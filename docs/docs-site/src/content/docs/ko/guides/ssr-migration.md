---
title: SSR 마이그레이션 가이드
description: 대규모 콘텐츠 사이트를 위해 SSG에서 SSR + D1으로 마이그레이션한 이유와 방법
---

이 가이드는 Context 앱이 **SSG + R2**에서 **SSR + D1 + Pages Functions**로 마이그레이션한 이유를 설명하고, 유사한 마이그레이션을 고려하는 분들을 위한 포괄적인 비교를 제공합니다.

:::tip[요약]
2,000개 이상의 엔트리 또는 자주 업데이트되는 콘텐츠가 있는 사이트의 경우, **SSR + D1이 유일한 해결책**입니다. SSG는 규모가 커지면 유지보수 악몽이 됩니다.
:::

---

## 마이그레이션 요약

| 이전 | 이후 |
|:----|:-----|
| SSG (정적 사이트 생성) | **SSR (서버 사이드 렌더링)** |
| R2 (객체 스토리지) | **D1 (SQL 데이터베이스)** |
| 16,836 HTML 파일 사전 빌드 | **요청 시 동적 생성** |
| ~15분 빌드 시간 | **~10초 빌드 시간** |
| 1.7GB 배포 크기 | **~50MB 배포 크기** |

---

## 상세 비교표

| 구분 | SSG + R2 (이전) | SSR + D1 + Functions (현재) | 효과 |
|:----|:---------------|:---------------------------|:-----|
| **렌더링** | | | |
| 방식 | 정적 사이트 생성 | 서버 사이드 렌더링 | 빌드 오류 완전 해결 |
| HTML 생성 | 빌드 시점 (사전 생성) | 런타임 (요청 시) | Cloudflare Pages 2만 파일 제한 돌파 |
| 물리적 파일 | `/entry/apple.html` 존재 | 파일 없음, 라우트 패턴만 | 배포 크기 99% 감소 |
| **SEO** | | | |
| URL 접근 | 파일 직접 접근 | 패턴 매칭 + 생성 | **동일** — 북마크/공유 동일하게 작동 |
| 검색 엔진 | 완성된 HTML 전송 | 완성된 HTML 생성 | **차이 없음** — Google은 둘 다 완전한 HTML을 봄 |
| 사이트맵 | 빌드 시 정적 XML | D1에서 동적 생성 | **더 나음** — 데이터 변경 시 자동 업데이트 |
| **데이터 저장소** | | | |
| 저장소 유형 | R2 (객체 스토리지) | D1 (SQL 데이터베이스) | SQL 쿼리로 검색/필터/정렬 가능 |
| 쿼리 방식 | 파일 fetch API | SQL WHERE 절 | 복잡한 쿼리 가능 |
| 조회 속도 | ~50ms (파일 읽기) | ~1ms (인덱스 쿼리) | 50배 빠른 데이터 조회 |
| **확장성** | | | |
| 10만 엔트리 | 청크 빌드 필요 | 행만 추가 | 아키텍처 변경 불필요 |
| 100만 엔트리 | 빌드 불가능 (OOM) | 완벽 작동 | D1은 수백만 행 처리 |
| KV vs D1 | - | KV: 일 10만 읽기, D1: 일 500만 읽기 | **D1이 50배 더 관대** |
| **빌드 프로세스** | | | |
| 빌드 시간 | 1-3시간 (2만 HTML) | 1-2분 | **50배 빠른 CI/CD** |
| 필요 메모리 | 8GB+ (OOM 위험) | 최소 | 안정적인 빌드 보장 |
| 데이터 변경 시 | 전체 재빌드 필요 | D1 UPDATE만 | **즉시 업데이트** (1초 미만) |
| **배포** | | | |
| 배포 시간 | 빌드 1-3시간 + 배포 10분 | 빌드 2분 + 배포 1분 | 긴급 수정 가능 |
| 배포 크기 | ~1.7GB (34,000+ 파일) | ~50MB | 97% 감소 |
| 인프라 | Pages만 | Pages + Functions (통합) | 단일 프로젝트 관리 |
| **성능** | | | |
| 응답 시간 | 50-100ms (CDN) | 첫 요청: 100-300ms, 캐시: 50-100ms | Edge Cache로 **동일한 속도** |
| 캐시 전략 | 자동 (정적 파일) | Cache-Control 헤더 | 80-90% 캐시 히트율 |
| **비용** | | | |
| R2 스토리지 | 1.7GB 사용 | 없음 | **스토리지 비용 제로** |
| R2 요청 | Class B: 월 1천만 무료 | 없음 | R2 요금 없음 |
| D1 요청 | 없음 | 일 500만 읽기 무료 | 무료 티어 충분 |
| Pro 플랜 | R2: 월 1억 | D1: 일 2,500만 읽기 | 7.5배 더 많은 용량 |
| **개발 경험** | | | |
| 로컬 테스트 | 빌드 후 프리뷰 | `wrangler dev` 즉시 | 즉각적인 피드백 |
| 데이터 추가 | 재빌드 + 재배포 | D1 INSERT | 몇 초 만에 데이터 반영 |
| 디버깅 | 빌드 로그 분석 | 런타임 로그 | 문제 해결 용이 |
| **사용자 경험** | | | |
| 초기 로드 | 완성된 HTML | 완성된 HTML | **동일** — 빠른 첫 페인트 |
| 네비게이션 | hydration 후 SPA | hydration 후 SPA | **동일** — 부드러운 전환 |
| JS 필요 | 아니오 (콘텐츠용) | 아니오 (콘텐츠용) | **동일** — JS 없이도 작동 |

---

## 마이그레이션 후에도 동일한 것

이 기능들은 마이그레이션 후에도 **완전히 동일**하게 작동합니다:

- ✅ **URL 직접 접근** — 모든 URL이 이전과 동일하게 작동
- ✅ **SEO 성능** — 검색 엔진은 동일한 완전한 HTML을 봄
- ✅ **사이트맵 생성** — 오히려 더 나음 (자동 업데이트)
- ✅ **사용자 경험** — 캐싱으로 동일한 속도
- ✅ **북마크/공유** — 모든 기능 유지

---

## 마이그레이션으로 얻는 것

SSR + D1의 새로운 이점:

- ✅ **빌드 지옥 탈출** — 1-3시간 → 2분
- ✅ **무제한 페이지** — 2만 제한 → 수백만
- ✅ **즉시 업데이트** — 재빌드 불필요
- ✅ **비용 절감** — R2 스토리지/요청 없음
- ✅ **운영 개선** — 몇 초 만에 핫픽스
- ✅ **인프라 단순화** — 단일 프로젝트

---

## 언제 어떤 모드를 사용할까

### SSG를 사용할 때:

- 콘텐츠가 **정적** (거의 변경되지 않음)
- 페이지 수가 **1,000개 미만**
- 빌드 시간이 **5분 미만**
- 실시간 데이터 요구 사항 없음

### SSR + D1을 사용할 때:

- 콘텐츠가 **동적** (자주 업데이트)
- 페이지 수가 **2,000개 이상** 또는 증가 중
- 재빌드 없이 **즉시 업데이트** 필요
- **10만 개 이상** 페이지로 확장 가능성 있음

---

## 마이그레이션 체크리스트

1. **D1 데이터베이스 설정**

   ```bash
   wrangler d1 create your-db
   wrangler d1 execute your-db --file=schema.sql
   ```

2. **react-router.config.ts 업데이트**

   ```typescript
   export default {
     ssr: true,  // false에서 변경
     async prerender() {
       // 정적 페이지만, 동적 콘텐츠 제외
       return staticRoutes;
     },
   } satisfies Config;
   ```

3. **loader를 D1 쿼리로 변환**

   ```typescript
   export async function loader({ params, context }) {
     const db = context.cloudflare.env.DB;
     return await db.prepare('SELECT * FROM entries WHERE id = ?')
       .bind(params.id).first();
   }
   ```

4. **wrangler.toml 설정**

   ```toml
   [[d1_databases]]
   binding = "DB"
   database_name = "your-db"
   database_id = "your-db-id"
   ```

5. **Functions용 _routes.json 업데이트**

   ```json
   {
     "include": ["/entry/*", "/ko/entry/*"],
     "exclude": []
   }
   ```

---

## 결론

**D1 + SSR + Functions = 대규모 콘텐츠 사이트의 유일한 정답**

2,000개 이상의 엔트리 또는 자주 업데이트되는 콘텐츠가 있다면, SSG는 유지보수 악몽입니다. SSR + D1은 다음을 제공합니다:

- 무제한 확장성
- 즉시 업데이트
- 낮은 비용
- 더 나은 개발 경험

이 모든 것이 **동일한 SEO와 사용자 경험**을 유지하면서 가능합니다.

---

## 관련 문서

- [렌더링 모드](/public-monorepo/ko/guides/ssg-deep-dive/) — SSG vs SSR 아키텍처
- [변경 로그 v3.0.0](/public-monorepo/ko/reference/changelog/) — 마이그레이션 상세
- [Context 앱 README](https://github.com/soundbluemusic/public-monorepo/tree/main/apps/context) — 현재 아키텍처
