[
  {
    "id": "numerical-error",
    "name": {
      "ko": "수치 오차",
      "en": "Numerical Error"
    },
    "field": "numerical",
    "subfield": "error-analysis",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수치 오차는 컴퓨터 계산에서 발생하는 오차입니다. 반올림 오차, 절단 오차, 전파 오차 등이 있습니다.",
        "formulas": [
          {
            "latex": "\\text{절대 오차} = |x - \\tilde{x}|",
            "description": "절대 오차"
          },
          {
            "latex": "\\text{상대 오차} = \\frac{|x - \\tilde{x}|}{|x|}",
            "description": "상대 오차"
          },
          {
            "latex": "\\epsilon_{\\text{machine}} \\approx 2.2 \\times 10^{-16}",
            "description": "배정밀도 기계 엡실론"
          }
        ],
        "examples": [
          {
            "problem": "참값이 π이고 근사값이 3.14일 때 상대 오차는?",
            "solution": "상대 오차 = |π - 3.14| / |π| ≈ 0.00159 / 3.14159 ≈ 0.05%"
          }
        ],
        "applications": [
          {
            "field": "과학 계산",
            "description": "계산 신뢰도 평가"
          },
          {
            "field": "금융",
            "description": "정밀 계산"
          },
          {
            "field": "공학",
            "description": "시뮬레이션 정확도"
          }
        ]
      },
      "en": {
        "definition": "Numerical error arises in computer calculations. Types include rounding error, truncation error, and propagation error.",
        "formulas": [
          {
            "latex": "\\text{Absolute error} = |x - \\tilde{x}|",
            "description": "Absolute error"
          },
          {
            "latex": "\\text{Relative error} = \\frac{|x - \\tilde{x}|}{|x|}",
            "description": "Relative error"
          },
          {
            "latex": "\\epsilon_{\\text{machine}} \\approx 2.2 \\times 10^{-16}",
            "description": "Double precision machine epsilon"
          }
        ],
        "examples": [
          {
            "problem": "If true value is π and approximation is 3.14, find relative error.",
            "solution": "Relative error = |π - 3.14| / |π| ≈ 0.00159 / 3.14159 ≈ 0.05%"
          }
        ],
        "applications": [
          {
            "field": "Scientific Computing",
            "description": "Calculation reliability"
          },
          {
            "field": "Finance",
            "description": "Precision calculations"
          },
          {
            "field": "Engineering",
            "description": "Simulation accuracy"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "floating-point"
      ],
      "nextTopics": [
        "stability-analysis",
        "conditioning"
      ],
      "related": [
        "approximation"
      ]
    },
    "tags": [
      "오차",
      "수치해석",
      "error",
      "numerical"
    ]
  },
  {
    "id": "newton-method",
    "name": {
      "ko": "뉴턴-랩슨 방법",
      "en": "Newton-Raphson Method"
    },
    "field": "numerical",
    "subfield": "root-finding",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "뉴턴-랩슨 방법은 f(x) = 0의 근을 찾는 반복법입니다. 접선을 이용해 빠르게 수렴합니다.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}",
            "description": "뉴턴-랩슨 반복 공식"
          }
        ],
        "examples": [
          {
            "problem": "√2를 뉴턴법으로 구하세요 (f(x) = x² - 2, x₀ = 1).",
            "solution": "x₁ = 1 - (1-2)/(2·1) = 1.5, x₂ = 1.5 - (0.25)/(3) ≈ 1.4167, x₃ ≈ 1.4142..."
          }
        ],
        "history": {
          "discoveredBy": "아이작 뉴턴, 조제프 랩슨",
          "year": "17세기",
          "background": "뉴턴이 다항식 근을 찾기 위해 개발했고, 랩슨이 일반화했습니다."
        },
        "applications": [
          {
            "field": "공학",
            "description": "비선형 방정식 풀이"
          },
          {
            "field": "최적화",
            "description": "뉴턴 최적화"
          },
          {
            "field": "컴퓨터 그래픽스",
            "description": "레이 트레이싱"
          }
        ]
      },
      "en": {
        "definition": "Newton-Raphson method is an iterative technique for finding roots of f(x) = 0. It uses tangent lines for fast convergence.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}",
            "description": "Newton-Raphson iteration formula"
          }
        ],
        "examples": [
          {
            "problem": "Find √2 using Newton's method (f(x) = x² - 2, x₀ = 1).",
            "solution": "x₁ = 1 - (1-2)/(2·1) = 1.5, x₂ = 1.5 - (0.25)/(3) ≈ 1.4167, x₃ ≈ 1.4142..."
          }
        ],
        "history": {
          "discoveredBy": "Isaac Newton, Joseph Raphson",
          "year": "17th century",
          "background": "Newton developed it for polynomial roots; Raphson generalized it."
        },
        "applications": [
          {
            "field": "Engineering",
            "description": "Nonlinear equation solving"
          },
          {
            "field": "Optimization",
            "description": "Newton optimization"
          },
          {
            "field": "Computer Graphics",
            "description": "Ray tracing"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "derivative",
        "limits"
      ],
      "nextTopics": [
        "secant-method",
        "fixed-point-iteration"
      ],
      "related": [
        "bisection"
      ]
    },
    "tags": [
      "뉴턴",
      "근찾기",
      "Newton",
      "root finding"
    ]
  },
  {
    "id": "numerical-integration",
    "name": {
      "ko": "수치 적분",
      "en": "Numerical Integration"
    },
    "field": "numerical",
    "subfield": "integration",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수치 적분은 정적분의 값을 근사적으로 계산하는 방법입니다. 사다리꼴 공식, 심프슨 공식 등이 있습니다.",
        "formulas": [
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{2}(f(a) + f(b))",
            "description": "사다리꼴 공식 (단일 구간)"
          },
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{3}(f(a) + 4f(m) + f(b))",
            "description": "심프슨 1/3 공식"
          }
        ],
        "examples": [
          {
            "problem": "심프슨 공식으로 ∫₀² x² dx를 계산하세요.",
            "solution": "h = 1, m = 1. S = (1/3)(0 + 4(1) + 4) = (1/3)(8) = 8/3 ≈ 2.67. 정확값 = 8/3 ✓"
          }
        ],
        "applications": [
          {
            "field": "물리학",
            "description": "궤적 계산"
          },
          {
            "field": "통계학",
            "description": "누적분포함수"
          },
          {
            "field": "공학",
            "description": "면적, 부피 계산"
          }
        ]
      },
      "en": {
        "definition": "Numerical integration approximates definite integral values. Methods include trapezoidal rule and Simpson's rule.",
        "formulas": [
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{2}(f(a) + f(b))",
            "description": "Trapezoidal rule (single interval)"
          },
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{3}(f(a) + 4f(m) + f(b))",
            "description": "Simpson's 1/3 rule"
          }
        ],
        "examples": [
          {
            "problem": "Calculate ∫₀² x² dx using Simpson's rule.",
            "solution": "h = 1, m = 1. S = (1/3)(0 + 4(1) + 4) = (1/3)(8) = 8/3 ≈ 2.67. Exact value = 8/3 ✓"
          }
        ],
        "applications": [
          {
            "field": "Physics",
            "description": "Trajectory calculation"
          },
          {
            "field": "Statistics",
            "description": "Cumulative distribution"
          },
          {
            "field": "Engineering",
            "description": "Area, volume calculation"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "integral"
      ],
      "nextTopics": [
        "gaussian-quadrature",
        "monte-carlo-integration"
      ],
      "related": [
        "riemann-sum"
      ]
    },
    "tags": [
      "수치적분",
      "심프슨",
      "numerical integration",
      "quadrature"
    ]
  },
  {
    "id": "interpolation",
    "name": {
      "ko": "보간법",
      "en": "Interpolation"
    },
    "field": "numerical",
    "subfield": "approximation",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "보간법은 주어진 데이터 점들 사이의 값을 추정하는 방법입니다. 다항식 보간, 스플라인 보간 등이 있습니다.",
        "formulas": [
          {
            "latex": "L(x) = \\sum_{i=0}^{n} y_i \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j}",
            "description": "라그랑주 보간 다항식"
          }
        ],
        "examples": [
          {
            "problem": "(0,1), (1,3), (2,7)을 지나는 라그랑주 보간다항식을 구하세요.",
            "solution": "L(x) = 1·(x-1)(x-2)/((0-1)(0-2)) + 3·x(x-2)/((1-0)(1-2)) + 7·x(x-1)/((2-0)(2-1)) = x² + x + 1"
          }
        ],
        "applications": [
          {
            "field": "컴퓨터 그래픽스",
            "description": "곡선/곡면 생성"
          },
          {
            "field": "신호 처리",
            "description": "리샘플링"
          },
          {
            "field": "데이터 분석",
            "description": "결측값 추정"
          }
        ]
      },
      "en": {
        "definition": "Interpolation estimates values between given data points. Methods include polynomial interpolation and spline interpolation.",
        "formulas": [
          {
            "latex": "L(x) = \\sum_{i=0}^{n} y_i \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j}",
            "description": "Lagrange interpolation polynomial"
          }
        ],
        "examples": [
          {
            "problem": "Find the Lagrange polynomial through (0,1), (1,3), (2,7).",
            "solution": "L(x) = 1·(x-1)(x-2)/((0-1)(0-2)) + 3·x(x-2)/((1-0)(1-2)) + 7·x(x-1)/((2-0)(2-1)) = x² + x + 1"
          }
        ],
        "applications": [
          {
            "field": "Computer Graphics",
            "description": "Curve/surface generation"
          },
          {
            "field": "Signal Processing",
            "description": "Resampling"
          },
          {
            "field": "Data Analysis",
            "description": "Missing value estimation"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "polynomial",
        "linear-algebra"
      ],
      "nextTopics": [
        "spline",
        "least-squares"
      ],
      "related": [
        "curve-fitting"
      ]
    },
    "tags": [
      "보간",
      "라그랑주",
      "interpolation",
      "Lagrange"
    ]
  },
  {
    "id": "numerical-ode",
    "name": {
      "ko": "미분방정식의 수치해법",
      "en": "Numerical ODE Methods"
    },
    "field": "numerical",
    "subfield": "ode",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "미분방정식의 수치해법은 해석적 해를 구하기 어려운 미분방정식의 해를 근사적으로 구하는 방법입니다.",
        "formulas": [
          {
            "latex": "y_{n+1} = y_n + h f(t_n, y_n)",
            "description": "오일러 방법 (전진)"
          },
          {
            "latex": "y_{n+1} = y_n + h f(t_n + h/2, y_n + \\frac{h}{2}f(t_n, y_n))",
            "description": "중점법 (2차 룽게-쿠타)"
          }
        ],
        "examples": [
          {
            "problem": "dy/dt = y, y(0) = 1을 오일러법으로 풀이하세요 (h = 0.1).",
            "solution": "y₁ = 1 + 0.1(1) = 1.1, y₂ = 1.1 + 0.1(1.1) = 1.21, ... (정확해: e^t)"
          }
        ],
        "applications": [
          {
            "field": "물리학",
            "description": "운동 시뮬레이션"
          },
          {
            "field": "공학",
            "description": "회로, 제어 시스템"
          },
          {
            "field": "생물학",
            "description": "개체군 모델"
          }
        ]
      },
      "en": {
        "definition": "Numerical ODE methods approximate solutions to differential equations that are difficult to solve analytically.",
        "formulas": [
          {
            "latex": "y_{n+1} = y_n + h f(t_n, y_n)",
            "description": "Euler method (forward)"
          },
          {
            "latex": "y_{n+1} = y_n + h f(t_n + h/2, y_n + \\frac{h}{2}f(t_n, y_n))",
            "description": "Midpoint method (RK2)"
          }
        ],
        "examples": [
          {
            "problem": "Solve dy/dt = y, y(0) = 1 using Euler method (h = 0.1).",
            "solution": "y₁ = 1 + 0.1(1) = 1.1, y₂ = 1.1 + 0.1(1.1) = 1.21, ... (exact: e^t)"
          }
        ],
        "applications": [
          {
            "field": "Physics",
            "description": "Motion simulation"
          },
          {
            "field": "Engineering",
            "description": "Circuits, control systems"
          },
          {
            "field": "Biology",
            "description": "Population models"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "derivative",
        "differential-equations"
      ],
      "nextTopics": [
        "runge-kutta",
        "stiff-equations"
      ],
      "related": [
        "stability"
      ]
    },
    "tags": [
      "미분방정식",
      "오일러",
      "ODE",
      "Euler"
    ]
  },
  {
    "id": "bisection-method",
    "name": {
      "ko": "이분법",
      "en": "Bisection Method"
    },
    "field": "numerical",
    "subfield": "root-finding",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "이분법은 연속함수의 근을 찾는 가장 간단한 방법입니다. 구간을 반으로 나누어 부호가 바뀌는 쪽으로 좁혀갑니다.",
        "formulas": [
          {
            "latex": "c = \\frac{a + b}{2}",
            "description": "중점 계산"
          },
          {
            "latex": "\\text{if } f(a)f(c) < 0: b = c, \\text{ else } a = c",
            "description": "구간 갱신 규칙"
          },
          {
            "latex": "|x_n - r| \\leq \\frac{b-a}{2^{n+1}}",
            "description": "n번 반복 후 오차 상한"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x² - 2의 근을 [1, 2]에서 이분법으로 찾으세요.",
            "solution": "f(1) = -1 < 0, f(2) = 2 > 0. c = 1.5, f(1.5) = 0.25 > 0. 새 구간 [1, 1.5]. c = 1.25, f(1.25) = -0.4375 < 0. [1.25, 1.5]... 계속하면 √2 ≈ 1.414로 수렴"
          }
        ],
        "applications": [
          {
            "field": "공학",
            "description": "안전한 근 탐색"
          },
          {
            "field": "컴퓨터 과학",
            "description": "이진 탐색의 수학적 기반"
          },
          {
            "field": "금융",
            "description": "손익분기점 계산"
          }
        ]
      },
      "en": {
        "definition": "Bisection method is the simplest root-finding method for continuous functions. It halves the interval, narrowing toward sign changes.",
        "formulas": [
          {
            "latex": "c = \\frac{a + b}{2}",
            "description": "Midpoint calculation"
          },
          {
            "latex": "\\text{if } f(a)f(c) < 0: b = c, \\text{ else } a = c",
            "description": "Interval update rule"
          },
          {
            "latex": "|x_n - r| \\leq \\frac{b-a}{2^{n+1}}",
            "description": "Error bound after n iterations"
          }
        ],
        "examples": [
          {
            "problem": "Find root of f(x) = x² - 2 in [1, 2] using bisection.",
            "solution": "f(1) = -1 < 0, f(2) = 2 > 0. c = 1.5, f(1.5) = 0.25 > 0. New interval [1, 1.5]. c = 1.25, f(1.25) = -0.4375 < 0. [1.25, 1.5]... Converges to √2 ≈ 1.414"
          }
        ],
        "applications": [
          {
            "field": "Engineering",
            "description": "Safe root finding"
          },
          {
            "field": "Computer Science",
            "description": "Mathematical basis of binary search"
          },
          {
            "field": "Finance",
            "description": "Break-even calculation"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "continuous-function",
        "intermediate-value-theorem"
      ],
      "nextTopics": [
        "newton-method",
        "secant-method"
      ],
      "related": [
        "binary-search"
      ]
    },
    "tags": [
      "이분법",
      "근찾기",
      "bisection",
      "root finding"
    ]
  },
  {
    "id": "runge-kutta",
    "name": {
      "ko": "룽게-쿠타 방법",
      "en": "Runge-Kutta Methods"
    },
    "field": "numerical",
    "subfield": "ode",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "룽게-쿠타 방법은 미분방정식의 수치해를 구하는 고정밀 방법입니다. 4차 방법(RK4)이 가장 널리 사용됩니다.",
        "formulas": [
          {
            "latex": "k_1 = f(t_n, y_n)",
            "description": "첫 번째 기울기"
          },
          {
            "latex": "k_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1)",
            "description": "두 번째 기울기"
          },
          {
            "latex": "k_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2)",
            "description": "세 번째 기울기"
          },
          {
            "latex": "k_4 = f(t_n + h, y_n + hk_3)",
            "description": "네 번째 기울기"
          },
          {
            "latex": "y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)",
            "description": "RK4 업데이트 공식"
          }
        ],
        "examples": [
          {
            "problem": "dy/dt = y, y(0) = 1에 RK4를 적용하세요 (h = 0.1).",
            "solution": "k₁ = 1, k₂ = 1.05, k₃ = 1.0525, k₄ = 1.10525. y₁ = 1 + (0.1/6)(1 + 2.1 + 2.105 + 1.10525) = 1.10517... (정확해 e^0.1 ≈ 1.10517)"
          }
        ],
        "history": {
          "discoveredBy": "카를 룽게, 마르틴 쿠타",
          "year": "1901년",
          "background": "오일러 방법의 정확도를 개선하기 위해 여러 기울기를 조합하는 방법을 개발했습니다."
        },
        "applications": [
          {
            "field": "물리 시뮬레이션",
            "description": "행성 궤도, 입자 운동"
          },
          {
            "field": "게임 개발",
            "description": "물리 엔진"
          },
          {
            "field": "공학",
            "description": "제어 시스템 시뮬레이션"
          }
        ]
      },
      "en": {
        "definition": "Runge-Kutta methods are high-precision techniques for numerical solutions of differential equations. Fourth-order (RK4) is most widely used.",
        "formulas": [
          {
            "latex": "k_1 = f(t_n, y_n)",
            "description": "First slope"
          },
          {
            "latex": "k_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1)",
            "description": "Second slope"
          },
          {
            "latex": "k_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2)",
            "description": "Third slope"
          },
          {
            "latex": "k_4 = f(t_n + h, y_n + hk_3)",
            "description": "Fourth slope"
          },
          {
            "latex": "y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)",
            "description": "RK4 update formula"
          }
        ],
        "examples": [
          {
            "problem": "Apply RK4 to dy/dt = y, y(0) = 1 with h = 0.1.",
            "solution": "k₁ = 1, k₂ = 1.05, k₃ = 1.0525, k₄ = 1.10525. y₁ = 1 + (0.1/6)(1 + 2.1 + 2.105 + 1.10525) = 1.10517... (exact e^0.1 ≈ 1.10517)"
          }
        ],
        "history": {
          "discoveredBy": "Carl Runge, Martin Kutta",
          "year": "1901",
          "background": "Developed combining multiple slopes to improve Euler method accuracy."
        },
        "applications": [
          {
            "field": "Physics Simulation",
            "description": "Orbital mechanics, particle motion"
          },
          {
            "field": "Game Development",
            "description": "Physics engines"
          },
          {
            "field": "Engineering",
            "description": "Control system simulation"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "numerical-ode",
        "taylor-series"
      ],
      "nextTopics": [
        "adaptive-methods",
        "stiff-equations"
      ],
      "related": [
        "euler-method"
      ]
    },
    "tags": [
      "룽게쿠타",
      "RK4",
      "Runge-Kutta",
      "ODE solver"
    ]
  },
  {
    "id": "matrix-factorization",
    "name": {
      "ko": "행렬 분해",
      "en": "Matrix Factorization"
    },
    "field": "numerical",
    "subfield": "linear-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "행렬 분해는 행렬을 더 간단한 행렬들의 곱으로 표현하는 것입니다. 연립방정식 풀이, 고유값 계산, 데이터 압축 등에 사용됩니다.",
        "formulas": [
          {
            "latex": "A = LU",
            "description": "LU 분해 (하삼각 × 상삼각)"
          },
          {
            "latex": "A = QR",
            "description": "QR 분해 (직교 × 상삼각)"
          },
          {
            "latex": "A = U\\Sigma V^T",
            "description": "특이값 분해 (SVD)"
          },
          {
            "latex": "A = LDL^T",
            "description": "촐레스키 분해 (대칭 양정치)"
          }
        ],
        "examples": [
          {
            "problem": "LU 분해를 이용해 Ax = b를 푸는 방법을 설명하세요.",
            "solution": "A = LU로 분해. Ly = b를 전진대입으로 풀고, Ux = y를 후진대입으로 풉니다. 같은 A에 대해 여러 b를 풀 때 효율적입니다."
          }
        ],
        "applications": [
          {
            "field": "수치선형대수",
            "description": "연립방정식 풀이"
          },
          {
            "field": "기계학습",
            "description": "차원 축소, 추천 시스템"
          },
          {
            "field": "이미지 처리",
            "description": "압축, 노이즈 제거"
          }
        ]
      },
      "en": {
        "definition": "Matrix factorization expresses a matrix as product of simpler matrices. Used for solving systems, eigenvalue computation, and data compression.",
        "formulas": [
          {
            "latex": "A = LU",
            "description": "LU decomposition (lower × upper triangular)"
          },
          {
            "latex": "A = QR",
            "description": "QR decomposition (orthogonal × upper triangular)"
          },
          {
            "latex": "A = U\\Sigma V^T",
            "description": "Singular Value Decomposition (SVD)"
          },
          {
            "latex": "A = LDL^T",
            "description": "Cholesky decomposition (symmetric positive definite)"
          }
        ],
        "examples": [
          {
            "problem": "Explain how to solve Ax = b using LU decomposition.",
            "solution": "Factor A = LU. Solve Ly = b by forward substitution, then Ux = y by back substitution. Efficient for multiple b with same A."
          }
        ],
        "applications": [
          {
            "field": "Numerical Linear Algebra",
            "description": "Solving linear systems"
          },
          {
            "field": "Machine Learning",
            "description": "Dimensionality reduction, recommender systems"
          },
          {
            "field": "Image Processing",
            "description": "Compression, denoising"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "matrices-basics",
        "determinant"
      ],
      "nextTopics": [
        "eigenvalues-eigenvectors",
        "iterative-methods"
      ],
      "related": [
        "gaussian-elimination"
      ]
    },
    "tags": [
      "행렬분해",
      "LU",
      "SVD",
      "matrix factorization"
    ]
  },
  {
    "id": "finite-difference",
    "name": {
      "ko": "유한 차분법",
      "en": "Finite Difference Method"
    },
    "field": "numerical",
    "subfield": "pde",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "유한 차분법은 미분을 차분으로 근사하여 미분방정식을 대수방정식으로 변환합니다. PDE의 수치해를 구하는 기본 방법입니다.",
        "formulas": [
          {
            "latex": "f'(x) \\approx \\frac{f(x+h) - f(x)}{h}",
            "description": "전진 차분"
          },
          {
            "latex": "f'(x) \\approx \\frac{f(x) - f(x-h)}{h}",
            "description": "후진 차분"
          },
          {
            "latex": "f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}",
            "description": "중심 차분"
          },
          {
            "latex": "f''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2}",
            "description": "2차 미분 근사"
          }
        ],
        "examples": [
          {
            "problem": "열 방정식 ∂u/∂t = α∂²u/∂x²를 차분으로 근사하세요.",
            "solution": "u(x,t+Δt) - u(x,t))/Δt = α(u(x+Δx,t) - 2u(x,t) + u(x-Δx,t))/Δx². 이를 정리하면 명시적 시간 진행 스킴이 됩니다."
          }
        ],
        "applications": [
          {
            "field": "전산유체역학",
            "description": "유동 시뮬레이션"
          },
          {
            "field": "열전달",
            "description": "온도 분포 계산"
          },
          {
            "field": "구조공학",
            "description": "응력 해석"
          }
        ]
      },
      "en": {
        "definition": "Finite difference method approximates derivatives with differences, converting differential equations to algebraic equations. Fundamental for numerical PDE solutions.",
        "formulas": [
          {
            "latex": "f'(x) \\approx \\frac{f(x+h) - f(x)}{h}",
            "description": "Forward difference"
          },
          {
            "latex": "f'(x) \\approx \\frac{f(x) - f(x-h)}{h}",
            "description": "Backward difference"
          },
          {
            "latex": "f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}",
            "description": "Central difference"
          },
          {
            "latex": "f''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2}",
            "description": "Second derivative approximation"
          }
        ],
        "examples": [
          {
            "problem": "Approximate heat equation ∂u/∂t = α∂²u/∂x² with finite differences.",
            "solution": "(u(x,t+Δt) - u(x,t))/Δt = α(u(x+Δx,t) - 2u(x,t) + u(x-Δx,t))/Δx². Rearranging gives explicit time-stepping scheme."
          }
        ],
        "applications": [
          {
            "field": "CFD",
            "description": "Flow simulation"
          },
          {
            "field": "Heat Transfer",
            "description": "Temperature distribution"
          },
          {
            "field": "Structural Engineering",
            "description": "Stress analysis"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "derivative",
        "partial-differential-equation"
      ],
      "nextTopics": [
        "finite-element",
        "stability-analysis"
      ],
      "related": [
        "interpolation"
      ]
    },
    "tags": [
      "유한차분",
      "PDE",
      "finite difference",
      "numerical PDE"
    ]
  }
]