[
  {
    "id": "natural-numbers",
    "name": { "ko": "자연수", "en": "Natural Numbers" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "1, 2, 3, 4, ... 처럼 물건을 셀 때 사용하는 양의 정수이다.",
        "formulas": [
          { "latex": "\\mathbb{N} = \\{1, 2, 3, 4, 5, ...\\}", "description": "자연수의 집합 표기" }
        ],
        "examples": [
          {
            "problem": "다음 중 자연수를 모두 고르시오: -3, 0, 5, 2.5, 100",
            "solution": "5와 100이 자연수입니다.\n-3은 음수, 0은 자연수가 아님, 2.5는 소수입니다.",
            "difficulty": 1
          },
          {
            "problem": "1부터 10까지 자연수의 합을 구하시오.",
            "solution": "1+2+3+4+5+6+7+8+9+10 = 55\n\n또는 공식 사용: n(n+1)/2 = 10×11/2 = 55",
            "latex": "\\sum_{k=1}^{10} k = \\frac{10 \\times 11}{2} = 55",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "일상생활", "description": "물건 개수 세기" },
          { "field": "컴퓨터", "description": "배열 인덱스, 반복 횟수" }
        ]
      },
      "en": {
        "definition": "Positive integers used for counting: 1, 2, 3, 4, ...",
        "formulas": [
          {
            "latex": "\\mathbb{N} = \\{1, 2, 3, 4, 5, ...\\}",
            "description": "Set notation for natural numbers"
          }
        ],
        "examples": [
          {
            "problem": "Select all natural numbers: -3, 0, 5, 2.5, 100",
            "solution": "5 and 100 are natural numbers.\n-3 is negative, 0 is not a natural number, 2.5 is decimal.",
            "difficulty": 1
          },
          {
            "problem": "Find the sum of natural numbers from 1 to 10.",
            "solution": "1+2+3+4+5+6+7+8+9+10 = 55\n\nOr using formula: n(n+1)/2 = 10×11/2 = 55",
            "latex": "\\sum_{k=1}^{10} k = \\frac{10 \\times 11}{2} = 55",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Daily life", "description": "Counting objects" },
          { "field": "Computing", "description": "Array indices, loop counts" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["integers", "arithmetic-operations"],
      "related": ["whole-numbers", "counting"],
      "applications": ["applied-daily-life"]
    },
    "tags": ["number", "fundamental", "counting", "elementary"]
  },
  {
    "id": "integers",
    "name": { "ko": "정수", "en": "Integers" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "양의 정수, 0, 음의 정수를 모두 포함하는 수의 집합이다.",
        "formulas": [
          {
            "latex": "\\mathbb{Z} = \\{..., -3, -2, -1, 0, 1, 2, 3, ...\\}",
            "description": "정수의 집합 표기"
          }
        ],
        "examples": [
          {
            "problem": "다음 중 정수를 모두 고르시오: -5, 0, 3.14, 7, -2.5",
            "solution": "-5, 0, 7이 정수입니다.\n3.14와 -2.5는 소수점이 있으므로 정수가 아닙니다.",
            "difficulty": 1
          },
          {
            "problem": "(-3) + 7 - (-2)를 계산하시오.",
            "solution": "(-3) + 7 - (-2) = -3 + 7 + 2 = 6\n\n음수를 빼면 더하는 것과 같습니다.",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "온도", "description": "영하 온도 표현 (예: -10°C)" },
          { "field": "금융", "description": "손실, 부채 표현" },
          { "field": "고도", "description": "해수면 아래 깊이" }
        ]
      },
      "en": {
        "definition": "The set of numbers including positive integers, zero, and negative integers.",
        "formulas": [
          {
            "latex": "\\mathbb{Z} = \\{..., -3, -2, -1, 0, 1, 2, 3, ...\\}",
            "description": "Set notation for integers"
          }
        ],
        "examples": [
          {
            "problem": "Select all integers: -5, 0, 3.14, 7, -2.5",
            "solution": "-5, 0, and 7 are integers.\n3.14 and -2.5 have decimal points, so they are not integers.",
            "difficulty": 1
          },
          {
            "problem": "Calculate (-3) + 7 - (-2).",
            "solution": "(-3) + 7 - (-2) = -3 + 7 + 2 = 6\n\nSubtracting a negative is the same as adding.",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Temperature", "description": "Below zero temperatures (e.g., -10°C)" },
          { "field": "Finance", "description": "Losses, debts" },
          { "field": "Elevation", "description": "Depths below sea level" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["natural-numbers"],
      "nextTopics": ["rational-numbers", "arithmetic-operations"],
      "related": ["number-line"],
      "applications": ["applied-daily-life", "applied-finance"]
    },
    "tags": ["number", "fundamental", "integer", "elementary"]
  },
  {
    "id": "rational-numbers",
    "name": { "ko": "유리수", "en": "Rational Numbers" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "두 정수의 비율(분수)로 나타낼 수 있는 수이다.",
        "formulas": [
          {
            "latex": "\\mathbb{Q} = \\left\\{ \\frac{a}{b} \\mid a, b \\in \\mathbb{Z}, b \\neq 0 \\right\\}",
            "description": "유리수의 집합 표기",
            "variables": [
              { "symbol": "a", "meaning": "분자 (정수)" },
              { "symbol": "b", "meaning": "분모 (0이 아닌 정수)" }
            ]
          }
        ],
        "examples": [
          {
            "problem": "다음 중 유리수를 고르시오: 1/2, √2, 0.333..., π",
            "solution": "1/2와 0.333...(=1/3)이 유리수입니다.\n√2와 π는 분수로 나타낼 수 없는 무리수입니다.",
            "difficulty": 1
          },
          {
            "problem": "0.75를 기약분수로 나타내시오.",
            "solution": "0.75 = 75/100 = 3/4\n\n75와 100을 25로 나누어 약분합니다.",
            "latex": "0.75 = \\frac{75}{100} = \\frac{3}{4}",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "측정", "description": "정확한 비율 표현" },
          { "field": "요리", "description": "레시피 재료 비율" }
        ]
      },
      "en": {
        "definition": "A number that can be expressed as a ratio (fraction) of two integers.",
        "formulas": [
          {
            "latex": "\\mathbb{Q} = \\left\\{ \\frac{a}{b} \\mid a, b \\in \\mathbb{Z}, b \\neq 0 \\right\\}",
            "description": "Set notation for rational numbers",
            "variables": [
              { "symbol": "a", "meaning": "Numerator (integer)" },
              { "symbol": "b", "meaning": "Denominator (non-zero integer)" }
            ]
          }
        ],
        "examples": [
          {
            "problem": "Select the rational numbers: 1/2, √2, 0.333..., π",
            "solution": "1/2 and 0.333...(=1/3) are rational.\n√2 and π cannot be expressed as fractions, so they are irrational.",
            "difficulty": 1
          },
          {
            "problem": "Express 0.75 as a fraction in lowest terms.",
            "solution": "0.75 = 75/100 = 3/4\n\nDivide both 75 and 100 by 25 to simplify.",
            "latex": "0.75 = \\frac{75}{100} = \\frac{3}{4}",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Measurement", "description": "Exact ratio expression" },
          { "field": "Cooking", "description": "Recipe ingredient ratios" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["integers", "fractions"],
      "nextTopics": ["irrational-numbers", "real-numbers"],
      "related": ["decimals"],
      "applications": ["applied-daily-life"]
    },
    "tags": ["number", "fundamental", "rational", "elementary"]
  },
  {
    "id": "irrational-numbers",
    "name": { "ko": "무리수", "en": "Irrational Numbers" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "분수로 나타낼 수 없는 수로, 소수점 이하가 무한히 계속되며 반복되지 않는다.",
        "formulas": [
          { "latex": "\\sqrt{2} = 1.41421356...", "description": "루트 2 (무한 비순환 소수)" },
          { "latex": "\\pi = 3.14159265...", "description": "원주율 파이" },
          { "latex": "e = 2.71828182...", "description": "자연상수 e" }
        ],
        "examples": [
          {
            "problem": "√2가 무리수임을 설명하시오.",
            "solution": "√2를 a/b (기약분수)로 나타낼 수 있다고 가정하면,\n2 = a²/b² → a² = 2b²\na²이 짝수이므로 a도 짝수, a = 2k라 하면\n4k² = 2b² → b² = 2k²\nb도 짝수가 되어 기약분수 가정에 모순.\n따라서 √2는 무리수이다.",
            "difficulty": 3
          },
          {
            "problem": "다음 중 무리수를 고르시오: √4, √5, 0.25, π/2",
            "solution": "√5와 π/2가 무리수입니다.\n√4 = 2 (정수), 0.25 = 1/4 (유리수)",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "기하학", "description": "대각선 길이, 원의 둘레" },
          { "field": "물리학", "description": "자연상수 e를 이용한 성장/붕괴" }
        ]
      },
      "en": {
        "definition": "A number that cannot be expressed as a fraction, with infinite non-repeating decimal expansion.",
        "formulas": [
          {
            "latex": "\\sqrt{2} = 1.41421356...",
            "description": "Square root of 2 (infinite non-repeating decimal)"
          },
          { "latex": "\\pi = 3.14159265...", "description": "Pi" },
          { "latex": "e = 2.71828182...", "description": "Euler's number e" }
        ],
        "examples": [
          {
            "problem": "Explain why √2 is irrational.",
            "solution": "Assume √2 = a/b (in lowest terms).\nThen 2 = a²/b² → a² = 2b²\nSince a² is even, a is even. Let a = 2k.\n4k² = 2b² → b² = 2k²\nSo b is also even, contradicting lowest terms.\nTherefore √2 is irrational.",
            "difficulty": 3
          },
          {
            "problem": "Select the irrational numbers: √4, √5, 0.25, π/2",
            "solution": "√5 and π/2 are irrational.\n√4 = 2 (integer), 0.25 = 1/4 (rational)",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Geometry", "description": "Diagonal lengths, circle circumference" },
          { "field": "Physics", "description": "Growth/decay using Euler's number e" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["rational-numbers", "square-roots"],
      "nextTopics": ["real-numbers"],
      "related": ["pi", "euler-number"],
      "applications": ["applied-physics"]
    },
    "tags": ["number", "fundamental", "irrational", "intermediate"]
  },
  {
    "id": "real-numbers",
    "name": { "ko": "실수", "en": "Real Numbers" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "유리수와 무리수를 모두 포함하는 수의 집합으로, 수직선 위의 모든 점에 대응한다.",
        "formulas": [
          {
            "latex": "\\mathbb{R} = \\mathbb{Q} \\cup \\mathbb{I}",
            "description": "실수 = 유리수 ∪ 무리수"
          },
          {
            "latex": "\\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{Q} \\subset \\mathbb{R}",
            "description": "수 체계의 포함 관계"
          }
        ],
        "examples": [
          {
            "problem": "수직선에서 √2의 위치를 설명하시오.",
            "solution": "√2 ≈ 1.414이므로 1과 2 사이에 위치합니다.\n정확히는 한 변이 1인 정사각형의 대각선 길이입니다.",
            "difficulty": 1
          },
          {
            "problem": "다음 수를 분류하시오: -3, 0.5, √3, π, 7",
            "solution": "자연수: 7\n정수: -3, 7\n유리수: -3, 0.5, 7\n무리수: √3, π\n실수: 모두 실수",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "물리학", "description": "연속적인 물리량 측정" },
          { "field": "공학", "description": "정밀한 계산과 측정" }
        ]
      },
      "en": {
        "definition": "The set of all rational and irrational numbers, corresponding to every point on the number line.",
        "formulas": [
          {
            "latex": "\\mathbb{R} = \\mathbb{Q} \\cup \\mathbb{I}",
            "description": "Real numbers = Rational ∪ Irrational"
          },
          {
            "latex": "\\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{Q} \\subset \\mathbb{R}",
            "description": "Number system hierarchy"
          }
        ],
        "examples": [
          {
            "problem": "Describe the position of √2 on the number line.",
            "solution": "√2 ≈ 1.414, so it lies between 1 and 2.\nIt's exactly the diagonal length of a unit square.",
            "difficulty": 1
          },
          {
            "problem": "Classify the following numbers: -3, 0.5, √3, π, 7",
            "solution": "Natural: 7\nInteger: -3, 7\nRational: -3, 0.5, 7\nIrrational: √3, π\nReal: all of them",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Continuous physical measurements" },
          { "field": "Engineering", "description": "Precise calculations and measurements" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["rational-numbers", "irrational-numbers"],
      "nextTopics": ["complex-numbers"],
      "related": ["number-line", "intervals"],
      "applications": ["applied-physics", "applied-engineering"]
    },
    "tags": ["number", "fundamental", "real", "intermediate"]
  },
  {
    "id": "arithmetic-operations",
    "name": { "ko": "사칙연산", "en": "Arithmetic Operations" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "덧셈, 뺄셈, 곱셈, 나눗셈의 네 가지 기본 연산이다.",
        "formulas": [
          { "latex": "a + b", "description": "덧셈 (합)" },
          { "latex": "a - b", "description": "뺄셈 (차)" },
          { "latex": "a \\times b = a \\cdot b = ab", "description": "곱셈 (곱)" },
          { "latex": "a \\div b = \\frac{a}{b}", "description": "나눗셈 (몫)" }
        ],
        "examples": [
          {
            "problem": "3 + 4 × 2 - 6 ÷ 3을 계산하시오.",
            "solution": "연산 순서: 곱셈/나눗셈 먼저, 덧셈/뺄셈 나중\n= 3 + 8 - 2\n= 9",
            "difficulty": 1
          },
          {
            "problem": "(12 + 8) ÷ 4 × 3을 계산하시오.",
            "solution": "괄호 먼저: 12 + 8 = 20\n왼쪽에서 오른쪽으로: 20 ÷ 4 = 5\n5 × 3 = 15",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "일상생활", "description": "쇼핑 계산, 거스름돈" },
          { "field": "프로그래밍", "description": "기본 연산자 (+, -, *, /)" }
        ]
      },
      "en": {
        "definition": "The four basic operations: addition, subtraction, multiplication, and division.",
        "formulas": [
          { "latex": "a + b", "description": "Addition (sum)" },
          { "latex": "a - b", "description": "Subtraction (difference)" },
          { "latex": "a \\times b = a \\cdot b = ab", "description": "Multiplication (product)" },
          { "latex": "a \\div b = \\frac{a}{b}", "description": "Division (quotient)" }
        ],
        "examples": [
          {
            "problem": "Calculate 3 + 4 × 2 - 6 ÷ 3.",
            "solution": "Order of operations: multiplication/division first\n= 3 + 8 - 2\n= 9",
            "difficulty": 1
          },
          {
            "problem": "Calculate (12 + 8) ÷ 4 × 3.",
            "solution": "Parentheses first: 12 + 8 = 20\nLeft to right: 20 ÷ 4 = 5\n5 × 3 = 15",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Daily life", "description": "Shopping calculations, change" },
          { "field": "Programming", "description": "Basic operators (+, -, *, /)" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["natural-numbers"],
      "nextTopics": ["exponents", "fractions"],
      "related": ["order-of-operations"],
      "applications": ["applied-daily-life", "applied-cs"]
    },
    "tags": ["operation", "fundamental", "arithmetic", "elementary"]
  },
  {
    "id": "exponents",
    "name": { "ko": "거듭제곱", "en": "Exponents" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "같은 수를 여러 번 곱하는 것을 간단히 나타낸 것이다.",
        "formulas": [
          {
            "latex": "a^n = \\underbrace{a \\times a \\times ... \\times a}_{n\\text{번}}",
            "description": "거듭제곱의 정의",
            "variables": [
              { "symbol": "a", "meaning": "밑 (base)" },
              { "symbol": "n", "meaning": "지수 (exponent)" }
            ]
          },
          { "latex": "a^m \\times a^n = a^{m+n}", "description": "지수법칙: 곱셈" },
          { "latex": "\\frac{a^m}{a^n} = a^{m-n}", "description": "지수법칙: 나눗셈" },
          { "latex": "(a^m)^n = a^{mn}", "description": "지수법칙: 거듭제곱의 거듭제곱" },
          { "latex": "a^0 = 1 \\quad (a \\neq 0)", "description": "0승은 1" }
        ],
        "examples": [
          {
            "problem": "2³ × 2⁴를 계산하시오.",
            "solution": "지수법칙 적용: 2³ × 2⁴ = 2³⁺⁴ = 2⁷ = 128",
            "latex": "2^3 \\times 2^4 = 2^{3+4} = 2^7 = 128",
            "difficulty": 1
          },
          {
            "problem": "(3²)³을 계산하시오.",
            "solution": "(3²)³ = 3²ˣ³ = 3⁶ = 729",
            "latex": "(3^2)^3 = 3^{2 \\times 3} = 3^6 = 729",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "과학", "description": "큰 수 표기 (예: 10⁹ = 10억)" },
          { "field": "컴퓨터", "description": "2의 거듭제곱 (메모리 크기)" },
          { "field": "금융", "description": "복리 계산" }
        ]
      },
      "en": {
        "definition": "A shorthand notation for multiplying a number by itself multiple times.",
        "formulas": [
          {
            "latex": "a^n = \\underbrace{a \\times a \\times ... \\times a}_{n\\text{ times}}",
            "description": "Definition of exponent",
            "variables": [
              { "symbol": "a", "meaning": "Base" },
              { "symbol": "n", "meaning": "Exponent" }
            ]
          },
          { "latex": "a^m \\times a^n = a^{m+n}", "description": "Exponent rule: multiplication" },
          { "latex": "\\frac{a^m}{a^n} = a^{m-n}", "description": "Exponent rule: division" },
          { "latex": "(a^m)^n = a^{mn}", "description": "Exponent rule: power of a power" },
          { "latex": "a^0 = 1 \\quad (a \\neq 0)", "description": "Zero exponent equals 1" }
        ],
        "examples": [
          {
            "problem": "Calculate 2³ × 2⁴.",
            "solution": "Using exponent rule: 2³ × 2⁴ = 2³⁺⁴ = 2⁷ = 128",
            "latex": "2^3 \\times 2^4 = 2^{3+4} = 2^7 = 128",
            "difficulty": 1
          },
          {
            "problem": "Calculate (3²)³.",
            "solution": "(3²)³ = 3²ˣ³ = 3⁶ = 729",
            "latex": "(3^2)^3 = 3^{2 \\times 3} = 3^6 = 729",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Science", "description": "Large number notation (e.g., 10⁹ = billion)" },
          { "field": "Computing", "description": "Powers of 2 (memory sizes)" },
          { "field": "Finance", "description": "Compound interest" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["arithmetic-operations"],
      "nextTopics": ["square-roots", "logarithms"],
      "related": ["scientific-notation"],
      "applications": ["applied-finance", "applied-cs"]
    },
    "tags": ["operation", "fundamental", "exponent", "elementary"]
  },
  {
    "id": "square-roots",
    "name": { "ko": "제곱근", "en": "Square Roots" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "제곱하여 어떤 수가 되는 수를 그 수의 제곱근이라 한다.",
        "formulas": [
          {
            "latex": "\\sqrt{a} = b \\iff b^2 = a \\quad (b \\geq 0)",
            "description": "제곱근의 정의"
          },
          { "latex": "\\sqrt{ab} = \\sqrt{a} \\cdot \\sqrt{b}", "description": "제곱근의 곱셈" },
          {
            "latex": "\\sqrt{\\frac{a}{b}} = \\frac{\\sqrt{a}}{\\sqrt{b}}",
            "description": "제곱근의 나눗셈"
          },
          { "latex": "\\sqrt{a^2} = |a|", "description": "제곱근과 제곱의 관계" }
        ],
        "examples": [
          {
            "problem": "√50을 간단히 하시오.",
            "solution": "√50 = √(25 × 2) = √25 × √2 = 5√2",
            "latex": "\\sqrt{50} = \\sqrt{25 \\times 2} = 5\\sqrt{2}",
            "difficulty": 1
          },
          {
            "problem": "√12 + √27을 간단히 하시오.",
            "solution": "√12 = 2√3, √27 = 3√3\n따라서 2√3 + 3√3 = 5√3",
            "latex": "\\sqrt{12} + \\sqrt{27} = 2\\sqrt{3} + 3\\sqrt{3} = 5\\sqrt{3}",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "기하학", "description": "피타고라스 정리에서 빗변 계산" },
          { "field": "물리학", "description": "거리, 속도 계산" }
        ]
      },
      "en": {
        "definition": "A number that, when squared, gives the original number.",
        "formulas": [
          {
            "latex": "\\sqrt{a} = b \\iff b^2 = a \\quad (b \\geq 0)",
            "description": "Definition of square root"
          },
          {
            "latex": "\\sqrt{ab} = \\sqrt{a} \\cdot \\sqrt{b}",
            "description": "Product rule for square roots"
          },
          {
            "latex": "\\sqrt{\\frac{a}{b}} = \\frac{\\sqrt{a}}{\\sqrt{b}}",
            "description": "Quotient rule for square roots"
          },
          { "latex": "\\sqrt{a^2} = |a|", "description": "Square root of a square" }
        ],
        "examples": [
          {
            "problem": "Simplify √50.",
            "solution": "√50 = √(25 × 2) = √25 × √2 = 5√2",
            "latex": "\\sqrt{50} = \\sqrt{25 \\times 2} = 5\\sqrt{2}",
            "difficulty": 1
          },
          {
            "problem": "Simplify √12 + √27.",
            "solution": "√12 = 2√3, √27 = 3√3\nSo 2√3 + 3√3 = 5√3",
            "latex": "\\sqrt{12} + \\sqrt{27} = 2\\sqrt{3} + 3\\sqrt{3} = 5\\sqrt{3}",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Geometry", "description": "Pythagorean theorem calculations" },
          { "field": "Physics", "description": "Distance, velocity calculations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["exponents"],
      "nextTopics": ["irrational-numbers", "nth-roots"],
      "related": ["pythagorean-theorem"],
      "applications": ["applied-physics"]
    },
    "tags": ["operation", "fundamental", "root", "elementary"]
  },
  {
    "id": "prime-numbers",
    "name": { "ko": "소수", "en": "Prime Numbers" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "1과 자기 자신만을 약수로 가지는 1보다 큰 자연수이다.",
        "formulas": [
          {
            "latex": "\\text{소수} = \\{2, 3, 5, 7, 11, 13, 17, 19, 23, ...\\}",
            "description": "처음 몇 개의 소수"
          }
        ],
        "examples": [
          {
            "problem": "1부터 20까지의 소수를 모두 구하시오.",
            "solution": "2, 3, 5, 7, 11, 13, 17, 19\n\n1은 소수가 아니고, 4, 6, 8, ... 등은 합성수입니다.",
            "difficulty": 1
          },
          {
            "problem": "84를 소인수분해하시오.",
            "solution": "84 = 2 × 42 = 2 × 2 × 21 = 2 × 2 × 3 × 7\n= 2² × 3 × 7",
            "latex": "84 = 2^2 \\times 3 \\times 7",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "암호학", "description": "RSA 암호화 알고리즘" },
          { "field": "컴퓨터과학", "description": "해시 함수, 난수 생성" }
        ]
      },
      "en": {
        "definition": "A natural number greater than 1 that has no positive divisors other than 1 and itself.",
        "formulas": [
          {
            "latex": "\\text{Primes} = \\{2, 3, 5, 7, 11, 13, 17, 19, 23, ...\\}",
            "description": "First several prime numbers"
          }
        ],
        "examples": [
          {
            "problem": "Find all prime numbers from 1 to 20.",
            "solution": "2, 3, 5, 7, 11, 13, 17, 19\n\n1 is not prime, and 4, 6, 8, ... are composite.",
            "difficulty": 1
          },
          {
            "problem": "Find the prime factorization of 84.",
            "solution": "84 = 2 × 42 = 2 × 2 × 21 = 2 × 2 × 3 × 7\n= 2² × 3 × 7",
            "latex": "84 = 2^2 \\times 3 \\times 7",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Cryptography", "description": "RSA encryption algorithm" },
          { "field": "Computer Science", "description": "Hash functions, random number generation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["natural-numbers"],
      "nextTopics": ["gcd-lcm", "prime-factorization"],
      "related": ["divisibility"],
      "applications": ["applied-cs", "cryptographic-number-theory"]
    },
    "tags": ["number", "fundamental", "prime", "elementary"]
  },
  {
    "id": "gcd-lcm",
    "name": { "ko": "최대공약수와 최소공배수", "en": "GCD and LCM" },
    "field": "foundations",
    "subfield": "arithmetic",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "최대공약수(GCD)는 두 수의 공통 약수 중 가장 큰 수이고, 최소공배수(LCM)는 공통 배수 중 가장 작은 수이다.",
        "formulas": [
          {
            "latex": "\\gcd(a, b) \\times \\text{lcm}(a, b) = a \\times b",
            "description": "GCD와 LCM의 관계"
          },
          { "latex": "\\gcd(a, b) = \\gcd(b, a \\mod b)", "description": "유클리드 호제법" }
        ],
        "examples": [
          {
            "problem": "GCD(24, 36)과 LCM(24, 36)을 구하시오.",
            "solution": "24 = 2³ × 3, 36 = 2² × 3²\nGCD = 2² × 3 = 12 (공통된 소인수의 최소 지수)\nLCM = 2³ × 3² = 72 (모든 소인수의 최대 지수)\n\n검산: 12 × 72 = 864 = 24 × 36 ✓",
            "difficulty": 1
          },
          {
            "problem": "유클리드 호제법으로 GCD(48, 18)을 구하시오.",
            "solution": "48 = 18 × 2 + 12\n18 = 12 × 1 + 6\n12 = 6 × 2 + 0\n\n나머지가 0이 되면 그 때의 나누는 수가 GCD\nGCD(48, 18) = 6",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "분수", "description": "약분, 통분" },
          { "field": "스케줄링", "description": "주기적 이벤트 동기화" },
          { "field": "암호학", "description": "RSA 키 생성" }
        ]
      },
      "en": {
        "definition": "GCD (Greatest Common Divisor) is the largest number that divides both numbers. LCM (Least Common Multiple) is the smallest number divisible by both.",
        "formulas": [
          {
            "latex": "\\gcd(a, b) \\times \\text{lcm}(a, b) = a \\times b",
            "description": "Relationship between GCD and LCM"
          },
          { "latex": "\\gcd(a, b) = \\gcd(b, a \\mod b)", "description": "Euclidean algorithm" }
        ],
        "examples": [
          {
            "problem": "Find GCD(24, 36) and LCM(24, 36).",
            "solution": "24 = 2³ × 3, 36 = 2² × 3²\nGCD = 2² × 3 = 12 (min exponents of common factors)\nLCM = 2³ × 3² = 72 (max exponents of all factors)\n\nCheck: 12 × 72 = 864 = 24 × 36 ✓",
            "difficulty": 1
          },
          {
            "problem": "Find GCD(48, 18) using Euclidean algorithm.",
            "solution": "48 = 18 × 2 + 12\n18 = 12 × 1 + 6\n12 = 6 × 2 + 0\n\nWhen remainder is 0, the divisor is the GCD.\nGCD(48, 18) = 6",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Fractions", "description": "Simplifying, finding common denominators" },
          { "field": "Scheduling", "description": "Synchronizing periodic events" },
          { "field": "Cryptography", "description": "RSA key generation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["prime-numbers"],
      "nextTopics": ["modular-arithmetic"],
      "related": ["divisibility", "fractions"],
      "applications": ["applied-cs", "cryptographic-number-theory"]
    },
    "tags": ["number", "fundamental", "gcd", "lcm", "elementary"]
  },
  {
    "id": "fractions",
    "name": { "ko": "분수", "en": "Fractions" },
    "field": "foundations",
    "subfield": "fractions-ratios",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "전체를 똑같이 나눈 것 중 일부를 나타내는 수이다.",
        "formulas": [
          {
            "latex": "\\frac{a}{b}",
            "description": "분수의 기본 형태",
            "variables": [
              { "symbol": "a", "meaning": "분자 (나눈 것 중 취한 부분)" },
              { "symbol": "b", "meaning": "분모 (전체를 나눈 수, b≠0)" }
            ]
          },
          {
            "latex": "\\frac{a}{b} + \\frac{c}{d} = \\frac{ad + bc}{bd}",
            "description": "분수의 덧셈"
          },
          {
            "latex": "\\frac{a}{b} \\times \\frac{c}{d} = \\frac{ac}{bd}",
            "description": "분수의 곱셈"
          },
          {
            "latex": "\\frac{a}{b} \\div \\frac{c}{d} = \\frac{a}{b} \\times \\frac{d}{c} = \\frac{ad}{bc}",
            "description": "분수의 나눗셈"
          }
        ],
        "examples": [
          {
            "problem": "1/2 + 1/3을 계산하시오.",
            "solution": "통분: 1/2 = 3/6, 1/3 = 2/6\n따라서 3/6 + 2/6 = 5/6",
            "latex": "\\frac{1}{2} + \\frac{1}{3} = \\frac{3}{6} + \\frac{2}{6} = \\frac{5}{6}",
            "difficulty": 1
          },
          {
            "problem": "2/3 ÷ 4/5를 계산하시오.",
            "solution": "나눗셈은 역수를 곱합니다.\n2/3 × 5/4 = 10/12 = 5/6",
            "latex": "\\frac{2}{3} \\div \\frac{4}{5} = \\frac{2}{3} \\times \\frac{5}{4} = \\frac{10}{12} = \\frac{5}{6}",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "요리", "description": "재료 비율 계산" },
          { "field": "음악", "description": "박자와 음표 길이" }
        ]
      },
      "en": {
        "definition": "A number representing part of a whole divided into equal parts.",
        "formulas": [
          {
            "latex": "\\frac{a}{b}",
            "description": "Basic fraction form",
            "variables": [
              { "symbol": "a", "meaning": "Numerator (parts taken)" },
              { "symbol": "b", "meaning": "Denominator (total parts, b≠0)" }
            ]
          },
          {
            "latex": "\\frac{a}{b} + \\frac{c}{d} = \\frac{ad + bc}{bd}",
            "description": "Fraction addition"
          },
          {
            "latex": "\\frac{a}{b} \\times \\frac{c}{d} = \\frac{ac}{bd}",
            "description": "Fraction multiplication"
          },
          {
            "latex": "\\frac{a}{b} \\div \\frac{c}{d} = \\frac{a}{b} \\times \\frac{d}{c} = \\frac{ad}{bc}",
            "description": "Fraction division"
          }
        ],
        "examples": [
          {
            "problem": "Calculate 1/2 + 1/3.",
            "solution": "Common denominator: 1/2 = 3/6, 1/3 = 2/6\nSo 3/6 + 2/6 = 5/6",
            "latex": "\\frac{1}{2} + \\frac{1}{3} = \\frac{3}{6} + \\frac{2}{6} = \\frac{5}{6}",
            "difficulty": 1
          },
          {
            "problem": "Calculate 2/3 ÷ 4/5.",
            "solution": "Division means multiply by reciprocal.\n2/3 × 5/4 = 10/12 = 5/6",
            "latex": "\\frac{2}{3} \\div \\frac{4}{5} = \\frac{2}{3} \\times \\frac{5}{4} = \\frac{10}{12} = \\frac{5}{6}",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Cooking", "description": "Recipe proportions" },
          { "field": "Music", "description": "Time signatures and note durations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["natural-numbers", "arithmetic-operations"],
      "nextTopics": ["decimals", "ratios", "percentages"],
      "related": ["gcd-lcm"],
      "applications": ["applied-daily-life", "applied-music"]
    },
    "tags": ["number", "fundamental", "fraction", "elementary"]
  },
  {
    "id": "decimals",
    "name": { "ko": "소수 (小數)", "en": "Decimals" },
    "field": "foundations",
    "subfield": "fractions-ratios",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "소수점을 사용하여 1보다 작은 부분을 10의 거듭제곱 분의 1로 나타낸 수이다.",
        "formulas": [
          {
            "latex": "0.abc = \\frac{a}{10} + \\frac{b}{100} + \\frac{c}{1000}",
            "description": "소수의 자릿값"
          }
        ],
        "examples": [
          { "problem": "3/8을 소수로 나타내시오.", "solution": "3 ÷ 8 = 0.375", "difficulty": 1 },
          {
            "problem": "0.125를 기약분수로 나타내시오.",
            "solution": "0.125 = 125/1000 = 1/8\n\n125와 1000을 125로 나눕니다.",
            "latex": "0.125 = \\frac{125}{1000} = \\frac{1}{8}",
            "difficulty": 1
          },
          {
            "problem": "순환소수 0.333...을 분수로 나타내시오.",
            "solution": "x = 0.333...\n10x = 3.333...\n10x - x = 3\n9x = 3\nx = 1/3",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "화폐", "description": "금액 표시" },
          { "field": "측정", "description": "정밀한 길이, 무게" }
        ]
      },
      "en": {
        "definition": "A number written using a decimal point to represent fractional parts as powers of ten.",
        "formulas": [
          {
            "latex": "0.abc = \\frac{a}{10} + \\frac{b}{100} + \\frac{c}{1000}",
            "description": "Decimal place values"
          }
        ],
        "examples": [
          { "problem": "Convert 3/8 to a decimal.", "solution": "3 ÷ 8 = 0.375", "difficulty": 1 },
          {
            "problem": "Convert 0.125 to a fraction in lowest terms.",
            "solution": "0.125 = 125/1000 = 1/8\n\nDivide both by 125.",
            "latex": "0.125 = \\frac{125}{1000} = \\frac{1}{8}",
            "difficulty": 1
          },
          {
            "problem": "Convert repeating decimal 0.333... to a fraction.",
            "solution": "Let x = 0.333...\n10x = 3.333...\n10x - x = 3\n9x = 3\nx = 1/3",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Currency", "description": "Money amounts" },
          { "field": "Measurement", "description": "Precise lengths, weights" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["fractions"],
      "nextTopics": ["percentages"],
      "related": ["rational-numbers"],
      "applications": ["applied-daily-life", "applied-finance"]
    },
    "tags": ["number", "fundamental", "decimal", "elementary"]
  },
  {
    "id": "percentages",
    "name": { "ko": "백분율", "en": "Percentages" },
    "field": "foundations",
    "subfield": "fractions-ratios",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "전체를 100으로 볼 때 차지하는 비율을 나타낸 것이다.",
        "formulas": [
          { "latex": "p\\% = \\frac{p}{100}", "description": "백분율을 분수로" },
          {
            "latex": "\\text{백분율} = \\frac{\\text{부분}}{\\text{전체}} \\times 100\\%",
            "description": "백분율 계산"
          }
        ],
        "examples": [
          {
            "problem": "80명 중 20명이 합격했다면 합격률은?",
            "solution": "합격률 = (20/80) × 100% = 25%",
            "difficulty": 1
          },
          {
            "problem": "원래 가격 50,000원에서 20% 할인하면?",
            "solution": "할인액 = 50,000 × 0.20 = 10,000원\n할인가 = 50,000 - 10,000 = 40,000원",
            "difficulty": 1
          },
          {
            "problem": "가격이 80,000원에서 100,000원으로 오르면 인상률은?",
            "solution": "인상액 = 100,000 - 80,000 = 20,000원\n인상률 = (20,000/80,000) × 100% = 25%",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "금융", "description": "이자율, 수익률, 세율" },
          { "field": "통계", "description": "설문조사 결과" },
          { "field": "쇼핑", "description": "할인율 계산" }
        ]
      },
      "en": {
        "definition": "A ratio expressed as a fraction of 100.",
        "formulas": [
          { "latex": "p\\% = \\frac{p}{100}", "description": "Percentage to fraction" },
          {
            "latex": "\\text{Percentage} = \\frac{\\text{Part}}{\\text{Whole}} \\times 100\\%",
            "description": "Percentage calculation"
          }
        ],
        "examples": [
          {
            "problem": "If 20 out of 80 people passed, what is the pass rate?",
            "solution": "Pass rate = (20/80) × 100% = 25%",
            "difficulty": 1
          },
          {
            "problem": "What is the price after a 20% discount on $50?",
            "solution": "Discount = 50 × 0.20 = $10\nFinal price = 50 - 10 = $40",
            "difficulty": 1
          },
          {
            "problem": "If price increases from $80 to $100, what is the percent increase?",
            "solution": "Increase = 100 - 80 = $20\nPercent increase = (20/80) × 100% = 25%",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Finance", "description": "Interest rates, returns, taxes" },
          { "field": "Statistics", "description": "Survey results" },
          { "field": "Shopping", "description": "Discount calculations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["fractions", "decimals"],
      "nextTopics": ["ratios", "proportions"],
      "related": ["statistics-basics"],
      "applications": ["applied-finance", "applied-daily-life"]
    },
    "tags": ["number", "fundamental", "percentage", "elementary"]
  },
  {
    "id": "ratios",
    "name": { "ko": "비", "en": "Ratios" },
    "field": "foundations",
    "subfield": "fractions-ratios",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "두 수의 상대적인 크기를 비교하는 것으로, a:b 또는 a/b로 나타낸다.",
        "formulas": [
          { "latex": "a : b = \\frac{a}{b}", "description": "비의 표기" },
          {
            "latex": "a : b = ka : kb \\quad (k \\neq 0)",
            "description": "비의 성질 (같은 수를 곱해도 같다)"
          }
        ],
        "examples": [
          {
            "problem": "12:18을 가장 간단한 정수의 비로 나타내시오.",
            "solution": "GCD(12, 18) = 6\n12:18 = 2:3",
            "difficulty": 1
          },
          {
            "problem": "A와 B가 2:3으로 72,000원을 나누면 각자 얼마?",
            "solution": "전체 비 = 2 + 3 = 5\nA = 72,000 × (2/5) = 28,800원\nB = 72,000 × (3/5) = 43,200원",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "요리", "description": "재료 배합 비율" },
          { "field": "지도", "description": "축척 (예: 1:50,000)" },
          { "field": "금융", "description": "투자 비율" }
        ]
      },
      "en": {
        "definition": "A comparison of the relative sizes of two numbers, written as a:b or a/b.",
        "formulas": [
          { "latex": "a : b = \\frac{a}{b}", "description": "Ratio notation" },
          {
            "latex": "a : b = ka : kb \\quad (k \\neq 0)",
            "description": "Property of ratios (multiplying both by same number)"
          }
        ],
        "examples": [
          {
            "problem": "Simplify the ratio 12:18.",
            "solution": "GCD(12, 18) = 6\n12:18 = 2:3",
            "difficulty": 1
          },
          {
            "problem": "A and B share $72,000 in ratio 2:3. How much does each get?",
            "solution": "Total parts = 2 + 3 = 5\nA = 72,000 × (2/5) = $28,800\nB = 72,000 × (3/5) = $43,200",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Cooking", "description": "Ingredient proportions" },
          { "field": "Maps", "description": "Scale (e.g., 1:50,000)" },
          { "field": "Finance", "description": "Investment allocation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["fractions", "gcd-lcm"],
      "nextTopics": ["proportions"],
      "related": ["percentages"],
      "applications": ["applied-daily-life", "applied-art"]
    },
    "tags": ["number", "fundamental", "ratio", "elementary"]
  },
  {
    "id": "proportions",
    "name": { "ko": "비례", "en": "Proportions" },
    "field": "foundations",
    "subfield": "fractions-ratios",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "두 비가 같다는 것을 나타내는 등식이다.",
        "formulas": [
          {
            "latex": "a : b = c : d \\iff \\frac{a}{b} = \\frac{c}{d} \\iff ad = bc",
            "description": "비례식과 내항외항의 곱"
          },
          { "latex": "y = kx", "description": "정비례 (k는 비례상수)" },
          { "latex": "y = \\frac{k}{x}", "description": "반비례" }
        ],
        "examples": [
          {
            "problem": "3:5 = x:20에서 x를 구하시오.",
            "solution": "내항의 곱 = 외항의 곱\n5x = 3 × 20 = 60\nx = 12",
            "difficulty": 1
          },
          {
            "problem": "4시간에 120km를 간다면 6시간에는 얼마나 갈 수 있는가?",
            "solution": "4:120 = 6:x\n4x = 120 × 6 = 720\nx = 180km",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "물리학", "description": "속도, 힘, 압력 관계" },
          { "field": "요리", "description": "레시피 인원수 조정" },
          { "field": "건축", "description": "설계도 비율" }
        ]
      },
      "en": {
        "definition": "An equation stating that two ratios are equal.",
        "formulas": [
          {
            "latex": "a : b = c : d \\iff \\frac{a}{b} = \\frac{c}{d} \\iff ad = bc",
            "description": "Proportion and cross multiplication"
          },
          {
            "latex": "y = kx",
            "description": "Direct proportion (k is constant of proportionality)"
          },
          { "latex": "y = \\frac{k}{x}", "description": "Inverse proportion" }
        ],
        "examples": [
          {
            "problem": "Find x in 3:5 = x:20.",
            "solution": "Cross multiply:\n5x = 3 × 20 = 60\nx = 12",
            "difficulty": 1
          },
          {
            "problem": "If you travel 120km in 4 hours, how far in 6 hours?",
            "solution": "4:120 = 6:x\n4x = 120 × 6 = 720\nx = 180km",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Speed, force, pressure relationships" },
          { "field": "Cooking", "description": "Scaling recipes" },
          { "field": "Architecture", "description": "Blueprint scaling" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["ratios"],
      "nextTopics": ["linear-equations", "similar-triangles"],
      "related": ["percentages"],
      "applications": ["applied-physics", "applied-daily-life"]
    },
    "tags": ["number", "fundamental", "proportion", "elementary"]
  },
  {
    "id": "binary",
    "name": { "ko": "이진법", "en": "Binary System" },
    "field": "foundations",
    "subfield": "number-systems",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "0과 1 두 숫자만 사용하여 수를 나타내는 방법이다.",
        "formulas": [
          {
            "latex": "(a_na_{n-1}...a_1a_0)_2 = \\sum_{i=0}^{n} a_i \\cdot 2^i",
            "description": "이진수를 십진수로 변환"
          }
        ],
        "examples": [
          {
            "problem": "이진수 1011₂를 십진수로 변환하시오.",
            "solution": "1011₂ = 1×2³ + 0×2² + 1×2¹ + 1×2⁰\n= 8 + 0 + 2 + 1 = 11",
            "difficulty": 1
          },
          {
            "problem": "십진수 25를 이진수로 변환하시오.",
            "solution": "25 ÷ 2 = 12 ... 1\n12 ÷ 2 = 6 ... 0\n6 ÷ 2 = 3 ... 0\n3 ÷ 2 = 1 ... 1\n1 ÷ 2 = 0 ... 1\n\n아래에서 위로 읽으면: 11001₂",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "컴퓨터", "description": "모든 디지털 데이터의 기본" },
          { "field": "전자공학", "description": "논리회로, 스위치" }
        ]
      },
      "en": {
        "definition": "A number system using only two digits: 0 and 1.",
        "formulas": [
          {
            "latex": "(a_na_{n-1}...a_1a_0)_2 = \\sum_{i=0}^{n} a_i \\cdot 2^i",
            "description": "Binary to decimal conversion"
          }
        ],
        "examples": [
          {
            "problem": "Convert binary 1011₂ to decimal.",
            "solution": "1011₂ = 1×2³ + 0×2² + 1×2¹ + 1×2⁰\n= 8 + 0 + 2 + 1 = 11",
            "difficulty": 1
          },
          {
            "problem": "Convert decimal 25 to binary.",
            "solution": "25 ÷ 2 = 12 r 1\n12 ÷ 2 = 6 r 0\n6 ÷ 2 = 3 r 0\n3 ÷ 2 = 1 r 1\n1 ÷ 2 = 0 r 1\n\nRead bottom-up: 11001₂",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Computing", "description": "Foundation of all digital data" },
          { "field": "Electronics", "description": "Logic circuits, switches" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["exponents", "arithmetic-operations"],
      "nextTopics": ["octal", "hexadecimal"],
      "related": ["boolean-algebra"],
      "applications": ["applied-cs"]
    },
    "tags": ["number-system", "binary", "computing", "intermediate"]
  },
  {
    "id": "octal",
    "name": { "ko": "8진법", "en": "Octal System" },
    "field": "foundations",
    "subfield": "number-systems",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "0부터 7까지 8개의 숫자를 사용하여 수를 나타내는 방법이다.",
        "formulas": [
          {
            "latex": "(a_na_{n-1}...a_1a_0)_8 = \\sum_{i=0}^{n} a_i \\cdot 8^i",
            "description": "8진수를 십진수로 변환"
          }
        ],
        "examples": [
          {
            "problem": "8진수 752₈을 십진수로 변환하시오.",
            "solution": "752₈ = 7×8² + 5×8¹ + 2×8⁰\n= 7×64 + 5×8 + 2×1\n= 448 + 40 + 2 = 490",
            "difficulty": 1
          },
          {
            "problem": "이진수 110101₂를 8진수로 변환하시오.",
            "solution": "3자리씩 묶음: 110 101\n110₂ = 6, 101₂ = 5\n따라서 65₈",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "유닉스/리눅스", "description": "파일 권한 (예: chmod 755)" },
          { "field": "컴퓨터과학", "description": "이진수의 간략한 표현" }
        ]
      },
      "en": {
        "definition": "A number system using digits 0 through 7.",
        "formulas": [
          {
            "latex": "(a_na_{n-1}...a_1a_0)_8 = \\sum_{i=0}^{n} a_i \\cdot 8^i",
            "description": "Octal to decimal conversion"
          }
        ],
        "examples": [
          {
            "problem": "Convert octal 752₈ to decimal.",
            "solution": "752₈ = 7×8² + 5×8¹ + 2×8⁰\n= 7×64 + 5×8 + 2×1\n= 448 + 40 + 2 = 490",
            "difficulty": 1
          },
          {
            "problem": "Convert binary 110101₂ to octal.",
            "solution": "Group in threes: 110 101\n110₂ = 6, 101₂ = 5\nAnswer: 65₈",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Unix/Linux", "description": "File permissions (e.g., chmod 755)" },
          { "field": "Computer Science", "description": "Compact binary representation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["binary"],
      "nextTopics": ["hexadecimal"],
      "related": ["exponents"],
      "applications": ["applied-cs"]
    },
    "tags": ["number-system", "octal", "computing", "intermediate"]
  },
  {
    "id": "hexadecimal",
    "name": { "ko": "16진법", "en": "Hexadecimal System" },
    "field": "foundations",
    "subfield": "number-systems",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "0-9와 A-F(10-15)를 사용하여 16개의 숫자로 수를 나타내는 방법이다.",
        "formulas": [
          {
            "latex": "(a_na_{n-1}...a_1a_0)_{16} = \\sum_{i=0}^{n} a_i \\cdot 16^i",
            "description": "16진수를 십진수로 변환"
          }
        ],
        "examples": [
          {
            "problem": "16진수 2F₁₆를 십진수로 변환하시오.",
            "solution": "2F₁₆ = 2×16¹ + F×16⁰\n= 2×16 + 15×1\n= 32 + 15 = 47",
            "difficulty": 1
          },
          {
            "problem": "색상 코드 #FF5733에서 RGB 값을 구하시오.",
            "solution": "R = FF₁₆ = 255\nG = 57₁₆ = 5×16 + 7 = 87\nB = 33₁₆ = 3×16 + 3 = 51\n\nRGB(255, 87, 51)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "웹/그래픽", "description": "색상 코드 (#RRGGBB)" },
          { "field": "프로그래밍", "description": "메모리 주소, 바이너리 데이터" },
          { "field": "네트워크", "description": "MAC 주소, IPv6" }
        ]
      },
      "en": {
        "definition": "A number system using 16 symbols: 0-9 and A-F (representing 10-15).",
        "formulas": [
          {
            "latex": "(a_na_{n-1}...a_1a_0)_{16} = \\sum_{i=0}^{n} a_i \\cdot 16^i",
            "description": "Hexadecimal to decimal conversion"
          }
        ],
        "examples": [
          {
            "problem": "Convert hexadecimal 2F₁₆ to decimal.",
            "solution": "2F₁₆ = 2×16¹ + F×16⁰\n= 2×16 + 15×1\n= 32 + 15 = 47",
            "difficulty": 1
          },
          {
            "problem": "Find RGB values from color code #FF5733.",
            "solution": "R = FF₁₆ = 255\nG = 57₁₆ = 5×16 + 7 = 87\nB = 33₁₆ = 3×16 + 3 = 51\n\nRGB(255, 87, 51)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Web/Graphics", "description": "Color codes (#RRGGBB)" },
          { "field": "Programming", "description": "Memory addresses, binary data" },
          { "field": "Networking", "description": "MAC addresses, IPv6" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["binary", "octal"],
      "nextTopics": ["color-theory"],
      "related": ["exponents"],
      "applications": ["applied-cs", "applied-art"]
    },
    "tags": ["number-system", "hexadecimal", "computing", "intermediate"]
  },
  {
    "id": "complex-numbers",
    "name": { "ko": "복소수", "en": "Complex Numbers" },
    "field": "foundations",
    "subfield": "number-systems",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "실수와 허수를 결합한 수로, a + bi 형태로 나타낸다 (i² = -1).",
        "formulas": [
          {
            "latex": "z = a + bi",
            "description": "복소수의 표준형",
            "variables": [
              { "symbol": "a", "meaning": "실수부 (Real part)" },
              { "symbol": "b", "meaning": "허수부 (Imaginary part)" },
              { "symbol": "i", "meaning": "허수 단위 (i² = -1)" }
            ]
          },
          { "latex": "|z| = \\sqrt{a^2 + b^2}", "description": "복소수의 절댓값 (크기)" },
          { "latex": "\\bar{z} = a - bi", "description": "켤레복소수" },
          { "latex": "(a+bi)(c+di) = (ac-bd) + (ad+bc)i", "description": "복소수의 곱셈" }
        ],
        "examples": [
          {
            "problem": "(3 + 2i) + (1 - 4i)를 계산하시오.",
            "solution": "실수부끼리, 허수부끼리 더합니다.\n(3+1) + (2-4)i = 4 - 2i",
            "difficulty": 1
          },
          {
            "problem": "(2 + 3i)(1 - 2i)를 계산하시오.",
            "solution": "= 2×1 + 2×(-2i) + 3i×1 + 3i×(-2i)\n= 2 - 4i + 3i - 6i²\n= 2 - i - 6(-1)\n= 2 - i + 6 = 8 - i",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "전자공학", "description": "교류 회로 분석" },
          { "field": "물리학", "description": "양자역학, 파동" },
          { "field": "컴퓨터 그래픽", "description": "2D 회전, 프랙탈" }
        ]
      },
      "en": {
        "definition": "A number combining real and imaginary parts, written as a + bi where i² = -1.",
        "formulas": [
          {
            "latex": "z = a + bi",
            "description": "Standard form of complex number",
            "variables": [
              { "symbol": "a", "meaning": "Real part" },
              { "symbol": "b", "meaning": "Imaginary part" },
              { "symbol": "i", "meaning": "Imaginary unit (i² = -1)" }
            ]
          },
          { "latex": "|z| = \\sqrt{a^2 + b^2}", "description": "Absolute value (modulus)" },
          { "latex": "\\bar{z} = a - bi", "description": "Complex conjugate" },
          { "latex": "(a+bi)(c+di) = (ac-bd) + (ad+bc)i", "description": "Complex multiplication" }
        ],
        "examples": [
          {
            "problem": "Calculate (3 + 2i) + (1 - 4i).",
            "solution": "Add real parts and imaginary parts separately.\n(3+1) + (2-4)i = 4 - 2i",
            "difficulty": 1
          },
          {
            "problem": "Calculate (2 + 3i)(1 - 2i).",
            "solution": "= 2×1 + 2×(-2i) + 3i×1 + 3i×(-2i)\n= 2 - 4i + 3i - 6i²\n= 2 - i - 6(-1)\n= 2 - i + 6 = 8 - i",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Electrical Engineering", "description": "AC circuit analysis" },
          { "field": "Physics", "description": "Quantum mechanics, waves" },
          { "field": "Computer Graphics", "description": "2D rotation, fractals" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["real-numbers", "square-roots"],
      "nextTopics": ["complex-analysis", "polar-form"],
      "related": ["imaginary-unit", "euler-formula"],
      "applications": ["applied-physics", "applied-engineering", "applied-cs"]
    },
    "tags": ["number", "complex", "imaginary", "advanced"]
  },
  {
    "id": "variables",
    "name": { "ko": "변수", "en": "Variables" },
    "field": "algebra",
    "subfield": "elementary-algebra",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "미지의 값을 나타내거나, 변할 수 있는 값을 표현하는 문자 기호이다.",
        "formulas": [
          { "latex": "x, y, z, a, b, c, ...", "description": "일반적으로 사용되는 변수 기호" }
        ],
        "examples": [
          {
            "problem": "x + 5 = 12일 때 x의 값을 구하시오.",
            "solution": "양변에서 5를 빼면\nx = 12 - 5 = 7",
            "difficulty": 1
          },
          {
            "problem": "사과 x개가 있고 3개를 더 사면 총 10개가 된다. x는?",
            "solution": "x + 3 = 10\nx = 7개",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "프로그래밍", "description": "변수에 값 저장" },
          { "field": "과학", "description": "공식에서 물리량 표현" }
        ]
      },
      "en": {
        "definition": "A symbol representing an unknown or changeable value.",
        "formulas": [
          { "latex": "x, y, z, a, b, c, ...", "description": "Commonly used variable symbols" }
        ],
        "examples": [
          {
            "problem": "Find x if x + 5 = 12.",
            "solution": "Subtract 5 from both sides:\nx = 12 - 5 = 7",
            "difficulty": 1
          },
          {
            "problem": "You have x apples. After buying 3 more, you have 10. What is x?",
            "solution": "x + 3 = 10\nx = 7 apples",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Programming", "description": "Storing values in variables" },
          { "field": "Science", "description": "Representing quantities in formulas" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["arithmetic-operations"],
      "nextTopics": ["linear-equation", "polynomial"],
      "related": ["constants"],
      "applications": ["applied-cs"]
    },
    "tags": ["algebra", "variable", "fundamental", "elementary"]
  },
  {
    "id": "polynomial",
    "name": { "ko": "다항식", "en": "Polynomial" },
    "field": "algebra",
    "subfield": "elementary-algebra",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "변수와 계수로 이루어진 항들의 합으로 표현된 식이다.",
        "formulas": [
          {
            "latex": "P(x) = a_nx^n + a_{n-1}x^{n-1} + ... + a_1x + a_0",
            "description": "n차 다항식의 일반형",
            "variables": [
              { "symbol": "n", "meaning": "다항식의 차수" },
              { "symbol": "a_n", "meaning": "최고차항의 계수 (≠0)" },
              { "symbol": "a_0", "meaning": "상수항" }
            ]
          }
        ],
        "examples": [
          {
            "problem": "다항식 3x³ + 2x² - 5x + 1의 차수와 최고차항의 계수를 구하시오.",
            "solution": "차수: 3 (x³의 지수)\n최고차항의 계수: 3",
            "difficulty": 1
          },
          {
            "problem": "(2x² + 3x - 1) + (x² - 2x + 4)를 계산하시오.",
            "solution": "동류항끼리 더합니다.\n= (2+1)x² + (3-2)x + (-1+4)\n= 3x² + x + 3",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "물리학", "description": "운동 방정식" },
          { "field": "경제학", "description": "비용/수익 함수" }
        ]
      },
      "en": {
        "definition": "An expression consisting of terms with variables and coefficients combined by addition.",
        "formulas": [
          {
            "latex": "P(x) = a_nx^n + a_{n-1}x^{n-1} + ... + a_1x + a_0",
            "description": "General form of degree n polynomial",
            "variables": [
              { "symbol": "n", "meaning": "Degree of polynomial" },
              { "symbol": "a_n", "meaning": "Leading coefficient (≠0)" },
              { "symbol": "a_0", "meaning": "Constant term" }
            ]
          }
        ],
        "examples": [
          {
            "problem": "Find the degree and leading coefficient of 3x³ + 2x² - 5x + 1.",
            "solution": "Degree: 3 (exponent of x³)\nLeading coefficient: 3",
            "difficulty": 1
          },
          {
            "problem": "Compute (2x² + 3x - 1) + (x² - 2x + 4).",
            "solution": "Combine like terms:\n= (2+1)x² + (3-2)x + (-1+4)\n= 3x² + x + 3",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Motion equations" },
          { "field": "Economics", "description": "Cost/revenue functions" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["variables", "exponents"],
      "nextTopics": ["factoring", "polynomial-division"],
      "related": ["monomial", "binomial"],
      "applications": ["applied-physics", "applied-economics"]
    },
    "tags": ["algebra", "polynomial", "fundamental"]
  },
  {
    "id": "linear-equation",
    "name": { "ko": "일차방정식", "en": "Linear Equation" },
    "field": "algebra",
    "subfield": "elementary-algebra",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "미지수의 최고차항이 1차인 방정식이다.",
        "formulas": [
          { "latex": "ax + b = 0 \\quad (a \\neq 0)", "description": "일차방정식의 일반형" },
          { "latex": "x = -\\frac{b}{a}", "description": "일차방정식의 해" }
        ],
        "examples": [
          { "problem": "3x - 6 = 0을 풀어라.", "solution": "3x = 6\nx = 2", "difficulty": 1 },
          {
            "problem": "2(x + 3) = 5x - 9를 풀어라.",
            "solution": "2x + 6 = 5x - 9\n6 + 9 = 5x - 2x\n15 = 3x\nx = 5",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "일상생활", "description": "가격 계산, 거리 문제" },
          { "field": "과학", "description": "선형 관계 분석" }
        ]
      },
      "en": {
        "definition": "An equation where the highest power of the variable is 1.",
        "formulas": [
          {
            "latex": "ax + b = 0 \\quad (a \\neq 0)",
            "description": "Standard form of linear equation"
          },
          { "latex": "x = -\\frac{b}{a}", "description": "Solution of linear equation" }
        ],
        "examples": [
          { "problem": "Solve 3x - 6 = 0.", "solution": "3x = 6\nx = 2", "difficulty": 1 },
          {
            "problem": "Solve 2(x + 3) = 5x - 9.",
            "solution": "2x + 6 = 5x - 9\n6 + 9 = 5x - 2x\n15 = 3x\nx = 5",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Daily life", "description": "Price calculations, distance problems" },
          { "field": "Science", "description": "Linear relationship analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["variables", "arithmetic-operations"],
      "nextTopics": ["quadratic-equation", "system-of-equations"],
      "related": ["linear-function"],
      "applications": ["applied-daily-life"]
    },
    "tags": ["algebra", "equation", "linear", "elementary"]
  },
  {
    "id": "factoring",
    "name": { "ko": "인수분해", "en": "Factoring" },
    "field": "algebra",
    "subfield": "elementary-algebra",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "다항식을 두 개 이상의 다항식의 곱으로 나타내는 것이다.",
        "formulas": [
          { "latex": "a^2 - b^2 = (a+b)(a-b)", "description": "합차 공식" },
          { "latex": "a^2 + 2ab + b^2 = (a+b)^2", "description": "완전제곱식 (덧셈)" },
          { "latex": "a^2 - 2ab + b^2 = (a-b)^2", "description": "완전제곱식 (뺄셈)" },
          { "latex": "x^2 + (a+b)x + ab = (x+a)(x+b)", "description": "이차식의 인수분해" },
          { "latex": "a^3 + b^3 = (a+b)(a^2 - ab + b^2)", "description": "합의 세제곱" },
          { "latex": "a^3 - b^3 = (a-b)(a^2 + ab + b^2)", "description": "차의 세제곱" }
        ],
        "examples": [
          {
            "problem": "x² - 9를 인수분해하시오.",
            "solution": "합차 공식 적용: a² - b² = (a+b)(a-b)\nx² - 9 = x² - 3² = (x+3)(x-3)",
            "latex": "x^2 - 9 = (x+3)(x-3)",
            "difficulty": 2
          },
          {
            "problem": "x² + 5x + 6을 인수분해하시오.",
            "solution": "곱이 6이고 합이 5인 두 수: 2와 3\n따라서 (x+2)(x+3)",
            "latex": "x^2 + 5x + 6 = (x+2)(x+3)",
            "difficulty": 2
          },
          {
            "problem": "2x² + 7x + 3을 인수분해하시오.",
            "solution": "ac = 2×3 = 6, b = 7\n6 = 1×6, 1+6=7 ✓\n= 2x² + x + 6x + 3\n= x(2x+1) + 3(2x+1)\n= (x+3)(2x+1)",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "방정식 풀이", "description": "이차방정식을 인수분해로 풀기" },
          { "field": "분수 간소화", "description": "분수식의 약분" }
        ]
      },
      "en": {
        "definition": "Expressing a polynomial as a product of two or more polynomials.",
        "formulas": [
          { "latex": "a^2 - b^2 = (a+b)(a-b)", "description": "Difference of squares" },
          {
            "latex": "a^2 + 2ab + b^2 = (a+b)^2",
            "description": "Perfect square trinomial (addition)"
          },
          {
            "latex": "a^2 - 2ab + b^2 = (a-b)^2",
            "description": "Perfect square trinomial (subtraction)"
          },
          {
            "latex": "x^2 + (a+b)x + ab = (x+a)(x+b)",
            "description": "Factoring quadratic trinomials"
          },
          { "latex": "a^3 + b^3 = (a+b)(a^2 - ab + b^2)", "description": "Sum of cubes" },
          { "latex": "a^3 - b^3 = (a-b)(a^2 + ab + b^2)", "description": "Difference of cubes" }
        ],
        "examples": [
          {
            "problem": "Factor x² - 9.",
            "solution": "Using difference of squares: a² - b² = (a+b)(a-b)\nx² - 9 = x² - 3² = (x+3)(x-3)",
            "latex": "x^2 - 9 = (x+3)(x-3)",
            "difficulty": 2
          },
          {
            "problem": "Factor x² + 5x + 6.",
            "solution": "Find two numbers that multiply to 6 and add to 5: 2 and 3\nSo (x+2)(x+3)",
            "latex": "x^2 + 5x + 6 = (x+2)(x+3)",
            "difficulty": 2
          },
          {
            "problem": "Factor 2x² + 7x + 3.",
            "solution": "ac = 2×3 = 6, b = 7\n6 = 1×6, 1+6=7 ✓\n= 2x² + x + 6x + 3\n= x(2x+1) + 3(2x+1)\n= (x+3)(2x+1)",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Solving equations", "description": "Solving quadratics by factoring" },
          { "field": "Simplifying fractions", "description": "Reducing algebraic fractions" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["polynomial"],
      "nextTopics": ["quadratic-equation"],
      "related": ["expanding", "gcf"],
      "applications": []
    },
    "tags": ["algebra", "polynomial", "factoring", "fundamental"]
  },
  {
    "id": "quadratic-equation",
    "name": { "ko": "이차방정식", "en": "Quadratic Equation" },
    "field": "algebra",
    "subfield": "elementary-algebra",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "미지수의 최고차항이 2차인 방정식이다.",
        "formulas": [
          {
            "latex": "ax^2 + bx + c = 0 \\quad (a \\neq 0)",
            "description": "이차방정식의 일반형",
            "variables": [
              { "symbol": "a", "meaning": "이차항의 계수 (0이 아님)" },
              { "symbol": "b", "meaning": "일차항의 계수" },
              { "symbol": "c", "meaning": "상수항" }
            ]
          },
          { "latex": "x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}", "description": "근의 공식" },
          { "latex": "D = b^2 - 4ac", "description": "판별식: D>0 두 실근, D=0 중근, D<0 허근" },
          {
            "latex": "x_1 + x_2 = -\\frac{b}{a}, \\quad x_1 x_2 = \\frac{c}{a}",
            "description": "근과 계수의 관계"
          }
        ],
        "examples": [
          {
            "problem": "x² - 5x + 6 = 0을 풀어라.",
            "solution": "인수분해: (x-2)(x-3) = 0\n따라서 x = 2 또는 x = 3",
            "latex": "x^2 - 5x + 6 = (x-2)(x-3) = 0",
            "difficulty": 2
          },
          {
            "problem": "2x² + 3x - 2 = 0을 근의 공식으로 풀어라.",
            "solution": "a=2, b=3, c=-2\nD = 9 + 16 = 25\nx = (-3 ± 5) / 4\nx = 1/2 또는 x = -2",
            "latex": "x = \\frac{-3 \\pm \\sqrt{25}}{4} = \\frac{1}{2}, -2",
            "difficulty": 3
          }
        ],
        "history": { "background": "바빌로니아인들이 기원전 2000년경에 이미 이차방정식을 풀었다." },
        "applications": [
          { "field": "물리학", "description": "포물선 운동, 자유낙하" },
          { "field": "경제학", "description": "이윤 최대화, 비용 최소화" }
        ]
      },
      "en": {
        "definition": "An equation where the highest power of the variable is 2.",
        "formulas": [
          {
            "latex": "ax^2 + bx + c = 0 \\quad (a \\neq 0)",
            "description": "Standard form of quadratic equation",
            "variables": [
              { "symbol": "a", "meaning": "Coefficient of x² (not zero)" },
              { "symbol": "b", "meaning": "Coefficient of x" },
              { "symbol": "c", "meaning": "Constant term" }
            ]
          },
          {
            "latex": "x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}",
            "description": "Quadratic formula"
          },
          {
            "latex": "D = b^2 - 4ac",
            "description": "Discriminant: D>0 two real roots, D=0 one root, D<0 complex roots"
          },
          {
            "latex": "x_1 + x_2 = -\\frac{b}{a}, \\quad x_1 x_2 = \\frac{c}{a}",
            "description": "Vieta's formulas"
          }
        ],
        "examples": [
          {
            "problem": "Solve x² - 5x + 6 = 0.",
            "solution": "Factor: (x-2)(x-3) = 0\nSo x = 2 or x = 3",
            "latex": "x^2 - 5x + 6 = (x-2)(x-3) = 0",
            "difficulty": 2
          },
          {
            "problem": "Solve 2x² + 3x - 2 = 0 using the quadratic formula.",
            "solution": "a=2, b=3, c=-2\nD = 9 + 16 = 25\nx = (-3 ± 5) / 4\nx = 1/2 or x = -2",
            "latex": "x = \\frac{-3 \\pm \\sqrt{25}}{4} = \\frac{1}{2}, -2",
            "difficulty": 3
          }
        ],
        "history": { "background": "Babylonians solved quadratic equations as early as 2000 BCE." },
        "applications": [
          { "field": "Physics", "description": "Projectile motion, free fall" },
          { "field": "Economics", "description": "Profit maximization, cost minimization" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["linear-equation", "square-roots", "factoring"],
      "nextTopics": ["polynomial-equation", "quadratic-function"],
      "related": ["completing-the-square"],
      "applications": ["applied-physics", "applied-economics"]
    },
    "tags": ["algebra", "equation", "quadratic", "fundamental"]
  },
  {
    "id": "inequality",
    "name": { "ko": "부등식", "en": "Inequality" },
    "field": "algebra",
    "subfield": "elementary-algebra",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "두 수식 사이의 대소 관계를 나타내는 식이다.",
        "formulas": [
          {
            "latex": "a < b, \\quad a > b, \\quad a \\leq b, \\quad a \\geq b",
            "description": "부등호의 종류"
          },
          {
            "latex": "a < b \\Rightarrow a + c < b + c",
            "description": "양변에 같은 수를 더해도 부등호 유지"
          },
          {
            "latex": "a < b, c > 0 \\Rightarrow ac < bc",
            "description": "양수를 곱하면 부등호 유지"
          },
          {
            "latex": "a < b, c < 0 \\Rightarrow ac > bc",
            "description": "음수를 곱하면 부등호 방향 바뀜"
          }
        ],
        "examples": [
          { "problem": "2x - 3 > 5를 풀어라.", "solution": "2x > 8\nx > 4", "difficulty": 1 },
          {
            "problem": "-3x + 6 ≤ 12를 풀어라.",
            "solution": "-3x ≤ 6\nx ≥ -2  (음수로 나누면 부등호 방향 바뀜)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "최적화", "description": "제약 조건 표현" },
          { "field": "경제학", "description": "예산 제약" }
        ]
      },
      "en": {
        "definition": "An expression showing the relationship between two values using inequality symbols.",
        "formulas": [
          {
            "latex": "a < b, \\quad a > b, \\quad a \\leq b, \\quad a \\geq b",
            "description": "Types of inequality symbols"
          },
          {
            "latex": "a < b \\Rightarrow a + c < b + c",
            "description": "Adding same value preserves inequality"
          },
          {
            "latex": "a < b, c > 0 \\Rightarrow ac < bc",
            "description": "Multiplying by positive preserves inequality"
          },
          {
            "latex": "a < b, c < 0 \\Rightarrow ac > bc",
            "description": "Multiplying by negative reverses inequality"
          }
        ],
        "examples": [
          { "problem": "Solve 2x - 3 > 5.", "solution": "2x > 8\nx > 4", "difficulty": 1 },
          {
            "problem": "Solve -3x + 6 ≤ 12.",
            "solution": "-3x ≤ 6\nx ≥ -2  (dividing by negative reverses inequality)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Optimization", "description": "Expressing constraints" },
          { "field": "Economics", "description": "Budget constraints" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["linear-equation"],
      "nextTopics": ["quadratic-inequality", "system-of-inequalities"],
      "related": ["absolute-value"],
      "applications": ["linear-programming"]
    },
    "tags": ["algebra", "inequality", "fundamental"]
  },
  {
    "id": "system-of-equations",
    "name": { "ko": "연립방정식", "en": "System of Equations" },
    "field": "algebra",
    "subfield": "elementary-algebra",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "두 개 이상의 방정식을 동시에 만족하는 해를 구하는 문제이다.",
        "formulas": [
          {
            "latex": "\\begin{cases} ax + by = e \\\\ cx + dy = f \\end{cases}",
            "description": "이원일차연립방정식"
          },
          {
            "latex": "x = \\frac{ed - bf}{ad - bc}, \\quad y = \\frac{af - ce}{ad - bc}",
            "description": "크래머 공식 (ad - bc ≠ 0)"
          }
        ],
        "examples": [
          {
            "problem": "x + y = 5, x - y = 1을 풀어라.",
            "solution": "두 식을 더하면: 2x = 6, x = 3\nx = 3을 대입: 3 + y = 5, y = 2\n해: (3, 2)",
            "difficulty": 2
          },
          {
            "problem": "2x + 3y = 12, x - y = 1을 풀어라.",
            "solution": "두 번째 식에서 x = y + 1\n첫 번째 식에 대입: 2(y+1) + 3y = 12\n5y + 2 = 12, y = 2\nx = 3\n해: (3, 2)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "물리학", "description": "힘의 평형, 회로 분석" },
          { "field": "경제학", "description": "수요-공급 균형" }
        ]
      },
      "en": {
        "definition": "A set of two or more equations that must be satisfied simultaneously.",
        "formulas": [
          {
            "latex": "\\begin{cases} ax + by = e \\\\ cx + dy = f \\end{cases}",
            "description": "System of two linear equations"
          },
          {
            "latex": "x = \\frac{ed - bf}{ad - bc}, \\quad y = \\frac{af - ce}{ad - bc}",
            "description": "Cramer's rule (ad - bc ≠ 0)"
          }
        ],
        "examples": [
          {
            "problem": "Solve x + y = 5, x - y = 1.",
            "solution": "Add equations: 2x = 6, x = 3\nSubstitute: 3 + y = 5, y = 2\nSolution: (3, 2)",
            "difficulty": 2
          },
          {
            "problem": "Solve 2x + 3y = 12, x - y = 1.",
            "solution": "From second: x = y + 1\nSubstitute: 2(y+1) + 3y = 12\n5y + 2 = 12, y = 2\nx = 3\nSolution: (3, 2)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Force equilibrium, circuit analysis" },
          { "field": "Economics", "description": "Supply-demand equilibrium" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["linear-equation"],
      "nextTopics": ["matrix-methods", "three-variable-systems"],
      "related": ["matrices"],
      "applications": ["applied-physics", "applied-economics"]
    },
    "tags": ["algebra", "system", "equations", "fundamental"]
  },
  {
    "id": "exponential-function",
    "name": { "ko": "지수함수", "en": "Exponential Function" },
    "field": "algebra",
    "subfield": "advanced-algebra",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "밑이 양의 상수이고 지수가 변수인 함수이다.",
        "formulas": [
          { "latex": "f(x) = a^x \\quad (a > 0, a \\neq 1)", "description": "지수함수의 정의" },
          { "latex": "a^{x+y} = a^x \\cdot a^y", "description": "지수법칙" },
          {
            "latex": "e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!}",
            "description": "자연지수함수의 급수 전개"
          }
        ],
        "examples": [
          {
            "problem": "2^x = 32를 풀어라.",
            "solution": "32 = 2^5이므로\n2^x = 2^5\nx = 5",
            "difficulty": 2
          },
          {
            "problem": "y = 3^x의 그래프 특성을 설명하시오.",
            "solution": "• 정의역: 모든 실수\n• 치역: y > 0\n• y절편: (0, 1)\n• 점근선: y = 0 (x축)\n• 증가함수 (a > 1)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "생물학", "description": "세포 분열, 인구 성장" },
          { "field": "금융", "description": "복리 이자" },
          { "field": "물리학", "description": "방사성 붕괴" }
        ]
      },
      "en": {
        "definition": "A function where the base is a positive constant and the exponent is the variable.",
        "formulas": [
          {
            "latex": "f(x) = a^x \\quad (a > 0, a \\neq 1)",
            "description": "Definition of exponential function"
          },
          { "latex": "a^{x+y} = a^x \\cdot a^y", "description": "Exponent rule" },
          {
            "latex": "e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!}",
            "description": "Series expansion of natural exponential"
          }
        ],
        "examples": [
          {
            "problem": "Solve 2^x = 32.",
            "solution": "Since 32 = 2^5,\n2^x = 2^5\nx = 5",
            "difficulty": 2
          },
          {
            "problem": "Describe the graph of y = 3^x.",
            "solution": "• Domain: all real numbers\n• Range: y > 0\n• y-intercept: (0, 1)\n• Asymptote: y = 0 (x-axis)\n• Increasing (since a > 1)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Biology", "description": "Cell division, population growth" },
          { "field": "Finance", "description": "Compound interest" },
          { "field": "Physics", "description": "Radioactive decay" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["exponents"],
      "nextTopics": ["logarithm"],
      "related": ["euler-number"],
      "applications": ["applied-finance", "applied-biology"]
    },
    "tags": ["algebra", "function", "exponential", "advanced"]
  },
  {
    "id": "logarithm",
    "name": { "ko": "로그", "en": "Logarithm" },
    "field": "algebra",
    "subfield": "advanced-algebra",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "지수함수의 역함수로, 어떤 수를 얻기 위해 밑을 몇 번 거듭제곱해야 하는지를 나타낸다.",
        "formulas": [
          {
            "latex": "\\log_a b = c \\Leftrightarrow a^c = b",
            "description": "로그의 정의",
            "variables": [
              { "symbol": "a", "meaning": "밑 (a > 0, a ≠ 1)" },
              { "symbol": "b", "meaning": "진수 (b > 0)" },
              { "symbol": "c", "meaning": "로그 값" }
            ]
          },
          { "latex": "\\log_a(xy) = \\log_a x + \\log_a y", "description": "로그의 덧셈 법칙" },
          {
            "latex": "\\log_a\\frac{x}{y} = \\log_a x - \\log_a y",
            "description": "로그의 뺄셈 법칙"
          },
          { "latex": "\\log_a x^n = n \\log_a x", "description": "로그의 거듭제곱 법칙" },
          { "latex": "\\log_a b = \\frac{\\log_c b}{\\log_c a}", "description": "밑 변환 공식" }
        ],
        "examples": [
          {
            "problem": "log₂ 32를 구하시오.",
            "solution": "2^x = 32 = 2^5이므로\nlog₂ 32 = 5",
            "difficulty": 2
          },
          {
            "problem": "log₁₀ 2 + log₁₀ 5를 계산하시오.",
            "solution": "log₁₀ 2 + log₁₀ 5 = log₁₀(2 × 5) = log₁₀ 10 = 1",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "과학", "description": "pH 척도, 데시벨" },
          { "field": "컴퓨터", "description": "알고리즘 복잡도 (O(log n))" },
          { "field": "지진학", "description": "리히터 규모" }
        ]
      },
      "en": {
        "definition": "The inverse of exponential function, indicating how many times a base must be multiplied to get a number.",
        "formulas": [
          {
            "latex": "\\log_a b = c \\Leftrightarrow a^c = b",
            "description": "Definition of logarithm",
            "variables": [
              { "symbol": "a", "meaning": "Base (a > 0, a ≠ 1)" },
              { "symbol": "b", "meaning": "Argument (b > 0)" },
              { "symbol": "c", "meaning": "Logarithm value" }
            ]
          },
          { "latex": "\\log_a(xy) = \\log_a x + \\log_a y", "description": "Product rule" },
          {
            "latex": "\\log_a\\frac{x}{y} = \\log_a x - \\log_a y",
            "description": "Quotient rule"
          },
          { "latex": "\\log_a x^n = n \\log_a x", "description": "Power rule" },
          {
            "latex": "\\log_a b = \\frac{\\log_c b}{\\log_c a}",
            "description": "Change of base formula"
          }
        ],
        "examples": [
          {
            "problem": "Find log₂ 32.",
            "solution": "2^x = 32 = 2^5, so\nlog₂ 32 = 5",
            "difficulty": 2
          },
          {
            "problem": "Calculate log₁₀ 2 + log₁₀ 5.",
            "solution": "log₁₀ 2 + log₁₀ 5 = log₁₀(2 × 5) = log₁₀ 10 = 1",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Science", "description": "pH scale, decibels" },
          { "field": "Computing", "description": "Algorithm complexity (O(log n))" },
          { "field": "Seismology", "description": "Richter scale" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["exponential-function"],
      "nextTopics": ["natural-logarithm", "logarithmic-equations"],
      "related": ["euler-number"],
      "applications": ["applied-cs", "applied-physics"]
    },
    "tags": ["algebra", "function", "logarithm", "advanced"]
  },
  {
    "id": "arithmetic-sequence",
    "name": { "ko": "등차수열", "en": "Arithmetic Sequence" },
    "field": "algebra",
    "subfield": "advanced-algebra",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "연속하는 두 항의 차이가 일정한 수열이다.",
        "formulas": [
          {
            "latex": "a_n = a_1 + (n-1)d",
            "description": "일반항 공식",
            "variables": [
              { "symbol": "a_n", "meaning": "n번째 항" },
              { "symbol": "a_1", "meaning": "첫째 항" },
              { "symbol": "d", "meaning": "공차 (common difference)" }
            ]
          },
          {
            "latex": "S_n = \\frac{n(a_1 + a_n)}{2} = \\frac{n(2a_1 + (n-1)d)}{2}",
            "description": "등차수열의 합"
          }
        ],
        "examples": [
          {
            "problem": "첫째 항이 3, 공차가 4인 등차수열의 10번째 항을 구하시오.",
            "solution": "a₁₀ = 3 + (10-1)×4 = 3 + 36 = 39",
            "difficulty": 2
          },
          {
            "problem": "1부터 100까지의 자연수의 합을 구하시오.",
            "solution": "S = n(a₁ + aₙ)/2 = 100(1 + 100)/2 = 5050",
            "difficulty": 2
          }
        ],
        "history": {
          "discoveredBy": "가우스",
          "background": "어린 가우스가 1부터 100까지의 합을 빠르게 계산한 일화가 유명하다."
        },
        "applications": [
          { "field": "금융", "description": "정액 적금" },
          { "field": "물리학", "description": "등가속도 운동" }
        ]
      },
      "en": {
        "definition": "A sequence where the difference between consecutive terms is constant.",
        "formulas": [
          {
            "latex": "a_n = a_1 + (n-1)d",
            "description": "General term formula",
            "variables": [
              { "symbol": "a_n", "meaning": "nth term" },
              { "symbol": "a_1", "meaning": "First term" },
              { "symbol": "d", "meaning": "Common difference" }
            ]
          },
          {
            "latex": "S_n = \\frac{n(a_1 + a_n)}{2} = \\frac{n(2a_1 + (n-1)d)}{2}",
            "description": "Sum of arithmetic sequence"
          }
        ],
        "examples": [
          {
            "problem": "Find the 10th term of an arithmetic sequence with a₁ = 3, d = 4.",
            "solution": "a₁₀ = 3 + (10-1)×4 = 3 + 36 = 39",
            "difficulty": 2
          },
          {
            "problem": "Find the sum of natural numbers from 1 to 100.",
            "solution": "S = n(a₁ + aₙ)/2 = 100(1 + 100)/2 = 5050",
            "difficulty": 2
          }
        ],
        "history": {
          "discoveredBy": "Gauss",
          "background": "Famous story of young Gauss quickly computing the sum from 1 to 100."
        },
        "applications": [
          { "field": "Finance", "description": "Fixed deposits" },
          { "field": "Physics", "description": "Uniform acceleration" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["variables"],
      "nextTopics": ["geometric-sequence", "series"],
      "related": ["linear-function"],
      "applications": ["applied-finance", "applied-physics"]
    },
    "tags": ["algebra", "sequence", "arithmetic"]
  },
  {
    "id": "geometric-sequence",
    "name": { "ko": "등비수열", "en": "Geometric Sequence" },
    "field": "algebra",
    "subfield": "advanced-algebra",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "연속하는 두 항의 비가 일정한 수열이다.",
        "formulas": [
          {
            "latex": "a_n = a_1 \\cdot r^{n-1}",
            "description": "일반항 공식",
            "variables": [
              { "symbol": "a_n", "meaning": "n번째 항" },
              { "symbol": "a_1", "meaning": "첫째 항" },
              { "symbol": "r", "meaning": "공비 (common ratio)" }
            ]
          },
          {
            "latex": "S_n = \\frac{a_1(1 - r^n)}{1 - r} = \\frac{a_1(r^n - 1)}{r - 1} \\quad (r \\neq 1)",
            "description": "등비수열의 합"
          },
          {
            "latex": "S_{\\infty} = \\frac{a_1}{1 - r} \\quad (|r| < 1)",
            "description": "무한등비급수의 합"
          }
        ],
        "examples": [
          {
            "problem": "첫째 항이 2, 공비가 3인 등비수열의 5번째 항을 구하시오.",
            "solution": "a₅ = 2 × 3⁴ = 2 × 81 = 162",
            "difficulty": 2
          },
          {
            "problem": "1 + 1/2 + 1/4 + 1/8 + ... 의 합을 구하시오.",
            "solution": "|r| = 1/2 < 1이므로 수렴\nS = a₁/(1-r) = 1/(1-1/2) = 2",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "금융", "description": "복리 계산" },
          { "field": "인구학", "description": "기하급수적 성장" },
          { "field": "컴퓨터", "description": "이진 트리 노드 수" }
        ]
      },
      "en": {
        "definition": "A sequence where the ratio between consecutive terms is constant.",
        "formulas": [
          {
            "latex": "a_n = a_1 \\cdot r^{n-1}",
            "description": "General term formula",
            "variables": [
              { "symbol": "a_n", "meaning": "nth term" },
              { "symbol": "a_1", "meaning": "First term" },
              { "symbol": "r", "meaning": "Common ratio" }
            ]
          },
          {
            "latex": "S_n = \\frac{a_1(1 - r^n)}{1 - r} = \\frac{a_1(r^n - 1)}{r - 1} \\quad (r \\neq 1)",
            "description": "Sum of geometric sequence"
          },
          {
            "latex": "S_{\\infty} = \\frac{a_1}{1 - r} \\quad (|r| < 1)",
            "description": "Sum of infinite geometric series"
          }
        ],
        "examples": [
          {
            "problem": "Find the 5th term of geometric sequence with a₁ = 2, r = 3.",
            "solution": "a₅ = 2 × 3⁴ = 2 × 81 = 162",
            "difficulty": 2
          },
          {
            "problem": "Find the sum: 1 + 1/2 + 1/4 + 1/8 + ...",
            "solution": "|r| = 1/2 < 1, so it converges\nS = a₁/(1-r) = 1/(1-1/2) = 2",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Finance", "description": "Compound interest" },
          { "field": "Demographics", "description": "Exponential growth" },
          { "field": "Computing", "description": "Binary tree node count" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["arithmetic-sequence", "exponents"],
      "nextTopics": ["series", "limits-continuity"],
      "related": ["exponential-function"],
      "applications": ["applied-finance", "applied-cs"]
    },
    "tags": ["algebra", "sequence", "geometric"]
  },
  {
    "id": "series",
    "name": { "ko": "급수", "en": "Series" },
    "field": "algebra",
    "subfield": "advanced-algebra",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수열의 항들을 더한 것으로, 유한급수와 무한급수가 있다.",
        "formulas": [
          {
            "latex": "\\sum_{k=1}^{n} a_k = a_1 + a_2 + ... + a_n",
            "description": "유한급수 (시그마 표기)"
          },
          { "latex": "\\sum_{k=1}^{n} k = \\frac{n(n+1)}{2}", "description": "자연수의 합" },
          { "latex": "\\sum_{k=1}^{n} k^2 = \\frac{n(n+1)(2n+1)}{6}", "description": "제곱의 합" },
          {
            "latex": "\\sum_{k=1}^{n} k^3 = \\left( \\frac{n(n+1)}{2} \\right)^2",
            "description": "세제곱의 합"
          }
        ],
        "examples": [
          {
            "problem": "Σ(k=1 to 10) k를 계산하시오.",
            "solution": "= 10 × 11 / 2 = 55",
            "difficulty": 1
          },
          {
            "problem": "Σ(k=1 to 5) k²를 계산하시오.",
            "solution": "= 5 × 6 × 11 / 6 = 55",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "수학", "description": "테일러 급수, 푸리에 급수" },
          { "field": "물리학", "description": "파동 분석" },
          { "field": "컴퓨터", "description": "알고리즘 분석" }
        ]
      },
      "en": {
        "definition": "The sum of terms in a sequence, which can be finite or infinite.",
        "formulas": [
          {
            "latex": "\\sum_{k=1}^{n} a_k = a_1 + a_2 + ... + a_n",
            "description": "Finite series (sigma notation)"
          },
          {
            "latex": "\\sum_{k=1}^{n} k = \\frac{n(n+1)}{2}",
            "description": "Sum of natural numbers"
          },
          {
            "latex": "\\sum_{k=1}^{n} k^2 = \\frac{n(n+1)(2n+1)}{6}",
            "description": "Sum of squares"
          },
          {
            "latex": "\\sum_{k=1}^{n} k^3 = \\left( \\frac{n(n+1)}{2} \\right)^2",
            "description": "Sum of cubes"
          }
        ],
        "examples": [
          {
            "problem": "Calculate Σ(k=1 to 10) k.",
            "solution": "= 10 × 11 / 2 = 55",
            "difficulty": 1
          },
          {
            "problem": "Calculate Σ(k=1 to 5) k².",
            "solution": "= 5 × 6 × 11 / 6 = 55",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Mathematics", "description": "Taylor series, Fourier series" },
          { "field": "Physics", "description": "Wave analysis" },
          { "field": "Computing", "description": "Algorithm analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["arithmetic-sequence", "geometric-sequence"],
      "nextTopics": ["convergence", "taylor-series"],
      "related": ["limits-continuity"],
      "applications": ["applied-physics", "applied-cs"]
    },
    "tags": ["algebra", "series", "summation", "advanced"]
  },
  {
    "id": "point-line-plane",
    "name": { "ko": "점, 선, 면", "en": "Point, Line, Plane" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "점은 위치만 있고 크기가 없는 기하학적 대상이다. 선은 두 점을 잇는 가장 짧은 경로이다. 면은 길이와 너비를 가진 2차원 영역이다.",
        "formulas": [
          { "latex": "\\text{점 } P(x, y)", "description": "좌표평면 위의 점" },
          { "latex": "ax + by + c = 0", "description": "직선의 일반형" }
        ],
        "examples": [
          {
            "problem": "점 A(2, 3)과 점 B(5, 7)을 지나는 직선의 기울기를 구하시오.",
            "solution": "기울기 m = (7-3)/(5-2) = 4/3",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "건축", "description": "설계 도면의 기본 요소" },
          { "field": "컴퓨터 그래픽", "description": "벡터 그래픽의 기초" }
        ]
      },
      "en": {
        "definition": "A point has position but no size. A line is the shortest path between two points. A plane is a 2-dimensional surface with length and width.",
        "formulas": [
          { "latex": "\\text{Point } P(x, y)", "description": "Point on coordinate plane" },
          { "latex": "ax + by + c = 0", "description": "General form of a line" }
        ],
        "examples": [
          {
            "problem": "Find the slope of the line through A(2, 3) and B(5, 7).",
            "solution": "Slope m = (7-3)/(5-2) = 4/3",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Architecture", "description": "Basic elements of blueprints" },
          { "field": "Computer Graphics", "description": "Foundation of vector graphics" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["angles", "distance-formula"],
      "related": ["coordinate-system"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "fundamental", "point", "line", "plane"]
  },
  {
    "id": "angles",
    "name": { "ko": "각도", "en": "Angles" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "두 직선이 한 점에서 만날 때 생기는 벌어진 정도를 각이라 하고, 그 크기를 각도라 한다.",
        "formulas": [
          { "latex": "\\text{예각: } 0° < \\theta < 90°", "description": "예각의 범위" },
          { "latex": "\\text{직각: } \\theta = 90°", "description": "직각" },
          { "latex": "\\text{둔각: } 90° < \\theta < 180°", "description": "둔각의 범위" },
          { "latex": "\\text{평각: } \\theta = 180°", "description": "평각 (일직선)" }
        ],
        "examples": [
          {
            "problem": "두 각이 보각일 때, 한 각이 35°이면 다른 각은?",
            "solution": "보각의 합은 90°이므로\n다른 각 = 90° - 35° = 55°",
            "difficulty": 1
          },
          {
            "problem": "두 각이 보충각일 때, 한 각이 120°이면 다른 각은?",
            "solution": "보충각의 합은 180°이므로\n다른 각 = 180° - 120° = 60°",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "건축", "description": "구조물 설계" },
          { "field": "항해", "description": "방향 측정" }
        ]
      },
      "en": {
        "definition": "An angle is formed when two lines meet at a point. The measure of an angle indicates how far apart the lines are.",
        "formulas": [
          { "latex": "\\text{Acute: } 0° < \\theta < 90°", "description": "Acute angle range" },
          { "latex": "\\text{Right: } \\theta = 90°", "description": "Right angle" },
          { "latex": "\\text{Obtuse: } 90° < \\theta < 180°", "description": "Obtuse angle range" },
          { "latex": "\\text{Straight: } \\theta = 180°", "description": "Straight angle" }
        ],
        "examples": [
          {
            "problem": "If two angles are complementary and one is 35°, find the other.",
            "solution": "Complementary angles sum to 90°\nOther angle = 90° - 35° = 55°",
            "difficulty": 1
          },
          {
            "problem": "If two angles are supplementary and one is 120°, find the other.",
            "solution": "Supplementary angles sum to 180°\nOther angle = 180° - 120° = 60°",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Architecture", "description": "Structural design" },
          { "field": "Navigation", "description": "Direction measurement" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["point-line-plane"],
      "nextTopics": ["triangle-basics", "parallel-lines"],
      "related": ["radians"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "angle", "fundamental"]
  },
  {
    "id": "triangle-basics",
    "name": { "ko": "삼각형", "en": "Triangle" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "세 개의 직선으로 둘러싸인 다각형이다. 세 내각의 합은 항상 180°이다.",
        "formulas": [
          {
            "latex": "\\angle A + \\angle B + \\angle C = 180°",
            "description": "삼각형 내각의 합"
          },
          {
            "latex": "a + b > c",
            "description": "삼각형 성립조건 (임의의 두 변의 합 > 나머지 한 변)"
          }
        ],
        "examples": [
          {
            "problem": "삼각형의 두 각이 50°와 70°일 때, 나머지 한 각은?",
            "solution": "내각의 합 = 180°\n나머지 각 = 180° - 50° - 70° = 60°",
            "difficulty": 1
          },
          {
            "problem": "변의 길이가 3, 4, 8인 삼각형이 존재하는지 판단하시오.",
            "solution": "3 + 4 = 7 < 8\n삼각형 성립조건을 만족하지 않으므로 존재하지 않는다.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "건축", "description": "트러스 구조" },
          { "field": "측량", "description": "삼각측량" }
        ]
      },
      "en": {
        "definition": "A polygon with three sides. The sum of interior angles is always 180°.",
        "formulas": [
          {
            "latex": "\\angle A + \\angle B + \\angle C = 180°",
            "description": "Sum of interior angles"
          },
          {
            "latex": "a + b > c",
            "description": "Triangle inequality (sum of any two sides > third side)"
          }
        ],
        "examples": [
          {
            "problem": "If two angles of a triangle are 50° and 70°, find the third.",
            "solution": "Sum of angles = 180°\nThird angle = 180° - 50° - 70° = 60°",
            "difficulty": 1
          },
          {
            "problem": "Can a triangle have sides of length 3, 4, and 8?",
            "solution": "3 + 4 = 7 < 8\nTriangle inequality not satisfied, so no.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Architecture", "description": "Truss structures" },
          { "field": "Surveying", "description": "Triangulation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["angles"],
      "nextTopics": ["pythagorean-theorem", "triangle-area", "similar-triangles"],
      "related": ["polygon"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "triangle", "fundamental"]
  },
  {
    "id": "pythagorean-theorem",
    "name": { "ko": "피타고라스 정리", "en": "Pythagorean Theorem" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "직각삼각형에서 빗변의 제곱은 다른 두 변의 제곱의 합과 같다.",
        "formulas": [
          {
            "latex": "a^2 + b^2 = c^2",
            "description": "직각삼각형의 세 변 사이의 관계",
            "variables": [
              { "symbol": "a", "meaning": "직각을 이루는 한 변 (밑변)" },
              { "symbol": "b", "meaning": "직각을 이루는 다른 변 (높이)" },
              { "symbol": "c", "meaning": "빗변 (직각의 대변, 가장 긴 변)" }
            ]
          }
        ],
        "examples": [
          {
            "problem": "밑변이 3, 높이가 4인 직각삼각형의 빗변의 길이를 구하시오.",
            "solution": "c² = 3² + 4² = 9 + 16 = 25\n따라서 c = √25 = 5\n\n빗변의 길이는 5입니다.",
            "latex": "c = \\sqrt{3^2 + 4^2} = \\sqrt{25} = 5",
            "difficulty": 2
          },
          {
            "problem": "빗변이 13, 한 변이 5인 직각삼각형의 나머지 한 변의 길이를 구하시오.",
            "solution": "5² + b² = 13²\n25 + b² = 169\nb² = 144\nb = 12\n\n나머지 변의 길이는 12입니다.",
            "latex": "b = \\sqrt{13^2 - 5^2} = \\sqrt{144} = 12",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "피타고라스 (Pythagoras)",
          "year": "기원전 6세기",
          "background": "고대 그리스의 수학자 피타고라스가 증명한 것으로 알려져 있으나, 바빌로니아와 인도에서는 이보다 훨씬 이전에 이 관계를 알고 있었다."
        },
        "applications": [
          { "field": "건축", "description": "직각을 확인하고 대각선 거리를 계산하는 데 사용" },
          { "field": "측량", "description": "두 지점 사이의 직선 거리 계산" },
          {
            "field": "컴퓨터 그래픽",
            "description": "2D/3D 공간에서 거리 계산",
            "conceptLink": "distance-formula"
          }
        ]
      },
      "en": {
        "definition": "In a right triangle, the square of the hypotenuse equals the sum of the squares of the other two sides.",
        "formulas": [
          {
            "latex": "a^2 + b^2 = c^2",
            "description": "Relationship between the three sides of a right triangle",
            "variables": [
              { "symbol": "a", "meaning": "One leg of the right triangle" },
              { "symbol": "b", "meaning": "The other leg of the right triangle" },
              {
                "symbol": "c",
                "meaning": "Hypotenuse (the longest side, opposite the right angle)"
              }
            ]
          }
        ],
        "examples": [
          {
            "problem": "Find the hypotenuse of a right triangle with legs of length 3 and 4.",
            "solution": "c² = 3² + 4² = 9 + 16 = 25\nTherefore c = √25 = 5\n\nThe hypotenuse is 5.",
            "latex": "c = \\sqrt{3^2 + 4^2} = \\sqrt{25} = 5",
            "difficulty": 2
          },
          {
            "problem": "Find the missing leg of a right triangle with hypotenuse 13 and one leg 5.",
            "solution": "5² + b² = 13²\n25 + b² = 169\nb² = 144\nb = 12\n\nThe missing leg is 12.",
            "latex": "b = \\sqrt{13^2 - 5^2} = \\sqrt{144} = 12",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "Pythagoras",
          "year": "6th century BCE",
          "background": "While attributed to the Greek mathematician Pythagoras, this relationship was known to Babylonians and Indians long before."
        },
        "applications": [
          {
            "field": "Architecture",
            "description": "Verifying right angles and calculating diagonal distances"
          },
          {
            "field": "Surveying",
            "description": "Calculating straight-line distances between points"
          },
          {
            "field": "Computer Graphics",
            "description": "Distance calculation in 2D/3D space",
            "conceptLink": "distance-formula"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["triangle-basics", "square-roots"],
      "nextTopics": ["distance-formula", "sine-cosine", "law-of-cosines"],
      "related": ["similar-triangles", "euclidean-geometry"],
      "applications": ["applied-engineering", "applied-cs"]
    },
    "tags": ["geometry", "triangle", "theorem", "fundamental"]
  },
  {
    "id": "triangle-area",
    "name": { "ko": "삼각형의 넓이", "en": "Area of Triangle" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "삼각형의 넓이는 밑변과 높이의 곱의 절반이다.",
        "formulas": [
          {
            "latex": "A = \\frac{1}{2} \\times b \\times h",
            "description": "기본 공식: 밑변 × 높이 ÷ 2",
            "variables": [
              { "symbol": "A", "meaning": "삼각형의 넓이" },
              { "symbol": "b", "meaning": "밑변의 길이" },
              { "symbol": "h", "meaning": "밑변에 대한 높이" }
            ]
          },
          {
            "latex": "A = \\frac{1}{2}ab\\sin C",
            "description": "두 변과 끼인각을 이용한 공식",
            "variables": [
              { "symbol": "a, b", "meaning": "두 변의 길이" },
              { "symbol": "C", "meaning": "두 변 사이의 끼인각" }
            ]
          },
          { "latex": "A = \\sqrt{s(s-a)(s-b)(s-c)}", "description": "헤론의 공식 (s = (a+b+c)/2)" }
        ],
        "examples": [
          {
            "problem": "밑변이 6cm, 높이가 4cm인 삼각형의 넓이를 구하시오.",
            "solution": "A = ½ × 6 × 4 = 12cm²",
            "latex": "A = \\frac{1}{2} \\times 6 \\times 4 = 12\\text{cm}^2",
            "difficulty": 1
          },
          {
            "problem": "두 변의 길이가 각각 5cm, 8cm이고 끼인각이 30°인 삼각형의 넓이를 구하시오.",
            "solution": "A = ½ × 5 × 8 × sin30° = ½ × 5 × 8 × 0.5 = 10cm²",
            "latex": "A = \\frac{1}{2} \\times 5 \\times 8 \\times \\sin 30° = 10\\text{cm}^2",
            "difficulty": 3
          }
        ]
      },
      "en": {
        "definition": "The area of a triangle is half the product of its base and height.",
        "formulas": [
          {
            "latex": "A = \\frac{1}{2} \\times b \\times h",
            "description": "Basic formula: base × height ÷ 2",
            "variables": [
              { "symbol": "A", "meaning": "Area of the triangle" },
              { "symbol": "b", "meaning": "Length of the base" },
              { "symbol": "h", "meaning": "Height perpendicular to the base" }
            ]
          },
          {
            "latex": "A = \\frac{1}{2}ab\\sin C",
            "description": "Formula using two sides and included angle",
            "variables": [
              { "symbol": "a, b", "meaning": "Lengths of two sides" },
              { "symbol": "C", "meaning": "Angle between the two sides" }
            ]
          },
          {
            "latex": "A = \\sqrt{s(s-a)(s-b)(s-c)}",
            "description": "Heron's formula (s = (a+b+c)/2)"
          }
        ],
        "examples": [
          {
            "problem": "Find the area of a triangle with base 6cm and height 4cm.",
            "solution": "A = ½ × 6 × 4 = 12cm²",
            "latex": "A = \\frac{1}{2} \\times 6 \\times 4 = 12\\text{cm}^2",
            "difficulty": 1
          },
          {
            "problem": "Find the area of a triangle with sides 5cm and 8cm, and included angle 30°.",
            "solution": "A = ½ × 5 × 8 × sin30° = ½ × 5 × 8 × 0.5 = 10cm²",
            "latex": "A = \\frac{1}{2} \\times 5 \\times 8 \\times \\sin 30° = 10\\text{cm}^2",
            "difficulty": 3
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["triangle-basics"],
      "nextTopics": ["polygon-area"],
      "related": ["pythagorean-theorem", "sine-cosine"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "triangle", "area", "fundamental"]
  },
  {
    "id": "similar-triangles",
    "name": { "ko": "닮은 삼각형", "en": "Similar Triangles" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "대응하는 각이 모두 같고, 대응하는 변의 비가 일정한 두 삼각형을 닮음이라 한다.",
        "formulas": [
          {
            "latex": "\\frac{a}{a'} = \\frac{b}{b'} = \\frac{c}{c'} = k",
            "description": "닮음비 (scale factor)"
          },
          { "latex": "\\frac{S_1}{S_2} = k^2", "description": "넓이의 비 = 닮음비의 제곱" }
        ],
        "examples": [
          {
            "problem": "삼각형 ABC와 DEF가 닮음이고 닮음비가 2:3이다. ABC의 넓이가 8cm²일 때, DEF의 넓이는?",
            "solution": "넓이의 비 = 닮음비² = (2/3)² = 4/9\n8 : S = 4 : 9\nS = 18cm²",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "측량", "description": "간접 거리 측정" },
          { "field": "사진", "description": "축소/확대 비율 계산" }
        ]
      },
      "en": {
        "definition": "Two triangles are similar if their corresponding angles are equal and their corresponding sides are proportional.",
        "formulas": [
          {
            "latex": "\\frac{a}{a'} = \\frac{b}{b'} = \\frac{c}{c'} = k",
            "description": "Scale factor (ratio of similarity)"
          },
          {
            "latex": "\\frac{S_1}{S_2} = k^2",
            "description": "Ratio of areas = square of scale factor"
          }
        ],
        "examples": [
          {
            "problem": "Triangles ABC and DEF are similar with ratio 2:3. If ABC has area 8cm², find DEF's area.",
            "solution": "Area ratio = (2/3)² = 4/9\n8 : S = 4 : 9\nS = 18cm²",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Surveying", "description": "Indirect distance measurement" },
          { "field": "Photography", "description": "Scale calculations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["triangle-basics", "ratios"],
      "nextTopics": ["congruent-triangles"],
      "related": ["proportions"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "triangle", "similarity"]
  },
  {
    "id": "congruent-triangles",
    "name": { "ko": "합동 삼각형", "en": "Congruent Triangles" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "모양과 크기가 완전히 같은 두 삼각형을 합동이라 한다. 대응하는 변과 각이 모두 같다.",
        "formulas": [
          { "latex": "\\triangle ABC \\cong \\triangle DEF", "description": "합동 기호" }
        ],
        "examples": [
          {
            "problem": "SSS 합동 조건을 설명하시오.",
            "solution": "세 변의 길이가 각각 같으면 두 삼각형은 합동이다.\na = d, b = e, c = f이면 △ABC ≅ △DEF",
            "difficulty": 1
          },
          {
            "problem": "합동 조건 5가지를 나열하시오.",
            "solution": "SSS (변변변)\nSAS (변각변)\nASA (각변각)\nAAS (각각변)\nRHS (직각빗변변)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "공학", "description": "부품 호환성 설계" },
          { "field": "건축", "description": "대칭 구조물" }
        ]
      },
      "en": {
        "definition": "Two triangles are congruent if they have exactly the same shape and size. All corresponding sides and angles are equal.",
        "formulas": [
          { "latex": "\\triangle ABC \\cong \\triangle DEF", "description": "Congruence notation" }
        ],
        "examples": [
          {
            "problem": "Explain the SSS congruence condition.",
            "solution": "If three sides are respectively equal, triangles are congruent.\na = d, b = e, c = f implies △ABC ≅ △DEF",
            "difficulty": 1
          },
          {
            "problem": "List the 5 congruence conditions.",
            "solution": "SSS (Side-Side-Side)\nSAS (Side-Angle-Side)\nASA (Angle-Side-Angle)\nAAS (Angle-Angle-Side)\nRHS (Right angle-Hypotenuse-Side)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Engineering", "description": "Component interchangeability" },
          { "field": "Architecture", "description": "Symmetric structures" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["triangle-basics"],
      "nextTopics": ["similar-triangles"],
      "related": ["isometry"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "triangle", "congruence"]
  },
  {
    "id": "quadrilaterals",
    "name": { "ko": "사각형", "en": "Quadrilaterals" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "네 개의 직선으로 둘러싸인 다각형이다. 내각의 합은 360°이다.",
        "formulas": [
          {
            "latex": "\\text{정사각형 넓이: } A = s^2",
            "description": "한 변의 길이가 s인 정사각형"
          },
          {
            "latex": "\\text{직사각형 넓이: } A = l \\times w",
            "description": "가로 l, 세로 w인 직사각형"
          },
          {
            "latex": "\\text{평행사변형 넓이: } A = b \\times h",
            "description": "밑변 b, 높이 h인 평행사변형"
          },
          {
            "latex": "\\text{사다리꼴 넓이: } A = \\frac{(a + b)}{2} \\times h",
            "description": "윗변 a, 아랫변 b, 높이 h인 사다리꼴"
          },
          {
            "latex": "\\text{마름모 넓이: } A = \\frac{d_1 \\times d_2}{2}",
            "description": "두 대각선이 d₁, d₂인 마름모"
          }
        ],
        "examples": [
          {
            "problem": "가로 8cm, 세로 5cm인 직사각형의 넓이와 둘레를 구하시오.",
            "solution": "넓이 = 8 × 5 = 40cm²\n둘레 = 2(8 + 5) = 26cm",
            "difficulty": 1
          },
          {
            "problem": "윗변 4cm, 아랫변 8cm, 높이 5cm인 사다리꼴의 넓이를 구하시오.",
            "solution": "A = (4 + 8)/2 × 5 = 6 × 5 = 30cm²",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "건축", "description": "방 면적 계산" },
          { "field": "토지", "description": "토지 면적 측량" }
        ]
      },
      "en": {
        "definition": "A polygon with four sides. The sum of interior angles is 360°.",
        "formulas": [
          { "latex": "\\text{Square area: } A = s^2", "description": "Square with side s" },
          {
            "latex": "\\text{Rectangle area: } A = l \\times w",
            "description": "Rectangle with length l, width w"
          },
          {
            "latex": "\\text{Parallelogram area: } A = b \\times h",
            "description": "Parallelogram with base b, height h"
          },
          {
            "latex": "\\text{Trapezoid area: } A = \\frac{(a + b)}{2} \\times h",
            "description": "Trapezoid with parallel sides a, b and height h"
          },
          {
            "latex": "\\text{Rhombus area: } A = \\frac{d_1 \\times d_2}{2}",
            "description": "Rhombus with diagonals d₁, d₂"
          }
        ],
        "examples": [
          {
            "problem": "Find the area and perimeter of a rectangle 8cm by 5cm.",
            "solution": "Area = 8 × 5 = 40cm²\nPerimeter = 2(8 + 5) = 26cm",
            "difficulty": 1
          },
          {
            "problem": "Find the area of a trapezoid with parallel sides 4cm and 8cm, height 5cm.",
            "solution": "A = (4 + 8)/2 × 5 = 6 × 5 = 30cm²",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Architecture", "description": "Room area calculation" },
          { "field": "Land", "description": "Land surveying" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["triangle-basics", "angles"],
      "nextTopics": ["polygon"],
      "related": ["parallel-lines"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "quadrilateral", "area"]
  },
  {
    "id": "circle-basics",
    "name": { "ko": "원", "en": "Circle" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "평면 위에서 한 점(중심)으로부터 같은 거리에 있는 모든 점의 집합이다.",
        "formulas": [
          {
            "latex": "C = 2\\pi r = \\pi d",
            "description": "원의 둘레 (원주)",
            "variables": [
              { "symbol": "r", "meaning": "반지름" },
              { "symbol": "d", "meaning": "지름 (d = 2r)" }
            ]
          },
          { "latex": "A = \\pi r^2", "description": "원의 넓이" },
          {
            "latex": "(x-a)^2 + (y-b)^2 = r^2",
            "description": "중심 (a, b), 반지름 r인 원의 방정식"
          }
        ],
        "examples": [
          {
            "problem": "반지름이 7cm인 원의 둘레와 넓이를 구하시오. (π ≈ 3.14)",
            "solution": "둘레 = 2π × 7 = 14π ≈ 43.96cm\n넓이 = π × 7² = 49π ≈ 153.86cm²",
            "difficulty": 1
          },
          {
            "problem": "넓이가 100πcm²인 원의 반지름을 구하시오.",
            "solution": "πr² = 100π\nr² = 100\nr = 10cm",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "공학", "description": "바퀴, 기어 설계" },
          { "field": "건축", "description": "돔, 원형 구조물" }
        ]
      },
      "en": {
        "definition": "The set of all points in a plane that are at a fixed distance from a center point.",
        "formulas": [
          {
            "latex": "C = 2\\pi r = \\pi d",
            "description": "Circumference",
            "variables": [
              { "symbol": "r", "meaning": "radius" },
              { "symbol": "d", "meaning": "diameter (d = 2r)" }
            ]
          },
          { "latex": "A = \\pi r^2", "description": "Area of circle" },
          {
            "latex": "(x-a)^2 + (y-b)^2 = r^2",
            "description": "Circle equation with center (a, b), radius r"
          }
        ],
        "examples": [
          {
            "problem": "Find the circumference and area of a circle with radius 7cm. (π ≈ 3.14)",
            "solution": "Circumference = 2π × 7 = 14π ≈ 43.96cm\nArea = π × 7² = 49π ≈ 153.86cm²",
            "difficulty": 1
          },
          {
            "problem": "Find the radius of a circle with area 100π cm².",
            "solution": "πr² = 100π\nr² = 100\nr = 10cm",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Engineering", "description": "Wheel, gear design" },
          { "field": "Architecture", "description": "Domes, circular structures" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["point-line-plane"],
      "nextTopics": ["radians", "arc-sector"],
      "related": ["pi-constant"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "circle", "fundamental"]
  },
  {
    "id": "arc-sector",
    "name": { "ko": "호와 부채꼴", "en": "Arc and Sector" },
    "field": "geometry",
    "subfield": "plane-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "호는 원 위의 두 점 사이의 곡선 부분이고, 부채꼴은 두 반지름과 호로 둘러싸인 영역이다.",
        "formulas": [
          {
            "latex": "l = \\frac{\\theta}{360°} \\times 2\\pi r = \\frac{\\theta \\pi r}{180}",
            "description": "호의 길이 (θ는 중심각, degree)"
          },
          { "latex": "l = r\\theta", "description": "호의 길이 (θ는 라디안)" },
          {
            "latex": "A = \\frac{\\theta}{360°} \\times \\pi r^2",
            "description": "부채꼴의 넓이 (θ는 degree)"
          },
          { "latex": "A = \\frac{1}{2}r^2\\theta", "description": "부채꼴의 넓이 (θ는 라디안)" }
        ],
        "examples": [
          {
            "problem": "반지름 10cm, 중심각 72°인 부채꼴의 호의 길이와 넓이를 구하시오.",
            "solution": "호의 길이 = (72/360) × 2π × 10 = (1/5) × 20π = 4π cm\n넓이 = (72/360) × π × 100 = 20π cm²",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "공학", "description": "원형 파이프, 원호 설계" },
          { "field": "그래픽", "description": "파이 차트" }
        ]
      },
      "en": {
        "definition": "An arc is a portion of the circle between two points. A sector is the region bounded by two radii and an arc.",
        "formulas": [
          {
            "latex": "l = \\frac{\\theta}{360°} \\times 2\\pi r",
            "description": "Arc length (θ in degrees)"
          },
          { "latex": "l = r\\theta", "description": "Arc length (θ in radians)" },
          {
            "latex": "A = \\frac{\\theta}{360°} \\times \\pi r^2",
            "description": "Sector area (θ in degrees)"
          },
          { "latex": "A = \\frac{1}{2}r^2\\theta", "description": "Sector area (θ in radians)" }
        ],
        "examples": [
          {
            "problem": "Find the arc length and area of a sector with radius 10cm and central angle 72°.",
            "solution": "Arc length = (72/360) × 2π × 10 = (1/5) × 20π = 4π cm\nArea = (72/360) × π × 100 = 20π cm²",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Engineering", "description": "Circular pipes, arc design" },
          { "field": "Graphics", "description": "Pie charts" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["circle-basics", "radians"],
      "nextTopics": ["circular-motion"],
      "related": ["angles"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "circle", "arc", "sector"]
  },
  {
    "id": "distance-formula",
    "name": { "ko": "두 점 사이의 거리", "en": "Distance Formula" },
    "field": "geometry",
    "subfield": "analytic-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "좌표평면에서 두 점 사이의 직선 거리를 피타고라스 정리를 이용해 구한다.",
        "formulas": [
          {
            "latex": "d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}",
            "description": "두 점 (x₁, y₁)과 (x₂, y₂) 사이의 거리"
          },
          {
            "latex": "d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}",
            "description": "3차원에서의 거리 공식"
          }
        ],
        "examples": [
          {
            "problem": "점 A(1, 2)와 점 B(4, 6) 사이의 거리를 구하시오.",
            "solution": "d = √[(4-1)² + (6-2)²]\n= √[9 + 16]\n= √25 = 5",
            "latex": "d = \\sqrt{3^2 + 4^2} = 5",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "GPS", "description": "위치 간 거리 계산" },
          { "field": "게임 개발", "description": "충돌 감지" }
        ]
      },
      "en": {
        "definition": "The straight-line distance between two points in a coordinate plane, derived from the Pythagorean theorem.",
        "formulas": [
          {
            "latex": "d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}",
            "description": "Distance between (x₁, y₁) and (x₂, y₂)"
          },
          {
            "latex": "d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}",
            "description": "3D distance formula"
          }
        ],
        "examples": [
          {
            "problem": "Find the distance between A(1, 2) and B(4, 6).",
            "solution": "d = √[(4-1)² + (6-2)²]\n= √[9 + 16]\n= √25 = 5",
            "latex": "d = \\sqrt{3^2 + 4^2} = 5",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "GPS", "description": "Distance between locations" },
          { "field": "Game Development", "description": "Collision detection" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["pythagorean-theorem", "coordinate-system"],
      "nextTopics": ["midpoint-formula", "slope"],
      "related": ["euclidean-distance"],
      "applications": ["applied-cs", "applied-physics"]
    },
    "tags": ["geometry", "coordinate", "distance", "analytic"]
  },
  {
    "id": "midpoint-formula",
    "name": { "ko": "중점 공식", "en": "Midpoint Formula" },
    "field": "geometry",
    "subfield": "analytic-geometry",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "두 점을 연결하는 선분의 중점 좌표를 구하는 공식이다.",
        "formulas": [
          {
            "latex": "M = \\left( \\frac{x_1 + x_2}{2}, \\frac{y_1 + y_2}{2} \\right)",
            "description": "중점 공식"
          }
        ],
        "examples": [
          {
            "problem": "점 A(2, 4)와 점 B(8, 10)의 중점을 구하시오.",
            "solution": "M = ((2+8)/2, (4+10)/2) = (5, 7)",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "컴퓨터 그래픽", "description": "객체 중심점 계산" },
          { "field": "물리학", "description": "무게중심" }
        ]
      },
      "en": {
        "definition": "A formula to find the coordinates of the midpoint of a line segment between two points.",
        "formulas": [
          {
            "latex": "M = \\left( \\frac{x_1 + x_2}{2}, \\frac{y_1 + y_2}{2} \\right)",
            "description": "Midpoint formula"
          }
        ],
        "examples": [
          {
            "problem": "Find the midpoint of A(2, 4) and B(8, 10).",
            "solution": "M = ((2+8)/2, (4+10)/2) = (5, 7)",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Computer Graphics", "description": "Object center calculation" },
          { "field": "Physics", "description": "Center of mass" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["point-line-plane"],
      "nextTopics": ["section-formula"],
      "related": ["distance-formula"],
      "applications": ["applied-cs"]
    },
    "tags": ["geometry", "coordinate", "midpoint", "analytic"]
  },
  {
    "id": "slope",
    "name": { "ko": "기울기", "en": "Slope" },
    "field": "geometry",
    "subfield": "analytic-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "직선의 기울어진 정도를 나타내는 값으로, 수평 변화량에 대한 수직 변화량의 비율이다.",
        "formulas": [
          {
            "latex": "m = \\frac{y_2 - y_1}{x_2 - x_1} = \\frac{\\Delta y}{\\Delta x}",
            "description": "두 점을 지나는 직선의 기울기"
          },
          { "latex": "y = mx + b", "description": "기울기-절편 형태의 직선 방정식" },
          { "latex": "m_1 \\cdot m_2 = -1", "description": "두 직선이 수직일 조건" }
        ],
        "examples": [
          {
            "problem": "점 (1, 2)와 (4, 8)을 지나는 직선의 기울기를 구하시오.",
            "solution": "m = (8-2)/(4-1) = 6/3 = 2",
            "difficulty": 1
          },
          {
            "problem": "기울기가 3인 직선에 수직인 직선의 기울기는?",
            "solution": "m₁ × m₂ = -1이므로\nm₂ = -1/3",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "물리학", "description": "속도, 가속도 그래프 분석" },
          { "field": "경제학", "description": "한계비용, 한계수입" }
        ]
      },
      "en": {
        "definition": "A measure of how steep a line is, calculated as the ratio of vertical change to horizontal change.",
        "formulas": [
          {
            "latex": "m = \\frac{y_2 - y_1}{x_2 - x_1} = \\frac{\\Delta y}{\\Delta x}",
            "description": "Slope of a line through two points"
          },
          { "latex": "y = mx + b", "description": "Slope-intercept form of a line" },
          { "latex": "m_1 \\cdot m_2 = -1", "description": "Condition for perpendicular lines" }
        ],
        "examples": [
          {
            "problem": "Find the slope of the line through (1, 2) and (4, 8).",
            "solution": "m = (8-2)/(4-1) = 6/3 = 2",
            "difficulty": 1
          },
          {
            "problem": "What slope is perpendicular to a line with slope 3?",
            "solution": "m₁ × m₂ = -1, so\nm₂ = -1/3",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Velocity, acceleration graphs" },
          { "field": "Economics", "description": "Marginal cost, marginal revenue" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["point-line-plane"],
      "nextTopics": ["linear-function", "parallel-lines"],
      "related": ["derivatives"],
      "applications": ["applied-physics", "applied-economics"]
    },
    "tags": ["geometry", "coordinate", "slope", "analytic"]
  },
  {
    "id": "conic-sections",
    "name": { "ko": "원뿔 곡선", "en": "Conic Sections" },
    "field": "geometry",
    "subfield": "analytic-geometry",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "원뿔을 평면으로 자를 때 생기는 곡선으로 원, 타원, 포물선, 쌍곡선이 있다.",
        "formulas": [
          { "latex": "x^2 + y^2 = r^2", "description": "원 (중심이 원점)" },
          {
            "latex": "\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1",
            "description": "타원 (중심이 원점)"
          },
          { "latex": "y = ax^2 + bx + c \\text{ 또는 } x^2 = 4py", "description": "포물선" },
          {
            "latex": "\\frac{x^2}{a^2} - \\frac{y^2}{b^2} = 1",
            "description": "쌍곡선 (중심이 원점)"
          }
        ],
        "examples": [
          {
            "problem": "타원 x²/9 + y²/4 = 1의 장축과 단축의 길이를 구하시오.",
            "solution": "a² = 9, b² = 4이므로 a = 3, b = 2\n장축 = 2a = 6\n단축 = 2b = 4",
            "difficulty": 2
          },
          {
            "problem": "포물선 y = x²의 초점을 구하시오.",
            "solution": "y = x²을 x² = y로 쓰면\n4p = 1, p = 1/4\n초점: (0, 1/4)",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "아폴로니우스",
          "year": "기원전 200년경",
          "background": "페르가의 아폴로니우스가 원뿔 곡선을 체계적으로 연구했다."
        },
        "applications": [
          { "field": "천문학", "description": "행성 궤도" },
          { "field": "공학", "description": "위성 안테나, 반사경" }
        ]
      },
      "en": {
        "definition": "Curves formed by intersecting a cone with a plane: circle, ellipse, parabola, and hyperbola.",
        "formulas": [
          { "latex": "x^2 + y^2 = r^2", "description": "Circle (centered at origin)" },
          {
            "latex": "\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1",
            "description": "Ellipse (centered at origin)"
          },
          { "latex": "y = ax^2 + bx + c \\text{ or } x^2 = 4py", "description": "Parabola" },
          {
            "latex": "\\frac{x^2}{a^2} - \\frac{y^2}{b^2} = 1",
            "description": "Hyperbola (centered at origin)"
          }
        ],
        "examples": [
          {
            "problem": "Find the major and minor axis lengths of ellipse x²/9 + y²/4 = 1.",
            "solution": "a² = 9, b² = 4, so a = 3, b = 2\nMajor axis = 2a = 6\nMinor axis = 2b = 4",
            "difficulty": 2
          },
          {
            "problem": "Find the focus of parabola y = x².",
            "solution": "Rewrite as x² = y\n4p = 1, p = 1/4\nFocus: (0, 1/4)",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "Apollonius of Perga",
          "year": "c. 200 BCE",
          "background": "Apollonius systematically studied conic sections."
        },
        "applications": [
          { "field": "Astronomy", "description": "Planetary orbits" },
          { "field": "Engineering", "description": "Satellite dishes, reflectors" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["circle-basics", "quadratic-equation"],
      "nextTopics": ["parametric-equations"],
      "related": ["polar-coordinates"],
      "applications": ["applied-physics", "applied-engineering"]
    },
    "tags": ["geometry", "conic", "analytic", "advanced"]
  },
  {
    "id": "solid-geometry-basics",
    "name": { "ko": "입체도형", "en": "Solid Figures" },
    "field": "geometry",
    "subfield": "solid-geometry",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "3차원 공간에서 부피와 겉넓이를 가지는 도형이다.",
        "formulas": [
          {
            "latex": "\\text{정육면체: } V = s^3, \\quad S = 6s^2",
            "description": "한 변이 s인 정육면체"
          },
          {
            "latex": "\\text{직육면체: } V = lwh, \\quad S = 2(lw + wh + lh)",
            "description": "가로 l, 세로 w, 높이 h인 직육면체"
          },
          {
            "latex": "\\text{구: } V = \\frac{4}{3}\\pi r^3, \\quad S = 4\\pi r^2",
            "description": "반지름 r인 구"
          },
          {
            "latex": "\\text{원기둥: } V = \\pi r^2 h, \\quad S = 2\\pi r(r + h)",
            "description": "밑면 반지름 r, 높이 h인 원기둥"
          },
          {
            "latex": "\\text{원뿔: } V = \\frac{1}{3}\\pi r^2 h",
            "description": "밑면 반지름 r, 높이 h인 원뿔"
          }
        ],
        "examples": [
          {
            "problem": "한 변이 4cm인 정육면체의 부피와 겉넓이를 구하시오.",
            "solution": "부피 = 4³ = 64cm³\n겉넓이 = 6 × 4² = 96cm²",
            "difficulty": 1
          },
          {
            "problem": "반지름 3cm인 구의 부피를 구하시오.",
            "solution": "V = (4/3)π × 3³ = (4/3)π × 27 = 36π cm³",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "건축", "description": "건물 공간 계산" },
          { "field": "제조", "description": "용기 용량 설계" }
        ]
      },
      "en": {
        "definition": "Three-dimensional shapes with volume and surface area.",
        "formulas": [
          { "latex": "\\text{Cube: } V = s^3, \\quad S = 6s^2", "description": "Cube with side s" },
          {
            "latex": "\\text{Rectangular prism: } V = lwh, \\quad S = 2(lw + wh + lh)",
            "description": "With length l, width w, height h"
          },
          {
            "latex": "\\text{Sphere: } V = \\frac{4}{3}\\pi r^3, \\quad S = 4\\pi r^2",
            "description": "Sphere with radius r"
          },
          {
            "latex": "\\text{Cylinder: } V = \\pi r^2 h, \\quad S = 2\\pi r(r + h)",
            "description": "Cylinder with radius r, height h"
          },
          {
            "latex": "\\text{Cone: } V = \\frac{1}{3}\\pi r^2 h",
            "description": "Cone with radius r, height h"
          }
        ],
        "examples": [
          {
            "problem": "Find the volume and surface area of a cube with side 4cm.",
            "solution": "Volume = 4³ = 64cm³\nSurface area = 6 × 4² = 96cm²",
            "difficulty": 1
          },
          {
            "problem": "Find the volume of a sphere with radius 3cm.",
            "solution": "V = (4/3)π × 3³ = (4/3)π × 27 = 36π cm³",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Architecture", "description": "Building space calculation" },
          { "field": "Manufacturing", "description": "Container capacity design" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["circle-basics", "quadrilaterals"],
      "nextTopics": ["surface-area", "volume-formulas"],
      "related": ["pi-constant"],
      "applications": ["applied-engineering"]
    },
    "tags": ["geometry", "solid", "3D", "volume"]
  },
  {
    "id": "limit",
    "name": { "ko": "극한", "en": "Limit" },
    "field": "analysis",
    "subfield": "limits-continuity",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "변수가 어떤 값에 한없이 가까워질 때 함수값이 다가가는 값이다.",
        "formulas": [
          {
            "latex": "\\lim_{x \\to a} f(x) = L",
            "description": "x가 a에 가까워질 때 f(x)가 L에 수렴",
            "variables": [
              { "symbol": "a", "meaning": "x가 접근하는 값" },
              { "symbol": "L", "meaning": "극한값" }
            ]
          },
          {
            "latex": "\\lim_{x \\to \\infty} \\frac{1}{x} = 0",
            "description": "무한대로 갈 때의 극한"
          }
        ],
        "examples": [
          {
            "problem": "lim(x→2) (x² - 4)/(x - 2)를 구하시오.",
            "solution": "분자를 인수분해: x² - 4 = (x+2)(x-2)\n(x+2)(x-2)/(x-2) = x+2\nx→2일 때: 2+2 = 4",
            "latex": "\\lim_{x \\to 2} \\frac{x^2 - 4}{x - 2} = \\lim_{x \\to 2} (x+2) = 4",
            "difficulty": 3
          },
          {
            "problem": "lim(x→∞) (3x² + x)/(x² + 1)를 구하시오.",
            "solution": "분자, 분모를 x²으로 나눔\n(3 + 1/x)/(1 + 1/x²)\nx→∞일 때: 3/1 = 3",
            "latex": "\\lim_{x \\to \\infty} \\frac{3x^2 + x}{x^2 + 1} = 3",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "오귀스탱 루이 코시, 카를 바이어슈트라스",
          "year": "19세기",
          "background": "엄밀한 ε-δ 정의는 바이어슈트라스가 확립했다."
        },
        "applications": [
          { "field": "미분", "description": "도함수의 정의" },
          { "field": "적분", "description": "정적분의 정의" }
        ]
      },
      "en": {
        "definition": "The value a function approaches as the variable approaches some value.",
        "formulas": [
          {
            "latex": "\\lim_{x \\to a} f(x) = L",
            "description": "f(x) approaches L as x approaches a",
            "variables": [
              { "symbol": "a", "meaning": "The value x approaches" },
              { "symbol": "L", "meaning": "The limit value" }
            ]
          },
          {
            "latex": "\\lim_{x \\to \\infty} \\frac{1}{x} = 0",
            "description": "Limit as x approaches infinity"
          }
        ],
        "examples": [
          {
            "problem": "Find lim(x→2) (x² - 4)/(x - 2).",
            "solution": "Factor numerator: x² - 4 = (x+2)(x-2)\n(x+2)(x-2)/(x-2) = x+2\nAs x→2: 2+2 = 4",
            "latex": "\\lim_{x \\to 2} \\frac{x^2 - 4}{x - 2} = \\lim_{x \\to 2} (x+2) = 4",
            "difficulty": 3
          },
          {
            "problem": "Find lim(x→∞) (3x² + x)/(x² + 1).",
            "solution": "Divide by x²\n(3 + 1/x)/(1 + 1/x²)\nAs x→∞: 3/1 = 3",
            "latex": "\\lim_{x \\to \\infty} \\frac{3x^2 + x}{x^2 + 1} = 3",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "Augustin-Louis Cauchy, Karl Weierstrass",
          "year": "19th century",
          "background": "The rigorous ε-δ definition was established by Weierstrass."
        },
        "applications": [
          { "field": "Differentiation", "description": "Definition of derivative" },
          { "field": "Integration", "description": "Definition of definite integral" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["functions", "infinity"],
      "nextTopics": ["derivative", "continuity"],
      "related": ["sequences", "series"],
      "applications": ["calculus"]
    },
    "tags": ["analysis", "calculus", "limit", "fundamental"]
  },
  {
    "id": "continuity",
    "name": { "ko": "연속성", "en": "Continuity" },
    "field": "analysis",
    "subfield": "limits-continuity",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "함수가 어떤 점에서 연속이란, 그 점에서 극한값과 함수값이 같다는 것이다.",
        "formulas": [{ "latex": "\\lim_{x \\to a} f(x) = f(a)", "description": "연속의 정의" }],
        "examples": [
          {
            "problem": "f(x) = |x|/x가 x=0에서 연속인지 판단하시오.",
            "solution": "lim(x→0⁺) f(x) = 1\nlim(x→0⁻) f(x) = -1\n좌극한 ≠ 우극한이므로 불연속",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "중간값 정리", "description": "연속함수의 중요한 성질" },
          { "field": "최대최소 정리", "description": "닫힌 구간에서 최대/최소 존재" }
        ]
      },
      "en": {
        "definition": "A function is continuous at a point if the limit equals the function value at that point.",
        "formulas": [
          { "latex": "\\lim_{x \\to a} f(x) = f(a)", "description": "Definition of continuity" }
        ],
        "examples": [
          {
            "problem": "Is f(x) = |x|/x continuous at x=0?",
            "solution": "lim(x→0⁺) f(x) = 1\nlim(x→0⁻) f(x) = -1\nLeft limit ≠ right limit, so discontinuous",
            "difficulty": 3
          }
        ],
        "applications": [
          {
            "field": "Intermediate Value Theorem",
            "description": "Key property of continuous functions"
          },
          {
            "field": "Extreme Value Theorem",
            "description": "Max/min existence on closed intervals"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["limit"],
      "nextTopics": ["derivative"],
      "related": ["intermediate-value-theorem"],
      "applications": ["applied-math"]
    },
    "tags": ["analysis", "continuity", "calculus"]
  },
  {
    "id": "derivative",
    "name": { "ko": "미분 / 도함수", "en": "Derivative" },
    "field": "analysis",
    "subfield": "differentiation",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "함수의 순간 변화율, 또는 그래프의 접선의 기울기를 나타낸다.",
        "formulas": [
          {
            "latex": "f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}",
            "description": "도함수의 정의 (극한)"
          },
          { "latex": "\\frac{d}{dx}(x^n) = nx^{n-1}", "description": "거듭제곱 미분법" },
          { "latex": "(fg)' = f'g + fg'", "description": "곱의 미분법" },
          {
            "latex": "\\left(\\frac{f}{g}\\right)' = \\frac{f'g - fg'}{g^2}",
            "description": "몫의 미분법"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x³의 도함수를 구하시오.",
            "solution": "거듭제곱 미분법 적용: d/dx(xⁿ) = nxⁿ⁻¹\nf'(x) = 3x²",
            "latex": "f'(x) = 3x^2",
            "difficulty": 3
          },
          {
            "problem": "f(x) = x²·sin(x)의 도함수를 구하시오.",
            "solution": "곱의 미분법: (fg)' = f'g + fg'\nf'(x) = 2x·sin(x) + x²·cos(x)",
            "latex": "f'(x) = 2x\\sin(x) + x^2\\cos(x)",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "아이작 뉴턴, 고트프리트 라이프니츠",
          "year": "17세기 후반",
          "background": "뉴턴과 라이프니츠가 독립적으로 미적분학을 발명했다."
        },
        "applications": [
          { "field": "물리학", "description": "속도, 가속도 계산" },
          { "field": "경제학", "description": "한계비용, 한계수익" },
          { "field": "최적화", "description": "함수의 극대/극소 찾기" }
        ]
      },
      "en": {
        "definition": "The instantaneous rate of change of a function, or slope of the tangent line.",
        "formulas": [
          {
            "latex": "f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}",
            "description": "Definition of derivative (limit)"
          },
          { "latex": "\\frac{d}{dx}(x^n) = nx^{n-1}", "description": "Power rule" },
          { "latex": "(fg)' = f'g + fg'", "description": "Product rule" },
          {
            "latex": "\\left(\\frac{f}{g}\\right)' = \\frac{f'g - fg'}{g^2}",
            "description": "Quotient rule"
          }
        ],
        "examples": [
          {
            "problem": "Find the derivative of f(x) = x³.",
            "solution": "Using power rule: d/dx(xⁿ) = nxⁿ⁻¹\nf'(x) = 3x²",
            "latex": "f'(x) = 3x^2",
            "difficulty": 3
          },
          {
            "problem": "Find the derivative of f(x) = x²·sin(x).",
            "solution": "Using product rule: (fg)' = f'g + fg'\nf'(x) = 2x·sin(x) + x²·cos(x)",
            "latex": "f'(x) = 2x\\sin(x) + x^2\\cos(x)",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "Isaac Newton, Gottfried Leibniz",
          "year": "Late 17th century",
          "background": "Newton and Leibniz independently invented calculus."
        },
        "applications": [
          { "field": "Physics", "description": "Velocity, acceleration" },
          { "field": "Economics", "description": "Marginal cost, marginal revenue" },
          { "field": "Optimization", "description": "Finding maxima and minima" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["limit", "functions"],
      "nextTopics": ["integral", "chain-rule"],
      "related": ["implicit-differentiation"],
      "applications": ["applied-physics", "applied-economics"]
    },
    "tags": ["analysis", "calculus", "derivative", "fundamental"]
  },
  {
    "id": "chain-rule",
    "name": { "ko": "연쇄 법칙", "en": "Chain Rule" },
    "field": "analysis",
    "subfield": "differentiation",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "합성함수의 미분법으로, 바깥 함수의 미분에 안쪽 함수의 미분을 곱한다.",
        "formulas": [
          { "latex": "\\frac{d}{dx}[f(g(x))] = f'(g(x)) \\cdot g'(x)", "description": "연쇄 법칙" },
          {
            "latex": "\\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx}",
            "description": "라이프니츠 표기법"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = sin(x²)의 도함수를 구하시오.",
            "solution": "외부함수: sin(u), 내부함수: u = x²\nf'(x) = cos(x²) · 2x = 2x cos(x²)",
            "latex": "f'(x) = 2x\\cos(x^2)",
            "difficulty": 3
          },
          {
            "problem": "f(x) = e^(3x+1)의 도함수를 구하시오.",
            "solution": "f'(x) = e^(3x+1) · 3 = 3e^(3x+1)",
            "latex": "f'(x) = 3e^{3x+1}",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "물리학", "description": "관련 변화율 문제" },
          { "field": "신경망", "description": "역전파 알고리즘" }
        ]
      },
      "en": {
        "definition": "Differentiation of composite functions: derivative of outer times derivative of inner.",
        "formulas": [
          {
            "latex": "\\frac{d}{dx}[f(g(x))] = f'(g(x)) \\cdot g'(x)",
            "description": "Chain rule"
          },
          {
            "latex": "\\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx}",
            "description": "Leibniz notation"
          }
        ],
        "examples": [
          {
            "problem": "Find the derivative of f(x) = sin(x²).",
            "solution": "Outer: sin(u), Inner: u = x²\nf'(x) = cos(x²) · 2x = 2x cos(x²)",
            "latex": "f'(x) = 2x\\cos(x^2)",
            "difficulty": 3
          },
          {
            "problem": "Find the derivative of f(x) = e^(3x+1).",
            "solution": "f'(x) = e^(3x+1) · 3 = 3e^(3x+1)",
            "latex": "f'(x) = 3e^{3x+1}",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Related rates problems" },
          { "field": "Neural Networks", "description": "Backpropagation algorithm" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative"],
      "nextTopics": ["implicit-differentiation"],
      "related": ["composite-functions"],
      "applications": ["applied-cs", "applied-physics"]
    },
    "tags": ["analysis", "calculus", "chain-rule", "differentiation"]
  },
  {
    "id": "derivatives-trig",
    "name": { "ko": "삼각함수의 미분", "en": "Derivatives of Trigonometric Functions" },
    "field": "analysis",
    "subfield": "differentiation",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "삼각함수들의 도함수 공식이다.",
        "formulas": [
          { "latex": "\\frac{d}{dx}(\\sin x) = \\cos x", "description": "사인의 미분" },
          { "latex": "\\frac{d}{dx}(\\cos x) = -\\sin x", "description": "코사인의 미분" },
          { "latex": "\\frac{d}{dx}(\\tan x) = \\sec^2 x", "description": "탄젠트의 미분" },
          { "latex": "\\frac{d}{dx}(\\sec x) = \\sec x \\tan x", "description": "시컨트의 미분" }
        ],
        "examples": [
          {
            "problem": "f(x) = sin(3x)의 도함수를 구하시오.",
            "solution": "연쇄법칙 적용: f'(x) = cos(3x) · 3 = 3cos(3x)",
            "difficulty": 2
          }
        ]
      },
      "en": {
        "definition": "Derivative formulas for trigonometric functions.",
        "formulas": [
          { "latex": "\\frac{d}{dx}(\\sin x) = \\cos x", "description": "Derivative of sine" },
          { "latex": "\\frac{d}{dx}(\\cos x) = -\\sin x", "description": "Derivative of cosine" },
          { "latex": "\\frac{d}{dx}(\\tan x) = \\sec^2 x", "description": "Derivative of tangent" },
          {
            "latex": "\\frac{d}{dx}(\\sec x) = \\sec x \\tan x",
            "description": "Derivative of secant"
          }
        ],
        "examples": [
          {
            "problem": "Find the derivative of f(x) = sin(3x).",
            "solution": "Using chain rule: f'(x) = cos(3x) · 3 = 3cos(3x)",
            "difficulty": 2
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "sine-cosine"],
      "nextTopics": ["derivatives-exp-log"],
      "related": ["chain-rule"],
      "applications": ["applied-physics"]
    },
    "tags": ["analysis", "calculus", "differentiation", "trigonometry"]
  },
  {
    "id": "derivatives-exp-log",
    "name": {
      "ko": "지수/로그 함수의 미분",
      "en": "Derivatives of Exponential and Logarithmic Functions"
    },
    "field": "analysis",
    "subfield": "differentiation",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "지수함수와 로그함수의 도함수 공식이다.",
        "formulas": [
          { "latex": "\\frac{d}{dx}(e^x) = e^x", "description": "자연지수함수의 미분 (자기 자신)" },
          { "latex": "\\frac{d}{dx}(a^x) = a^x \\ln a", "description": "일반 지수함수의 미분" },
          { "latex": "\\frac{d}{dx}(\\ln x) = \\frac{1}{x}", "description": "자연로그의 미분" },
          {
            "latex": "\\frac{d}{dx}(\\log_a x) = \\frac{1}{x \\ln a}",
            "description": "일반 로그의 미분"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = e^(2x)의 도함수를 구하시오.",
            "solution": "연쇄법칙: f'(x) = e^(2x) · 2 = 2e^(2x)",
            "difficulty": 2
          },
          {
            "problem": "f(x) = ln(x² + 1)의 도함수를 구하시오.",
            "solution": "연쇄법칙: f'(x) = (1/(x²+1)) · 2x = 2x/(x²+1)",
            "difficulty": 3
          }
        ]
      },
      "en": {
        "definition": "Derivative formulas for exponential and logarithmic functions.",
        "formulas": [
          {
            "latex": "\\frac{d}{dx}(e^x) = e^x",
            "description": "Derivative of natural exponential (itself)"
          },
          {
            "latex": "\\frac{d}{dx}(a^x) = a^x \\ln a",
            "description": "Derivative of general exponential"
          },
          {
            "latex": "\\frac{d}{dx}(\\ln x) = \\frac{1}{x}",
            "description": "Derivative of natural log"
          },
          {
            "latex": "\\frac{d}{dx}(\\log_a x) = \\frac{1}{x \\ln a}",
            "description": "Derivative of general log"
          }
        ],
        "examples": [
          {
            "problem": "Find the derivative of f(x) = e^(2x).",
            "solution": "Using chain rule: f'(x) = e^(2x) · 2 = 2e^(2x)",
            "difficulty": 2
          },
          {
            "problem": "Find the derivative of f(x) = ln(x² + 1).",
            "solution": "Using chain rule: f'(x) = (1/(x²+1)) · 2x = 2x/(x²+1)",
            "difficulty": 3
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "exponential-function", "logarithm"],
      "nextTopics": ["integral"],
      "related": ["chain-rule"],
      "applications": ["applied-physics", "applied-biology"]
    },
    "tags": ["analysis", "calculus", "differentiation", "exponential"]
  },
  {
    "id": "higher-derivatives",
    "name": { "ko": "고계 도함수", "en": "Higher Order Derivatives" },
    "field": "analysis",
    "subfield": "differentiation",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "도함수를 다시 미분한 것으로, 2차 도함수는 곡률과 관련된다.",
        "formulas": [
          {
            "latex": "f''(x) = \\frac{d^2y}{dx^2} = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right)",
            "description": "2차 도함수"
          },
          { "latex": "f^{(n)}(x) = \\frac{d^n y}{dx^n}", "description": "n차 도함수" }
        ],
        "examples": [
          {
            "problem": "f(x) = x⁴의 1차, 2차, 3차 도함수를 구하시오.",
            "solution": "f'(x) = 4x³\nf''(x) = 12x²\nf'''(x) = 24x",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "물리학", "description": "가속도 (속도의 미분)" },
          { "field": "곡률 분석", "description": "오목/볼록 판정" }
        ]
      },
      "en": {
        "definition": "Derivatives of derivatives. The second derivative relates to curvature.",
        "formulas": [
          {
            "latex": "f''(x) = \\frac{d^2y}{dx^2} = \\frac{d}{dx}\\left(\\frac{dy}{dx}\\right)",
            "description": "Second derivative"
          },
          { "latex": "f^{(n)}(x) = \\frac{d^n y}{dx^n}", "description": "nth derivative" }
        ],
        "examples": [
          {
            "problem": "Find the first, second, and third derivatives of f(x) = x⁴.",
            "solution": "f'(x) = 4x³\nf''(x) = 12x²\nf'''(x) = 24x",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Acceleration (derivative of velocity)" },
          { "field": "Curve Analysis", "description": "Concavity determination" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative"],
      "nextTopics": ["taylor-series"],
      "related": ["concavity"],
      "applications": ["applied-physics"]
    },
    "tags": ["analysis", "calculus", "differentiation"]
  },
  {
    "id": "indefinite-integral",
    "name": { "ko": "부정적분", "en": "Indefinite Integral" },
    "field": "analysis",
    "subfield": "integration",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "미분의 역연산으로, 도함수로부터 원래 함수를 찾는다.",
        "formulas": [
          {
            "latex": "\\int f(x)\\,dx = F(x) + C",
            "description": "부정적분의 정의 (C는 적분상수)"
          },
          {
            "latex": "\\int x^n\\,dx = \\frac{x^{n+1}}{n+1} + C \\quad (n \\neq -1)",
            "description": "거듭제곱 적분"
          },
          { "latex": "\\int e^x\\,dx = e^x + C", "description": "지수함수 적분" },
          { "latex": "\\int \\frac{1}{x}\\,dx = \\ln|x| + C", "description": "역수 적분" }
        ],
        "examples": [
          {
            "problem": "∫ 3x² dx를 구하시오.",
            "solution": "∫ 3x² dx = 3 · (x³/3) + C = x³ + C",
            "difficulty": 2
          },
          {
            "problem": "∫ (2x + cos x) dx를 구하시오.",
            "solution": "= x² + sin x + C",
            "difficulty": 2
          }
        ]
      },
      "en": {
        "definition": "The reverse of differentiation, finding the original function from its derivative.",
        "formulas": [
          {
            "latex": "\\int f(x)\\,dx = F(x) + C",
            "description": "Definition (C is constant of integration)"
          },
          {
            "latex": "\\int x^n\\,dx = \\frac{x^{n+1}}{n+1} + C \\quad (n \\neq -1)",
            "description": "Power rule for integration"
          },
          { "latex": "\\int e^x\\,dx = e^x + C", "description": "Exponential integral" },
          {
            "latex": "\\int \\frac{1}{x}\\,dx = \\ln|x| + C",
            "description": "Integral of reciprocal"
          }
        ],
        "examples": [
          {
            "problem": "Find ∫ 3x² dx.",
            "solution": "∫ 3x² dx = 3 · (x³/3) + C = x³ + C",
            "difficulty": 2
          },
          { "problem": "Find ∫ (2x + cos x) dx.", "solution": "= x² + sin x + C", "difficulty": 2 }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative"],
      "nextTopics": ["definite-integral"],
      "related": ["antiderivative"],
      "applications": ["applied-physics"]
    },
    "tags": ["analysis", "calculus", "integration", "fundamental"]
  },
  {
    "id": "definite-integral",
    "name": { "ko": "정적분", "en": "Definite Integral" },
    "field": "analysis",
    "subfield": "integration",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "함수와 x축 사이의 넓이를 나타내며, 극한으로 정의된다.",
        "formulas": [
          {
            "latex": "\\int_a^b f(x)\\,dx = \\lim_{n \\to \\infty} \\sum_{i=1}^n f(x_i)\\Delta x",
            "description": "리만 합의 극한으로 정의"
          },
          { "latex": "\\int_a^b f(x)\\,dx = F(b) - F(a)", "description": "미적분학의 기본정리" }
        ],
        "examples": [
          {
            "problem": "∫₀² x² dx를 구하시오.",
            "solution": "= [x³/3]₀² = 8/3 - 0 = 8/3",
            "latex": "\\int_0^2 x^2\\,dx = \\frac{8}{3}",
            "difficulty": 2
          },
          {
            "problem": "∫₀^π sin x dx를 구하시오.",
            "solution": "= [-cos x]₀^π = -(-1) - (-1) = 2",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "기하학", "description": "곡선 아래 넓이" },
          { "field": "물리학", "description": "변위, 일" }
        ]
      },
      "en": {
        "definition": "Represents the area between a function and the x-axis, defined as a limit.",
        "formulas": [
          {
            "latex": "\\int_a^b f(x)\\,dx = \\lim_{n \\to \\infty} \\sum_{i=1}^n f(x_i)\\Delta x",
            "description": "Defined as limit of Riemann sums"
          },
          {
            "latex": "\\int_a^b f(x)\\,dx = F(b) - F(a)",
            "description": "Fundamental Theorem of Calculus"
          }
        ],
        "examples": [
          {
            "problem": "Find ∫₀² x² dx.",
            "solution": "= [x³/3]₀² = 8/3 - 0 = 8/3",
            "latex": "\\int_0^2 x^2\\,dx = \\frac{8}{3}",
            "difficulty": 2
          },
          {
            "problem": "Find ∫₀^π sin x dx.",
            "solution": "= [-cos x]₀^π = -(-1) - (-1) = 2",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Geometry", "description": "Area under curves" },
          { "field": "Physics", "description": "Displacement, work" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["indefinite-integral", "limit"],
      "nextTopics": ["integration-techniques"],
      "related": ["riemann-sum"],
      "applications": ["applied-physics", "applied-engineering"]
    },
    "tags": ["analysis", "calculus", "integration", "fundamental"]
  },
  {
    "id": "integration-substitution",
    "name": { "ko": "치환적분", "en": "Integration by Substitution" },
    "field": "analysis",
    "subfield": "integration",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "연쇄법칙의 역으로, 복잡한 적분을 단순하게 만드는 기법이다.",
        "formulas": [
          {
            "latex": "\\int f(g(x)) \\cdot g'(x)\\,dx = \\int f(u)\\,du",
            "description": "치환적분 공식 (u = g(x))"
          }
        ],
        "examples": [
          {
            "problem": "∫ 2x·e^(x²) dx를 구하시오.",
            "solution": "u = x², du = 2x dx\n∫ e^u du = e^u + C = e^(x²) + C",
            "difficulty": 3
          },
          {
            "problem": "∫ cos(3x) dx를 구하시오.",
            "solution": "u = 3x, du = 3dx\n∫ cos u · (1/3) du = (1/3)sin u + C = (1/3)sin(3x) + C",
            "difficulty": 3
          }
        ]
      },
      "en": {
        "definition": "The reverse of the chain rule, simplifying complex integrals.",
        "formulas": [
          {
            "latex": "\\int f(g(x)) \\cdot g'(x)\\,dx = \\int f(u)\\,du",
            "description": "Substitution formula (u = g(x))"
          }
        ],
        "examples": [
          {
            "problem": "Find ∫ 2x·e^(x²) dx.",
            "solution": "u = x², du = 2x dx\n∫ e^u du = e^u + C = e^(x²) + C",
            "difficulty": 3
          },
          {
            "problem": "Find ∫ cos(3x) dx.",
            "solution": "u = 3x, du = 3dx\n∫ cos u · (1/3) du = (1/3)sin u + C = (1/3)sin(3x) + C",
            "difficulty": 3
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["indefinite-integral", "chain-rule"],
      "nextTopics": ["integration-by-parts"],
      "related": ["u-substitution"],
      "applications": []
    },
    "tags": ["analysis", "calculus", "integration", "technique"]
  },
  {
    "id": "integration-by-parts",
    "name": { "ko": "부분적분", "en": "Integration by Parts" },
    "field": "analysis",
    "subfield": "integration",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "곱의 미분법의 역으로, 두 함수의 곱을 적분하는 기법이다.",
        "formulas": [
          { "latex": "\\int u\\,dv = uv - \\int v\\,du", "description": "부분적분 공식" }
        ],
        "examples": [
          {
            "problem": "∫ x·e^x dx를 구하시오.",
            "solution": "u = x, dv = e^x dx\ndu = dx, v = e^x\n= xe^x - ∫ e^x dx = xe^x - e^x + C",
            "difficulty": 3
          },
          {
            "problem": "∫ x·cos x dx를 구하시오.",
            "solution": "u = x, dv = cos x dx\ndu = dx, v = sin x\n= x sin x - ∫ sin x dx = x sin x + cos x + C",
            "difficulty": 3
          }
        ]
      },
      "en": {
        "definition": "The reverse of the product rule, for integrating products of functions.",
        "formulas": [
          {
            "latex": "\\int u\\,dv = uv - \\int v\\,du",
            "description": "Integration by parts formula"
          }
        ],
        "examples": [
          {
            "problem": "Find ∫ x·e^x dx.",
            "solution": "u = x, dv = e^x dx\ndu = dx, v = e^x\n= xe^x - ∫ e^x dx = xe^x - e^x + C",
            "difficulty": 3
          },
          {
            "problem": "Find ∫ x·cos x dx.",
            "solution": "u = x, dv = cos x dx\ndu = dx, v = sin x\n= x sin x - ∫ sin x dx = x sin x + cos x + C",
            "difficulty": 3
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["indefinite-integral", "derivative"],
      "nextTopics": ["partial-fractions"],
      "related": ["product-rule"],
      "applications": []
    },
    "tags": ["analysis", "calculus", "integration", "technique"]
  },
  {
    "id": "taylor-series",
    "name": { "ko": "테일러 급수", "en": "Taylor Series" },
    "field": "analysis",
    "subfield": "series-sequences",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "함수를 무한 다항식으로 표현하는 급수 전개이다.",
        "formulas": [
          {
            "latex": "f(x) = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!}(x-a)^n",
            "description": "테일러 급수 (x=a 주위)"
          },
          {
            "latex": "e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!} = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + ...",
            "description": "자연지수함수의 테일러 급수"
          },
          {
            "latex": "\\sin x = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{(2n+1)!}",
            "description": "사인함수의 테일러 급수"
          },
          {
            "latex": "\\cos x = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n}}{(2n)!}",
            "description": "코사인함수의 테일러 급수"
          }
        ],
        "examples": [
          {
            "problem": "e^x의 x=0에서의 4차까지 테일러 다항식을 구하시오.",
            "solution": "P₄(x) = 1 + x + x²/2! + x³/3! + x⁴/4! = 1 + x + x²/2 + x³/6 + x⁴/24",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "브룩 테일러",
          "year": "1715년",
          "background": "콜린 매클로린이 x=0 특수 케이스를 연구했다."
        },
        "applications": [
          { "field": "근사 계산", "description": "복잡한 함수의 다항식 근사" },
          { "field": "물리학", "description": "선형화, 섭동 이론" },
          { "field": "컴퓨터", "description": "삼각/지수 함수 계산" }
        ]
      },
      "en": {
        "definition": "A series expansion that represents a function as an infinite polynomial.",
        "formulas": [
          {
            "latex": "f(x) = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!}(x-a)^n",
            "description": "Taylor series about x=a"
          },
          {
            "latex": "e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!} = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + ...",
            "description": "Taylor series for e^x"
          },
          {
            "latex": "\\sin x = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{(2n+1)!}",
            "description": "Taylor series for sine"
          },
          {
            "latex": "\\cos x = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n}}{(2n)!}",
            "description": "Taylor series for cosine"
          }
        ],
        "examples": [
          {
            "problem": "Find the Taylor polynomial of degree 4 for e^x about x=0.",
            "solution": "P₄(x) = 1 + x + x²/2! + x³/3! + x⁴/4! = 1 + x + x²/2 + x³/6 + x⁴/24",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "Brook Taylor",
          "year": "1715",
          "background": "Colin Maclaurin studied the special case at x=0."
        },
        "applications": [
          { "field": "Approximation", "description": "Polynomial approximation of functions" },
          { "field": "Physics", "description": "Linearization, perturbation theory" },
          { "field": "Computing", "description": "Trig/exponential function calculation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["higher-derivatives", "series"],
      "nextTopics": ["fourier-series"],
      "related": ["maclaurin-series"],
      "applications": ["applied-physics", "applied-cs"]
    },
    "tags": ["analysis", "series", "taylor", "advanced"]
  },
  {
    "id": "partial-derivative",
    "name": { "ko": "편미분", "en": "Partial Derivative" },
    "field": "analysis",
    "subfield": "multivariable",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "다변수 함수에서 하나의 변수에 대해서만 미분하는 것이다.",
        "formulas": [
          {
            "latex": "\\frac{\\partial f}{\\partial x} = \\lim_{h \\to 0} \\frac{f(x+h, y) - f(x, y)}{h}",
            "description": "x에 대한 편미분 정의"
          },
          {
            "latex": "\\nabla f = \\left( \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y} \\right)",
            "description": "그래디언트 (기울기 벡터)"
          }
        ],
        "examples": [
          {
            "problem": "f(x, y) = x²y + xy³에서 ∂f/∂x를 구하시오.",
            "solution": "y를 상수로 보고 x로 미분\n∂f/∂x = 2xy + y³",
            "difficulty": 3
          },
          {
            "problem": "f(x, y) = x²y + xy³에서 ∂f/∂y를 구하시오.",
            "solution": "x를 상수로 보고 y로 미분\n∂f/∂y = x² + 3xy²",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "최적화", "description": "다변수 함수의 극값" },
          { "field": "머신러닝", "description": "손실함수 최소화" },
          { "field": "물리학", "description": "열방정식, 파동방정식" }
        ]
      },
      "en": {
        "definition": "Differentiating a multivariable function with respect to one variable while holding others constant.",
        "formulas": [
          {
            "latex": "\\frac{\\partial f}{\\partial x} = \\lim_{h \\to 0} \\frac{f(x+h, y) - f(x, y)}{h}",
            "description": "Definition of partial derivative w.r.t. x"
          },
          {
            "latex": "\\nabla f = \\left( \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y} \\right)",
            "description": "Gradient vector"
          }
        ],
        "examples": [
          {
            "problem": "Find ∂f/∂x for f(x, y) = x²y + xy³.",
            "solution": "Treat y as constant, differentiate w.r.t. x\n∂f/∂x = 2xy + y³",
            "difficulty": 3
          },
          {
            "problem": "Find ∂f/∂y for f(x, y) = x²y + xy³.",
            "solution": "Treat x as constant, differentiate w.r.t. y\n∂f/∂y = x² + 3xy²",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Optimization", "description": "Extrema of multivariable functions" },
          { "field": "Machine Learning", "description": "Loss function minimization" },
          { "field": "Physics", "description": "Heat equation, wave equation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative"],
      "nextTopics": ["gradient", "multiple-integrals"],
      "related": ["directional-derivative"],
      "applications": ["applied-cs", "applied-physics"]
    },
    "tags": ["analysis", "calculus", "multivariable", "partial"]
  },
  {
    "id": "multiple-integrals",
    "name": { "ko": "중적분", "en": "Multiple Integrals" },
    "field": "analysis",
    "subfield": "multivariable",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "여러 변수에 대해 적분하는 것으로, 부피나 질량 등을 계산한다.",
        "formulas": [
          {
            "latex": "\\iint_R f(x,y)\\,dA = \\int_a^b \\int_c^d f(x,y)\\,dy\\,dx",
            "description": "이중적분 (반복적분)"
          },
          { "latex": "\\iiint_V f(x,y,z)\\,dV", "description": "삼중적분" }
        ],
        "examples": [
          {
            "problem": "∫∫_R xy dA (R: 0≤x≤1, 0≤y≤2)를 구하시오.",
            "solution": "= ∫₀¹ ∫₀² xy dy dx\n= ∫₀¹ [xy²/2]₀² dx\n= ∫₀¹ 2x dx = [x²]₀¹ = 1",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "물리학", "description": "질량, 관성 모멘트" },
          { "field": "공학", "description": "부피 계산" }
        ]
      },
      "en": {
        "definition": "Integration over multiple variables, used to compute volume, mass, etc.",
        "formulas": [
          {
            "latex": "\\iint_R f(x,y)\\,dA = \\int_a^b \\int_c^d f(x,y)\\,dy\\,dx",
            "description": "Double integral (iterated)"
          },
          { "latex": "\\iiint_V f(x,y,z)\\,dV", "description": "Triple integral" }
        ],
        "examples": [
          {
            "problem": "Find ∫∫_R xy dA where R: 0≤x≤1, 0≤y≤2.",
            "solution": "= ∫₀¹ ∫₀² xy dy dx\n= ∫₀¹ [xy²/2]₀² dx\n= ∫₀¹ 2x dx = [x²]₀¹ = 1",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Mass, moment of inertia" },
          { "field": "Engineering", "description": "Volume calculation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["definite-integral", "partial-derivative"],
      "nextTopics": ["surface-integrals"],
      "related": ["jacobian"],
      "applications": ["applied-physics", "applied-engineering"]
    },
    "tags": ["analysis", "calculus", "multivariable", "integration"]
  },
  {
    "id": "sine-cosine",
    "name": { "ko": "사인과 코사인", "en": "Sine and Cosine" },
    "field": "trigonometry",
    "subfield": "trig-functions",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "직각삼각형에서 사인(sin)은 대변/빗변, 코사인(cos)은 인접변/빗변의 비율입니다. 단위원에서는 각도 θ에 대해 점의 좌표가 (cos θ, sin θ)입니다.",
        "formulas": [
          {
            "latex": "\\sin \\theta = \\frac{\\text{대변}}{\\text{빗변}}",
            "description": "사인의 정의 (직각삼각형)"
          },
          {
            "latex": "\\cos \\theta = \\frac{\\text{인접변}}{\\text{빗변}}",
            "description": "코사인의 정의 (직각삼각형)"
          },
          { "latex": "\\sin^2 \\theta + \\cos^2 \\theta = 1", "description": "피타고라스 항등식" }
        ],
        "examples": [
          {
            "problem": "θ = 30°일 때 sin θ와 cos θ의 값을 구하세요.",
            "solution": "sin 30° = 1/2, cos 30° = √3/2"
          },
          {
            "problem": "sin θ = 3/5일 때, cos θ를 구하세요 (0° < θ < 90°).",
            "solution": "sin²θ + cos²θ = 1이므로, cos²θ = 1 - 9/25 = 16/25, cos θ = 4/5"
          }
        ],
        "history": {
          "discoveredBy": "히파르코스",
          "year": "기원전 190-120년경",
          "background": "고대 그리스의 천문학자 히파르코스가 삼각법의 기초를 세웠습니다."
        },
        "applications": [
          { "field": "물리학", "description": "파동, 진동, 회전 운동 분석" },
          { "field": "공학", "description": "신호 처리, 전자 회로 설계" },
          { "field": "컴퓨터 그래픽스", "description": "회전 변환, 애니메이션" }
        ]
      },
      "en": {
        "definition": "In a right triangle, sine (sin) is the ratio of opposite/hypotenuse, and cosine (cos) is adjacent/hypotenuse. On the unit circle, for angle θ, the point coordinates are (cos θ, sin θ).",
        "formulas": [
          {
            "latex": "\\sin \\theta = \\frac{\\text{opposite}}{\\text{hypotenuse}}",
            "description": "Definition of sine (right triangle)"
          },
          {
            "latex": "\\cos \\theta = \\frac{\\text{adjacent}}{\\text{hypotenuse}}",
            "description": "Definition of cosine (right triangle)"
          },
          {
            "latex": "\\sin^2 \\theta + \\cos^2 \\theta = 1",
            "description": "Pythagorean identity"
          }
        ],
        "examples": [
          {
            "problem": "Find sin θ and cos θ when θ = 30°.",
            "solution": "sin 30° = 1/2, cos 30° = √3/2"
          },
          {
            "problem": "If sin θ = 3/5, find cos θ (0° < θ < 90°).",
            "solution": "Since sin²θ + cos²θ = 1, cos²θ = 1 - 9/25 = 16/25, cos θ = 4/5"
          }
        ],
        "history": {
          "discoveredBy": "Hipparchus",
          "year": "c. 190-120 BCE",
          "background": "Ancient Greek astronomer Hipparchus established the foundations of trigonometry."
        },
        "applications": [
          { "field": "Physics", "description": "Wave, oscillation, rotation analysis" },
          { "field": "Engineering", "description": "Signal processing, circuit design" },
          { "field": "Computer Graphics", "description": "Rotation transforms, animation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["pythagorean-theorem"],
      "nextTopics": ["tangent", "inverse-trig"],
      "related": ["unit-circle", "radians"]
    },
    "tags": ["삼각함수", "사인", "코사인", "trigonometry", "sine", "cosine"]
  },
  {
    "id": "tangent",
    "name": { "ko": "탄젠트", "en": "Tangent" },
    "field": "trigonometry",
    "subfield": "trig-functions",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "탄젠트(tan)는 사인을 코사인으로 나눈 값으로, 직각삼각형에서는 대변/인접변의 비율입니다.",
        "formulas": [
          {
            "latex": "\\tan \\theta = \\frac{\\sin \\theta}{\\cos \\theta}",
            "description": "탄젠트의 정의"
          },
          {
            "latex": "\\tan \\theta = \\frac{\\text{대변}}{\\text{인접변}}",
            "description": "직각삼각형에서의 탄젠트"
          },
          { "latex": "1 + \\tan^2 \\theta = \\sec^2 \\theta", "description": "탄젠트 항등식" }
        ],
        "examples": [
          {
            "problem": "tan 45°의 값을 구하세요.",
            "solution": "tan 45° = sin 45° / cos 45° = (√2/2) / (√2/2) = 1"
          }
        ]
      },
      "en": {
        "definition": "Tangent (tan) is the ratio of sine to cosine, or in a right triangle, the ratio of opposite to adjacent side.",
        "formulas": [
          {
            "latex": "\\tan \\theta = \\frac{\\sin \\theta}{\\cos \\theta}",
            "description": "Definition of tangent"
          },
          {
            "latex": "\\tan \\theta = \\frac{\\text{opposite}}{\\text{adjacent}}",
            "description": "Tangent in a right triangle"
          },
          { "latex": "1 + \\tan^2 \\theta = \\sec^2 \\theta", "description": "Tangent identity" }
        ],
        "examples": [
          {
            "problem": "Find the value of tan 45°.",
            "solution": "tan 45° = sin 45° / cos 45° = (√2/2) / (√2/2) = 1"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sine-cosine"],
      "nextTopics": ["inverse-trig", "trig-identities"],
      "related": ["cotangent", "secant"]
    },
    "tags": ["삼각함수", "탄젠트", "trigonometry", "tangent"]
  },
  {
    "id": "unit-circle",
    "name": { "ko": "단위원", "en": "Unit Circle" },
    "field": "trigonometry",
    "subfield": "trig-functions",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "단위원은 원점을 중심으로 반지름이 1인 원입니다. 삼각함수를 정의하고 시각화하는 데 핵심적인 도구입니다.",
        "formulas": [
          { "latex": "x^2 + y^2 = 1", "description": "단위원의 방정식" },
          { "latex": "(x, y) = (\\cos \\theta, \\sin \\theta)", "description": "단위원 위의 점" }
        ],
        "examples": [
          {
            "problem": "단위원에서 θ = π/4일 때 좌표를 구하세요.",
            "solution": "(cos π/4, sin π/4) = (√2/2, √2/2)"
          }
        ],
        "applications": [
          { "field": "수학", "description": "삼각함수의 기하학적 정의" },
          { "field": "물리학", "description": "원운동, 회전 시스템" }
        ]
      },
      "en": {
        "definition": "The unit circle is a circle with radius 1 centered at the origin. It's a fundamental tool for defining and visualizing trigonometric functions.",
        "formulas": [
          { "latex": "x^2 + y^2 = 1", "description": "Unit circle equation" },
          {
            "latex": "(x, y) = (\\cos \\theta, \\sin \\theta)",
            "description": "Point on unit circle"
          }
        ],
        "examples": [
          {
            "problem": "Find the coordinates on the unit circle when θ = π/4.",
            "solution": "(cos π/4, sin π/4) = (√2/2, √2/2)"
          }
        ],
        "applications": [
          { "field": "Mathematics", "description": "Geometric definition of trig functions" },
          { "field": "Physics", "description": "Circular motion, rotation systems" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sine-cosine"],
      "nextTopics": ["radians", "trig-identities"],
      "related": ["complex-numbers"]
    },
    "tags": ["단위원", "삼각함수", "unit circle", "trigonometry"]
  },
  {
    "id": "radians",
    "name": { "ko": "라디안", "en": "Radians" },
    "field": "trigonometry",
    "subfield": "trig-functions",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "라디안은 호의 길이가 반지름과 같을 때의 중심각입니다. 360° = 2π 라디안입니다.",
        "formulas": [
          {
            "latex": "\\theta_{\\text{rad}} = \\frac{\\pi}{180} \\times \\theta_{\\text{deg}}",
            "description": "도(degree)를 라디안으로 변환"
          },
          { "latex": "s = r\\theta", "description": "호의 길이 (θ는 라디안)" },
          { "latex": "A = \\frac{1}{2}r^2\\theta", "description": "부채꼴의 넓이 (θ는 라디안)" }
        ],
        "examples": [
          { "problem": "90°를 라디안으로 변환하세요.", "solution": "90° × (π/180) = π/2 라디안" },
          {
            "problem": "반지름이 5이고 중심각이 π/3 라디안인 호의 길이를 구하세요.",
            "solution": "s = rθ = 5 × (π/3) = 5π/3"
          }
        ]
      },
      "en": {
        "definition": "A radian is the angle where the arc length equals the radius. 360° = 2π radians.",
        "formulas": [
          {
            "latex": "\\theta_{\\text{rad}} = \\frac{\\pi}{180} \\times \\theta_{\\text{deg}}",
            "description": "Convert degrees to radians"
          },
          { "latex": "s = r\\theta", "description": "Arc length (θ in radians)" },
          { "latex": "A = \\frac{1}{2}r^2\\theta", "description": "Sector area (θ in radians)" }
        ],
        "examples": [
          { "problem": "Convert 90° to radians.", "solution": "90° × (π/180) = π/2 radians" },
          {
            "problem": "Find the arc length with radius 5 and central angle π/3 radians.",
            "solution": "s = rθ = 5 × (π/3) = 5π/3"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["circle-basics"],
      "nextTopics": ["unit-circle", "trig-functions"],
      "related": ["pi-constant"]
    },
    "tags": ["라디안", "각도", "radians", "angle"]
  },
  {
    "id": "trig-identities",
    "name": { "ko": "삼각 항등식", "en": "Trigonometric Identities" },
    "field": "trigonometry",
    "subfield": "trig-identities",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "삼각 항등식은 모든 각도에서 성립하는 삼각함수 간의 등식입니다.",
        "formulas": [
          { "latex": "\\sin^2\\theta + \\cos^2\\theta = 1", "description": "피타고라스 항등식" },
          {
            "latex": "\\sin(A \\pm B) = \\sin A \\cos B \\pm \\cos A \\sin B",
            "description": "사인의 덧셈정리"
          },
          {
            "latex": "\\cos(A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B",
            "description": "코사인의 덧셈정리"
          },
          {
            "latex": "\\sin 2\\theta = 2\\sin\\theta\\cos\\theta",
            "description": "배각공식 (사인)"
          },
          {
            "latex": "\\cos 2\\theta = \\cos^2\\theta - \\sin^2\\theta",
            "description": "배각공식 (코사인)"
          }
        ],
        "examples": [
          {
            "problem": "sin 75°를 sin과 cos의 특수각을 사용해 구하세요.",
            "solution": "sin 75° = sin(45° + 30°) = sin45°cos30° + cos45°sin30° = (√2/2)(√3/2) + (√2/2)(1/2) = (√6 + √2)/4"
          }
        ]
      },
      "en": {
        "definition": "Trigonometric identities are equations involving trigonometric functions that hold true for all angles.",
        "formulas": [
          { "latex": "\\sin^2\\theta + \\cos^2\\theta = 1", "description": "Pythagorean identity" },
          {
            "latex": "\\sin(A \\pm B) = \\sin A \\cos B \\pm \\cos A \\sin B",
            "description": "Sine addition formula"
          },
          {
            "latex": "\\cos(A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B",
            "description": "Cosine addition formula"
          },
          {
            "latex": "\\sin 2\\theta = 2\\sin\\theta\\cos\\theta",
            "description": "Double angle formula (sine)"
          },
          {
            "latex": "\\cos 2\\theta = \\cos^2\\theta - \\sin^2\\theta",
            "description": "Double angle formula (cosine)"
          }
        ],
        "examples": [
          {
            "problem": "Find sin 75° using special angles.",
            "solution": "sin 75° = sin(45° + 30°) = sin45°cos30° + cos45°sin30° = (√2/2)(√3/2) + (√2/2)(1/2) = (√6 + √2)/4"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sine-cosine", "tangent"],
      "nextTopics": ["inverse-trig", "trig-equations"],
      "related": ["euler-formula"]
    },
    "tags": ["항등식", "삼각함수", "identities", "trigonometry"]
  },
  {
    "id": "inverse-trig",
    "name": { "ko": "역삼각함수", "en": "Inverse Trigonometric Functions" },
    "field": "trigonometry",
    "subfield": "trig-functions",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "역삼각함수는 삼각함수의 역함수로, 비율 값으로부터 각도를 구합니다. arcsin, arccos, arctan 등이 있습니다.",
        "formulas": [
          {
            "latex": "y = \\arcsin x \\Leftrightarrow \\sin y = x, \\quad -\\frac{\\pi}{2} \\leq y \\leq \\frac{\\pi}{2}",
            "description": "아크사인의 정의"
          },
          {
            "latex": "y = \\arccos x \\Leftrightarrow \\cos y = x, \\quad 0 \\leq y \\leq \\pi",
            "description": "아크코사인의 정의"
          },
          {
            "latex": "y = \\arctan x \\Leftrightarrow \\tan y = x, \\quad -\\frac{\\pi}{2} < y < \\frac{\\pi}{2}",
            "description": "아크탄젠트의 정의"
          }
        ],
        "examples": [
          {
            "problem": "arcsin(1/2)를 구하세요.",
            "solution": "sin(π/6) = 1/2이므로, arcsin(1/2) = π/6 (또는 30°)"
          },
          {
            "problem": "arctan(1)을 구하세요.",
            "solution": "tan(π/4) = 1이므로, arctan(1) = π/4 (또는 45°)"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "각도 계산, 궤적 분석" },
          { "field": "공학", "description": "로봇 역기구학, 제어 시스템" }
        ]
      },
      "en": {
        "definition": "Inverse trigonometric functions are the inverse functions of trigonometric functions, finding angles from ratio values. They include arcsin, arccos, and arctan.",
        "formulas": [
          {
            "latex": "y = \\arcsin x \\Leftrightarrow \\sin y = x, \\quad -\\frac{\\pi}{2} \\leq y \\leq \\frac{\\pi}{2}",
            "description": "Definition of arcsine"
          },
          {
            "latex": "y = \\arccos x \\Leftrightarrow \\cos y = x, \\quad 0 \\leq y \\leq \\pi",
            "description": "Definition of arccosine"
          },
          {
            "latex": "y = \\arctan x \\Leftrightarrow \\tan y = x, \\quad -\\frac{\\pi}{2} < y < \\frac{\\pi}{2}",
            "description": "Definition of arctangent"
          }
        ],
        "examples": [
          {
            "problem": "Find arcsin(1/2).",
            "solution": "Since sin(π/6) = 1/2, arcsin(1/2) = π/6 (or 30°)"
          },
          {
            "problem": "Find arctan(1).",
            "solution": "Since tan(π/4) = 1, arctan(1) = π/4 (or 45°)"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Angle calculation, trajectory analysis" },
          { "field": "Engineering", "description": "Robot inverse kinematics, control systems" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sine-cosine", "tangent"],
      "nextTopics": ["trig-equations"],
      "related": ["inverse-function"]
    },
    "tags": ["역삼각함수", "아크사인", "inverse trig", "arcsine"]
  },
  {
    "id": "law-of-sines",
    "name": { "ko": "사인 법칙", "en": "Law of Sines" },
    "field": "trigonometry",
    "subfield": "triangle-trig",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "사인 법칙은 삼각형의 각 변의 길이와 대각의 사인 값의 비가 일정함을 나타냅니다.",
        "formulas": [
          {
            "latex": "\\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C} = 2R",
            "description": "사인 법칙 (R은 외접원의 반지름)"
          }
        ],
        "examples": [
          {
            "problem": "삼각형에서 A = 30°, B = 45°, a = 5일 때, b를 구하세요.",
            "solution": "a/sin A = b/sin B에서 5/sin30° = b/sin45°, 5/(1/2) = b/(√2/2), b = 5√2"
          }
        ],
        "applications": [
          { "field": "측량학", "description": "거리 측정, 지도 제작" },
          { "field": "항해", "description": "선박 위치 결정" }
        ]
      },
      "en": {
        "definition": "The Law of Sines states that the ratio of each side length to the sine of its opposite angle is constant in a triangle.",
        "formulas": [
          {
            "latex": "\\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C} = 2R",
            "description": "Law of Sines (R is circumradius)"
          }
        ],
        "examples": [
          {
            "problem": "In a triangle with A = 30°, B = 45°, and a = 5, find b.",
            "solution": "From a/sin A = b/sin B: 5/sin30° = b/sin45°, 5/(1/2) = b/(√2/2), b = 5√2"
          }
        ],
        "applications": [
          { "field": "Surveying", "description": "Distance measurement, mapping" },
          { "field": "Navigation", "description": "Ship positioning" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sine-cosine", "triangle-basics"],
      "nextTopics": ["law-of-cosines"],
      "related": ["circumcircle"]
    },
    "tags": ["사인법칙", "삼각형", "law of sines", "triangle"]
  },
  {
    "id": "law-of-cosines",
    "name": { "ko": "코사인 법칙", "en": "Law of Cosines" },
    "field": "trigonometry",
    "subfield": "triangle-trig",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "코사인 법칙은 삼각형의 한 변의 길이를 다른 두 변과 그 사이각을 이용해 구하는 공식입니다. 피타고라스 정리의 일반화입니다.",
        "formulas": [
          { "latex": "c^2 = a^2 + b^2 - 2ab\\cos C", "description": "코사인 법칙" },
          {
            "latex": "\\cos C = \\frac{a^2 + b^2 - c^2}{2ab}",
            "description": "코사인 법칙 (각도 계산용)"
          }
        ],
        "examples": [
          {
            "problem": "a = 5, b = 7, C = 60°일 때 c를 구하세요.",
            "solution": "c² = 5² + 7² - 2(5)(7)cos60° = 25 + 49 - 70(1/2) = 39, c = √39"
          }
        ],
        "history": {
          "discoveredBy": "고대 그리스 수학자들",
          "background": "유클리드의 원론에서 기하학적 형태로 등장했으며, 현대적 공식은 삼각법 발전과 함께 정립되었습니다."
        },
        "applications": [
          { "field": "측량학", "description": "삼각측량" },
          { "field": "GPS", "description": "위치 결정 알고리즘" }
        ]
      },
      "en": {
        "definition": "The Law of Cosines relates one side of a triangle to the other two sides and their included angle. It generalizes the Pythagorean theorem.",
        "formulas": [
          { "latex": "c^2 = a^2 + b^2 - 2ab\\cos C", "description": "Law of Cosines" },
          {
            "latex": "\\cos C = \\frac{a^2 + b^2 - c^2}{2ab}",
            "description": "Law of Cosines (for finding angles)"
          }
        ],
        "examples": [
          {
            "problem": "Find c when a = 5, b = 7, and C = 60°.",
            "solution": "c² = 5² + 7² - 2(5)(7)cos60° = 25 + 49 - 70(1/2) = 39, c = √39"
          }
        ],
        "history": {
          "discoveredBy": "Ancient Greek mathematicians",
          "background": "Appeared in geometric form in Euclid's Elements; the modern formula developed with trigonometry."
        },
        "applications": [
          { "field": "Surveying", "description": "Triangulation" },
          { "field": "GPS", "description": "Positioning algorithms" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["pythagorean-theorem", "sine-cosine"],
      "nextTopics": ["law-of-sines"],
      "related": ["herons-formula"]
    },
    "tags": ["코사인법칙", "삼각형", "law of cosines", "triangle"]
  },
  {
    "id": "hyperbolic-functions",
    "name": { "ko": "쌍곡선 함수", "en": "Hyperbolic Functions" },
    "field": "trigonometry",
    "subfield": "hyperbolic",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "삼각함수와 유사한 형태를 가지며 쌍곡선과 관련된 함수이다. 지수함수로 정의된다.",
        "formulas": [
          {
            "latex": "\\sinh x = \\frac{e^x - e^{-x}}{2}",
            "description": "쌍곡사인 (hyperbolic sine)"
          },
          {
            "latex": "\\cosh x = \\frac{e^x + e^{-x}}{2}",
            "description": "쌍곡코사인 (hyperbolic cosine)"
          },
          {
            "latex": "\\tanh x = \\frac{\\sinh x}{\\cosh x} = \\frac{e^x - e^{-x}}{e^x + e^{-x}}",
            "description": "쌍곡탄젠트 (hyperbolic tangent)"
          },
          {
            "latex": "\\cosh^2 x - \\sinh^2 x = 1",
            "description": "쌍곡선 항등식 (삼각함수와 부호 차이에 주목)"
          }
        ],
        "examples": [
          {
            "problem": "sinh(0)과 cosh(0)의 값을 구하시오.",
            "solution": "sinh(0) = (e⁰ - e⁰)/2 = (1 - 1)/2 = 0\ncosh(0) = (e⁰ + e⁰)/2 = (1 + 1)/2 = 1",
            "difficulty": 2
          },
          {
            "problem": "cosh²(x) - sinh²(x) = 1임을 증명하시오.",
            "solution": "cosh²x = [(eˣ + e⁻ˣ)/2]² = (e²ˣ + 2 + e⁻²ˣ)/4\nsinh²x = [(eˣ - e⁻ˣ)/2]² = (e²ˣ - 2 + e⁻²ˣ)/4\ncosh²x - sinh²x = (e²ˣ + 2 + e⁻²ˣ - e²ˣ + 2 - e⁻²ˣ)/4 = 4/4 = 1",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "물리학", "description": "현수선(catenary) 곡선, 특수상대성이론" },
          { "field": "공학", "description": "전기회로, 신호처리" },
          { "field": "딥러닝", "description": "tanh 활성화 함수" }
        ]
      },
      "en": {
        "definition": "Functions related to hyperbolas, similar in form to trigonometric functions but defined using exponentials.",
        "formulas": [
          { "latex": "\\sinh x = \\frac{e^x - e^{-x}}{2}", "description": "Hyperbolic sine" },
          { "latex": "\\cosh x = \\frac{e^x + e^{-x}}{2}", "description": "Hyperbolic cosine" },
          {
            "latex": "\\tanh x = \\frac{\\sinh x}{\\cosh x} = \\frac{e^x - e^{-x}}{e^x + e^{-x}}",
            "description": "Hyperbolic tangent"
          },
          {
            "latex": "\\cosh^2 x - \\sinh^2 x = 1",
            "description": "Hyperbolic identity (note sign difference from trig)"
          }
        ],
        "examples": [
          {
            "problem": "Find sinh(0) and cosh(0).",
            "solution": "sinh(0) = (e⁰ - e⁰)/2 = (1 - 1)/2 = 0\ncosh(0) = (e⁰ + e⁰)/2 = (1 + 1)/2 = 1",
            "difficulty": 2
          },
          {
            "problem": "Prove that cosh²(x) - sinh²(x) = 1.",
            "solution": "cosh²x = [(eˣ + e⁻ˣ)/2]² = (e²ˣ + 2 + e⁻²ˣ)/4\nsinh²x = [(eˣ - e⁻ˣ)/2]² = (e²ˣ - 2 + e⁻²ˣ)/4\ncosh²x - sinh²x = (e²ˣ + 2 + e⁻²ˣ - e²ˣ + 2 - e⁻²ˣ)/4 = 4/4 = 1",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Catenary curves, special relativity" },
          { "field": "Engineering", "description": "Electric circuits, signal processing" },
          { "field": "Deep Learning", "description": "tanh activation function" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["exponential-function", "sine-cosine"],
      "nextTopics": ["inverse-hyperbolic"],
      "related": ["euler-formula"],
      "applications": ["applied-physics", "applied-cs"]
    },
    "tags": ["쌍곡선함수", "sinh", "cosh", "tanh", "hyperbolic"]
  },
  {
    "id": "inverse-hyperbolic",
    "name": { "ko": "역쌍곡선 함수", "en": "Inverse Hyperbolic Functions" },
    "field": "trigonometry",
    "subfield": "hyperbolic",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "쌍곡선 함수의 역함수로, 로그 함수로 표현할 수 있다.",
        "formulas": [
          { "latex": "\\text{arsinh } x = \\ln(x + \\sqrt{x^2 + 1})", "description": "역쌍곡사인" },
          {
            "latex": "\\text{arcosh } x = \\ln(x + \\sqrt{x^2 - 1}) \\quad (x \\geq 1)",
            "description": "역쌍곡코사인"
          },
          {
            "latex": "\\text{artanh } x = \\frac{1}{2}\\ln\\frac{1+x}{1-x} \\quad (|x| < 1)",
            "description": "역쌍곡탄젠트"
          }
        ],
        "examples": [
          {
            "problem": "arsinh(0)을 구하시오.",
            "solution": "arsinh(0) = ln(0 + √(0 + 1)) = ln(1) = 0",
            "difficulty": 2
          },
          {
            "problem": "arcosh(1)을 구하시오.",
            "solution": "arcosh(1) = ln(1 + √(1 - 1)) = ln(1 + 0) = ln(1) = 0",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "적분", "description": "특정 적분의 결과 표현" },
          { "field": "물리학", "description": "상대론적 속도 덧셈" }
        ]
      },
      "en": {
        "definition": "Inverse functions of hyperbolic functions, expressible in terms of logarithms.",
        "formulas": [
          {
            "latex": "\\text{arsinh } x = \\ln(x + \\sqrt{x^2 + 1})",
            "description": "Inverse hyperbolic sine"
          },
          {
            "latex": "\\text{arcosh } x = \\ln(x + \\sqrt{x^2 - 1}) \\quad (x \\geq 1)",
            "description": "Inverse hyperbolic cosine"
          },
          {
            "latex": "\\text{artanh } x = \\frac{1}{2}\\ln\\frac{1+x}{1-x} \\quad (|x| < 1)",
            "description": "Inverse hyperbolic tangent"
          }
        ],
        "examples": [
          {
            "problem": "Find arsinh(0).",
            "solution": "arsinh(0) = ln(0 + √(0 + 1)) = ln(1) = 0",
            "difficulty": 2
          },
          {
            "problem": "Find arcosh(1).",
            "solution": "arcosh(1) = ln(1 + √(1 - 1)) = ln(1 + 0) = ln(1) = 0",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Integration", "description": "Expressing certain integral results" },
          { "field": "Physics", "description": "Relativistic velocity addition" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["hyperbolic-functions", "logarithm"],
      "nextTopics": [],
      "related": ["inverse-trig"],
      "applications": ["applied-physics"]
    },
    "tags": ["역쌍곡선함수", "arsinh", "arcosh", "artanh", "inverse hyperbolic"]
  },
  {
    "id": "vectors-basics",
    "name": { "ko": "벡터", "en": "Vectors" },
    "field": "linear-algebra",
    "subfield": "vectors",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "크기와 방향을 모두 가진 양으로, 좌표로 표현된다.",
        "formulas": [
          {
            "latex": "\\vec{v} = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{pmatrix}",
            "description": "n차원 벡터 표기"
          },
          {
            "latex": "|\\vec{v}| = \\sqrt{v_1^2 + v_2^2 + ... + v_n^2}",
            "description": "벡터의 크기 (노름)"
          },
          { "latex": "\\hat{v} = \\frac{\\vec{v}}{|\\vec{v}|}", "description": "단위 벡터" }
        ],
        "examples": [
          {
            "problem": "벡터 v = (3, 4)의 크기를 구하시오.",
            "solution": "|v| = √(3² + 4²) = √25 = 5",
            "difficulty": 1
          },
          {
            "problem": "벡터 v = (3, 4)의 단위 벡터를 구하시오.",
            "solution": "v̂ = (3/5, 4/5) = (0.6, 0.8)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "물리학", "description": "힘, 속도, 가속도" },
          { "field": "컴퓨터 그래픽", "description": "위치, 방향 표현" }
        ]
      },
      "en": {
        "definition": "A quantity with both magnitude and direction, represented by coordinates.",
        "formulas": [
          {
            "latex": "\\vec{v} = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{pmatrix}",
            "description": "n-dimensional vector notation"
          },
          {
            "latex": "|\\vec{v}| = \\sqrt{v_1^2 + v_2^2 + ... + v_n^2}",
            "description": "Vector magnitude (norm)"
          },
          { "latex": "\\hat{v} = \\frac{\\vec{v}}{|\\vec{v}|}", "description": "Unit vector" }
        ],
        "examples": [
          {
            "problem": "Find the magnitude of v = (3, 4).",
            "solution": "|v| = √(3² + 4²) = √25 = 5",
            "difficulty": 1
          },
          {
            "problem": "Find the unit vector of v = (3, 4).",
            "solution": "v̂ = (3/5, 4/5) = (0.6, 0.8)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Force, velocity, acceleration" },
          { "field": "Computer Graphics", "description": "Position, direction" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["pythagorean-theorem"],
      "nextTopics": ["vector-operations", "dot-product"],
      "related": ["coordinate-system"],
      "applications": ["applied-physics", "applied-cs"]
    },
    "tags": ["linear-algebra", "vector", "fundamental"]
  },
  {
    "id": "vector-operations",
    "name": { "ko": "벡터 연산", "en": "Vector Operations" },
    "field": "linear-algebra",
    "subfield": "vectors",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "벡터의 덧셈, 뺄셈, 스칼라 곱 등의 기본 연산이다.",
        "formulas": [
          {
            "latex": "\\vec{u} + \\vec{v} = \\begin{pmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\end{pmatrix}",
            "description": "벡터의 덧셈 (성분별)"
          },
          {
            "latex": "c\\vec{v} = \\begin{pmatrix} cv_1 \\\\ cv_2 \\end{pmatrix}",
            "description": "스칼라 곱"
          },
          { "latex": "\\vec{u} - \\vec{v} = \\vec{u} + (-1)\\vec{v}", "description": "벡터의 뺄셈" }
        ],
        "examples": [
          {
            "problem": "u = (1, 2), v = (3, 4)일 때 u + v를 구하시오.",
            "solution": "u + v = (1+3, 2+4) = (4, 6)",
            "difficulty": 1
          },
          {
            "problem": "v = (2, -3)일 때 3v를 구하시오.",
            "solution": "3v = (6, -9)",
            "difficulty": 1
          }
        ]
      },
      "en": {
        "definition": "Basic operations on vectors: addition, subtraction, scalar multiplication.",
        "formulas": [
          {
            "latex": "\\vec{u} + \\vec{v} = \\begin{pmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\end{pmatrix}",
            "description": "Vector addition (component-wise)"
          },
          {
            "latex": "c\\vec{v} = \\begin{pmatrix} cv_1 \\\\ cv_2 \\end{pmatrix}",
            "description": "Scalar multiplication"
          },
          {
            "latex": "\\vec{u} - \\vec{v} = \\vec{u} + (-1)\\vec{v}",
            "description": "Vector subtraction"
          }
        ],
        "examples": [
          {
            "problem": "If u = (1, 2) and v = (3, 4), find u + v.",
            "solution": "u + v = (1+3, 2+4) = (4, 6)",
            "difficulty": 1
          },
          { "problem": "If v = (2, -3), find 3v.", "solution": "3v = (6, -9)", "difficulty": 1 }
        ]
      }
    },
    "relations": {
      "prerequisites": ["vectors-basics"],
      "nextTopics": ["dot-product", "cross-product"],
      "related": ["linear-combination"],
      "applications": ["applied-physics", "applied-cs"]
    },
    "tags": ["linear-algebra", "vector", "operations"]
  },
  {
    "id": "dot-product",
    "name": { "ko": "내적", "en": "Dot Product" },
    "field": "linear-algebra",
    "subfield": "vectors",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "두 벡터의 대응하는 성분을 곱한 후 합한 스칼라 값이다. 두 벡터의 사이각을 구하는 데 사용된다.",
        "formulas": [
          {
            "latex": "\\vec{u} \\cdot \\vec{v} = u_1v_1 + u_2v_2 + ... + u_nv_n",
            "description": "내적의 정의 (성분 계산)"
          },
          {
            "latex": "\\vec{u} \\cdot \\vec{v} = |\\vec{u}||\\vec{v}|\\cos\\theta",
            "description": "내적의 기하학적 정의"
          },
          {
            "latex": "\\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{|\\vec{u}||\\vec{v}|}",
            "description": "두 벡터 사이의 각도"
          }
        ],
        "examples": [
          {
            "problem": "u = (1, 2, 3), v = (4, 5, 6)의 내적을 구하시오.",
            "solution": "u · v = 1×4 + 2×5 + 3×6 = 4 + 10 + 18 = 32",
            "difficulty": 2
          },
          {
            "problem": "u = (1, 0), v = (0, 1)의 사이각을 구하시오.",
            "solution": "u · v = 0, |u| = |v| = 1\ncos θ = 0\nθ = 90°",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "물리학", "description": "일 = 힘 · 변위" },
          { "field": "머신러닝", "description": "코사인 유사도" },
          { "field": "컴퓨터 그래픽", "description": "조명 계산" }
        ]
      },
      "en": {
        "definition": "The sum of products of corresponding components, resulting in a scalar. Used to find angles between vectors.",
        "formulas": [
          {
            "latex": "\\vec{u} \\cdot \\vec{v} = u_1v_1 + u_2v_2 + ... + u_nv_n",
            "description": "Dot product definition (component)"
          },
          {
            "latex": "\\vec{u} \\cdot \\vec{v} = |\\vec{u}||\\vec{v}|\\cos\\theta",
            "description": "Geometric definition"
          },
          {
            "latex": "\\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{|\\vec{u}||\\vec{v}|}",
            "description": "Angle between vectors"
          }
        ],
        "examples": [
          {
            "problem": "Find the dot product of u = (1, 2, 3) and v = (4, 5, 6).",
            "solution": "u · v = 1×4 + 2×5 + 3×6 = 4 + 10 + 18 = 32",
            "difficulty": 2
          },
          {
            "problem": "Find the angle between u = (1, 0) and v = (0, 1).",
            "solution": "u · v = 0, |u| = |v| = 1\ncos θ = 0\nθ = 90°",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Work = Force · Displacement" },
          { "field": "Machine Learning", "description": "Cosine similarity" },
          { "field": "Computer Graphics", "description": "Lighting calculations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["vectors-basics"],
      "nextTopics": ["cross-product", "orthogonality"],
      "related": ["projection"],
      "applications": ["applied-physics", "applied-cs"]
    },
    "tags": ["linear-algebra", "vector", "dot-product"]
  },
  {
    "id": "cross-product",
    "name": { "ko": "외적", "en": "Cross Product" },
    "field": "linear-algebra",
    "subfield": "vectors",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "3차원 벡터에서 정의되며, 두 벡터에 모두 수직인 새 벡터를 생성한다.",
        "formulas": [
          {
            "latex": "\\vec{u} \\times \\vec{v} = \\begin{pmatrix} u_2v_3 - u_3v_2 \\\\ u_3v_1 - u_1v_3 \\\\ u_1v_2 - u_2v_1 \\end{pmatrix}",
            "description": "외적의 성분 공식"
          },
          {
            "latex": "|\\vec{u} \\times \\vec{v}| = |\\vec{u}||\\vec{v}|\\sin\\theta",
            "description": "외적의 크기 (평행사변형 넓이)"
          }
        ],
        "examples": [
          {
            "problem": "u = (1, 0, 0), v = (0, 1, 0)의 외적을 구하시오.",
            "solution": "u × v = (0×0 - 0×1, 0×0 - 1×0, 1×1 - 0×0)\n= (0, 0, 1)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "물리학", "description": "토크, 각운동량" },
          { "field": "컴퓨터 그래픽", "description": "법선 벡터 계산" }
        ]
      },
      "en": {
        "definition": "Defined for 3D vectors, produces a vector perpendicular to both input vectors.",
        "formulas": [
          {
            "latex": "\\vec{u} \\times \\vec{v} = \\begin{pmatrix} u_2v_3 - u_3v_2 \\\\ u_3v_1 - u_1v_3 \\\\ u_1v_2 - u_2v_1 \\end{pmatrix}",
            "description": "Cross product component formula"
          },
          {
            "latex": "|\\vec{u} \\times \\vec{v}| = |\\vec{u}||\\vec{v}|\\sin\\theta",
            "description": "Magnitude (parallelogram area)"
          }
        ],
        "examples": [
          {
            "problem": "Find u × v for u = (1, 0, 0) and v = (0, 1, 0).",
            "solution": "u × v = (0×0 - 0×1, 0×0 - 1×0, 1×1 - 0×0)\n= (0, 0, 1)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Torque, angular momentum" },
          { "field": "Computer Graphics", "description": "Normal vector calculation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["vectors-basics", "dot-product"],
      "nextTopics": [],
      "related": ["determinant"],
      "applications": ["applied-physics", "applied-cs"]
    },
    "tags": ["linear-algebra", "vector", "cross-product"]
  },
  {
    "id": "matrices-basics",
    "name": { "ko": "행렬", "en": "Matrices" },
    "field": "linear-algebra",
    "subfield": "matrices",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "수를 직사각형 배열로 나열한 것으로, 선형 변환과 연립방정식을 표현한다.",
        "formulas": [
          {
            "latex": "A = \\begin{pmatrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{pmatrix}",
            "description": "2×2 행렬 표기"
          },
          { "latex": "A_{m \\times n}", "description": "m행 n열 행렬" }
        ],
        "examples": [
          {
            "problem": "A = [[1, 2], [3, 4]]의 (2, 1) 성분을 구하시오.",
            "solution": "2행 1열의 성분은 3이다.",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "컴퓨터 그래픽", "description": "변환 행렬" },
          { "field": "데이터 과학", "description": "데이터 표현" }
        ]
      },
      "en": {
        "definition": "A rectangular array of numbers, used to represent linear transformations and systems of equations.",
        "formulas": [
          {
            "latex": "A = \\begin{pmatrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{pmatrix}",
            "description": "2×2 matrix notation"
          },
          { "latex": "A_{m \\times n}", "description": "m rows by n columns matrix" }
        ],
        "examples": [
          {
            "problem": "Find the (2, 1) entry of A = [[1, 2], [3, 4]].",
            "solution": "The entry in row 2, column 1 is 3.",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Computer Graphics", "description": "Transformation matrices" },
          { "field": "Data Science", "description": "Data representation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["vectors-basics"],
      "nextTopics": ["matrix-operations", "determinant"],
      "related": ["linear-transformation"],
      "applications": ["applied-cs"]
    },
    "tags": ["linear-algebra", "matrix", "fundamental"]
  },
  {
    "id": "matrix-operations",
    "name": { "ko": "행렬 연산", "en": "Matrix Operations" },
    "field": "linear-algebra",
    "subfield": "matrices",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "행렬의 덧셈, 스칼라 곱, 행렬 곱셈 등의 연산이다.",
        "formulas": [
          {
            "latex": "(A + B)_{ij} = A_{ij} + B_{ij}",
            "description": "행렬의 덧셈 (같은 크기일 때)"
          },
          { "latex": "(cA)_{ij} = c \\cdot A_{ij}", "description": "스칼라 곱" },
          {
            "latex": "(AB)_{ij} = \\sum_{k=1}^{n} A_{ik}B_{kj}",
            "description": "행렬 곱셈 (A: m×n, B: n×p → AB: m×p)"
          }
        ],
        "examples": [
          {
            "problem": "A = [[1, 2], [3, 4]], B = [[5, 6], [7, 8]]일 때 AB를 구하시오.",
            "solution": "AB = [[1×5+2×7, 1×6+2×8], [3×5+4×7, 3×6+4×8]]\n= [[19, 22], [43, 50]]",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "컴퓨터 그래픽", "description": "연속 변환의 합성" },
          { "field": "신경망", "description": "레이어 간 연산" }
        ]
      },
      "en": {
        "definition": "Operations on matrices: addition, scalar multiplication, matrix multiplication.",
        "formulas": [
          {
            "latex": "(A + B)_{ij} = A_{ij} + B_{ij}",
            "description": "Matrix addition (same dimensions)"
          },
          { "latex": "(cA)_{ij} = c \\cdot A_{ij}", "description": "Scalar multiplication" },
          {
            "latex": "(AB)_{ij} = \\sum_{k=1}^{n} A_{ik}B_{kj}",
            "description": "Matrix multiplication (A: m×n, B: n×p → AB: m×p)"
          }
        ],
        "examples": [
          {
            "problem": "Find AB where A = [[1, 2], [3, 4]] and B = [[5, 6], [7, 8]].",
            "solution": "AB = [[1×5+2×7, 1×6+2×8], [3×5+4×7, 3×6+4×8]]\n= [[19, 22], [43, 50]]",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Computer Graphics", "description": "Composition of transformations" },
          { "field": "Neural Networks", "description": "Layer computations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["matrices-basics"],
      "nextTopics": ["determinant", "inverse-matrix"],
      "related": ["matrix-transpose"],
      "applications": ["applied-cs"]
    },
    "tags": ["linear-algebra", "matrix", "operations"]
  },
  {
    "id": "determinant",
    "name": { "ko": "행렬식", "en": "Determinant" },
    "field": "linear-algebra",
    "subfield": "matrices",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "정방행렬에 대해 정의되는 스칼라 값으로, 역행렬의 존재 여부와 선형변환의 부피 변화를 나타낸다.",
        "formulas": [
          {
            "latex": "\\det(A) = |A| = ad - bc \\quad (2 \\times 2)",
            "description": "2×2 행렬의 행렬식",
            "variables": [{ "symbol": "A", "meaning": "[[a, b], [c, d]]" }]
          },
          {
            "latex": "\\det(A) = \\sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}",
            "description": "여인수 전개 (n×n)"
          }
        ],
        "examples": [
          {
            "problem": "A = [[3, 1], [2, 4]]의 행렬식을 구하시오.",
            "solution": "det(A) = 3×4 - 1×2 = 12 - 2 = 10",
            "difficulty": 2
          },
          {
            "problem": "det(A) = 0일 때 A의 특성은?",
            "solution": "특이행렬(singular matrix)이며 역행렬이 존재하지 않는다.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "선형대수", "description": "역행렬 존재 판단" },
          { "field": "기하학", "description": "넓이/부피 변화율" }
        ]
      },
      "en": {
        "definition": "A scalar value for square matrices, indicating invertibility and volume scaling of linear transformations.",
        "formulas": [
          {
            "latex": "\\det(A) = |A| = ad - bc \\quad (2 \\times 2)",
            "description": "Determinant of 2×2 matrix",
            "variables": [{ "symbol": "A", "meaning": "[[a, b], [c, d]]" }]
          },
          {
            "latex": "\\det(A) = \\sum_{j=1}^{n} (-1)^{1+j} a_{1j} M_{1j}",
            "description": "Cofactor expansion (n×n)"
          }
        ],
        "examples": [
          {
            "problem": "Find det(A) for A = [[3, 1], [2, 4]].",
            "solution": "det(A) = 3×4 - 1×2 = 12 - 2 = 10",
            "difficulty": 2
          },
          {
            "problem": "What does det(A) = 0 imply?",
            "solution": "A is singular and has no inverse.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Linear Algebra", "description": "Invertibility test" },
          { "field": "Geometry", "description": "Area/volume scaling" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["matrices-basics"],
      "nextTopics": ["inverse-matrix", "eigenvalues"],
      "related": ["cramers-rule"],
      "applications": ["applied-math"]
    },
    "tags": ["linear-algebra", "matrix", "determinant"]
  },
  {
    "id": "inverse-matrix",
    "name": { "ko": "역행렬", "en": "Inverse Matrix" },
    "field": "linear-algebra",
    "subfield": "matrices",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "행렬 A에 대해 AB = BA = I를 만족하는 행렬 B를 A의 역행렬이라 한다.",
        "formulas": [
          { "latex": "AA^{-1} = A^{-1}A = I", "description": "역행렬의 정의" },
          {
            "latex": "A^{-1} = \\frac{1}{\\det(A)} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}",
            "description": "2×2 행렬의 역행렬 (det(A) ≠ 0)"
          }
        ],
        "examples": [
          {
            "problem": "A = [[2, 1], [5, 3]]의 역행렬을 구하시오.",
            "solution": "det(A) = 6 - 5 = 1\nA⁻¹ = [[3, -1], [-5, 2]]",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "연립방정식", "description": "Ax = b → x = A⁻¹b" },
          { "field": "암호학", "description": "행렬 암호화" }
        ]
      },
      "en": {
        "definition": "Matrix B such that AB = BA = I, where I is the identity matrix.",
        "formulas": [
          { "latex": "AA^{-1} = A^{-1}A = I", "description": "Definition of inverse" },
          {
            "latex": "A^{-1} = \\frac{1}{\\det(A)} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}",
            "description": "Inverse of 2×2 matrix (det(A) ≠ 0)"
          }
        ],
        "examples": [
          {
            "problem": "Find the inverse of A = [[2, 1], [5, 3]].",
            "solution": "det(A) = 6 - 5 = 1\nA⁻¹ = [[3, -1], [-5, 2]]",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Systems of equations", "description": "Ax = b → x = A⁻¹b" },
          { "field": "Cryptography", "description": "Matrix encryption" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["determinant"],
      "nextTopics": ["systems-linear-equations"],
      "related": ["identity-matrix"],
      "applications": ["applied-cs"]
    },
    "tags": ["linear-algebra", "matrix", "inverse"]
  },
  {
    "id": "systems-linear-equations",
    "name": { "ko": "연립일차방정식과 행렬", "en": "Systems of Linear Equations (Matrix Form)" },
    "field": "linear-algebra",
    "subfield": "applications",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "연립방정식을 행렬 형태 Ax = b로 표현하고 풀 수 있다.",
        "formulas": [
          { "latex": "Ax = b", "description": "연립방정식의 행렬 표현" },
          { "latex": "x = A^{-1}b", "description": "역행렬을 이용한 풀이 (det(A) ≠ 0)" }
        ],
        "examples": [
          {
            "problem": "x + 2y = 5, 3x + 4y = 11을 행렬로 풀어라.",
            "solution": "A = [[1, 2], [3, 4]], b = [5, 11]\ndet(A) = -2\nA⁻¹ = [[-2, 1], [1.5, -0.5]]\nx = A⁻¹b = [1, 2]",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "공학", "description": "회로 분석, 구조 해석" },
          { "field": "경제학", "description": "투입산출 분석" }
        ]
      },
      "en": {
        "definition": "Systems of equations can be expressed and solved in matrix form Ax = b.",
        "formulas": [
          { "latex": "Ax = b", "description": "Matrix form of system" },
          { "latex": "x = A^{-1}b", "description": "Solution using inverse (det(A) ≠ 0)" }
        ],
        "examples": [
          {
            "problem": "Solve x + 2y = 5, 3x + 4y = 11 using matrices.",
            "solution": "A = [[1, 2], [3, 4]], b = [5, 11]\ndet(A) = -2\nA⁻¹ = [[-2, 1], [1.5, -0.5]]\nx = A⁻¹b = [1, 2]",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Engineering", "description": "Circuit analysis, structural analysis" },
          { "field": "Economics", "description": "Input-output analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["inverse-matrix", "system-of-equations"],
      "nextTopics": ["row-reduction"],
      "related": ["gaussian-elimination"],
      "applications": ["applied-engineering"]
    },
    "tags": ["linear-algebra", "system", "applications"]
  },
  {
    "id": "eigenvalues-eigenvectors",
    "name": { "ko": "고유값과 고유벡터", "en": "Eigenvalues and Eigenvectors" },
    "field": "linear-algebra",
    "subfield": "advanced",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "행렬 A에 대해 Av = λv를 만족하는 스칼라 λ를 고유값, 벡터 v를 고유벡터라 한다.",
        "formulas": [
          { "latex": "Av = \\lambda v", "description": "고유값 방정식" },
          { "latex": "\\det(A - \\lambda I) = 0", "description": "특성방정식" }
        ],
        "examples": [
          {
            "problem": "A = [[2, 1], [1, 2]]의 고유값을 구하시오.",
            "solution": "det(A - λI) = (2-λ)² - 1 = 0\nλ² - 4λ + 3 = 0\n(λ-1)(λ-3) = 0\nλ = 1 또는 λ = 3",
            "difficulty": 4
          }
        ],
        "history": {
          "background": "오일러와 라그랑주의 연구에서 시작되어 힐버트가 이론을 완성했다."
        },
        "applications": [
          { "field": "물리학", "description": "양자역학, 진동 모드" },
          { "field": "데이터 과학", "description": "PCA (주성분 분석)" },
          { "field": "페이지랭크", "description": "Google 검색 알고리즘" }
        ]
      },
      "en": {
        "definition": "For matrix A, λ is an eigenvalue and v is an eigenvector if Av = λv.",
        "formulas": [
          { "latex": "Av = \\lambda v", "description": "Eigenvalue equation" },
          { "latex": "\\det(A - \\lambda I) = 0", "description": "Characteristic equation" }
        ],
        "examples": [
          {
            "problem": "Find the eigenvalues of A = [[2, 1], [1, 2]].",
            "solution": "det(A - λI) = (2-λ)² - 1 = 0\nλ² - 4λ + 3 = 0\n(λ-1)(λ-3) = 0\nλ = 1 or λ = 3",
            "difficulty": 4
          }
        ],
        "history": {
          "background": "Developed from work by Euler and Lagrange, formalized by Hilbert."
        },
        "applications": [
          { "field": "Physics", "description": "Quantum mechanics, vibration modes" },
          { "field": "Data Science", "description": "PCA (Principal Component Analysis)" },
          { "field": "PageRank", "description": "Google search algorithm" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["determinant", "matrices-basics"],
      "nextTopics": ["diagonalization", "spectral-theorem"],
      "related": ["characteristic-polynomial"],
      "applications": ["applied-cs", "applied-physics"]
    },
    "tags": ["linear-algebra", "eigenvalue", "eigenvector", "advanced"]
  },
  {
    "id": "linear-transformation",
    "name": { "ko": "선형 변환", "en": "Linear Transformation" },
    "field": "linear-algebra",
    "subfield": "advanced",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "벡터 공간 사이의 함수로, 덧셈과 스칼라 곱을 보존하는 변환이다.",
        "formulas": [
          {
            "latex": "T(\\vec{u} + \\vec{v}) = T(\\vec{u}) + T(\\vec{v})",
            "description": "덧셈 보존"
          },
          { "latex": "T(c\\vec{v}) = cT(\\vec{v})", "description": "스칼라 곱 보존" }
        ],
        "examples": [
          {
            "problem": "회전 변환 행렬을 구하시오 (반시계 방향 θ).",
            "solution": "R(θ) = [[cos θ, -sin θ], [sin θ, cos θ]]",
            "difficulty": 3
          },
          {
            "problem": "스케일링 변환 (x방향 2배, y방향 3배)을 행렬로 표현하시오.",
            "solution": "S = [[2, 0], [0, 3]]",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "컴퓨터 그래픽", "description": "회전, 확대/축소, 이동" },
          { "field": "로봇공학", "description": "좌표계 변환" }
        ]
      },
      "en": {
        "definition": "A function between vector spaces that preserves addition and scalar multiplication.",
        "formulas": [
          {
            "latex": "T(\\vec{u} + \\vec{v}) = T(\\vec{u}) + T(\\vec{v})",
            "description": "Preserves addition"
          },
          {
            "latex": "T(c\\vec{v}) = cT(\\vec{v})",
            "description": "Preserves scalar multiplication"
          }
        ],
        "examples": [
          {
            "problem": "Find the rotation matrix (counterclockwise by θ).",
            "solution": "R(θ) = [[cos θ, -sin θ], [sin θ, cos θ]]",
            "difficulty": 3
          },
          {
            "problem": "Express scaling (2x in x, 3x in y) as a matrix.",
            "solution": "S = [[2, 0], [0, 3]]",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Computer Graphics", "description": "Rotation, scaling, translation" },
          { "field": "Robotics", "description": "Coordinate frame transformations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["matrices-basics", "vectors-basics"],
      "nextTopics": ["kernel-image"],
      "related": ["isomorphism"],
      "applications": ["applied-cs"]
    },
    "tags": ["linear-algebra", "transformation", "advanced"]
  },
  {
    "id": "vector-space",
    "name": { "ko": "벡터 공간", "en": "Vector Space" },
    "field": "linear-algebra",
    "subfield": "advanced",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "벡터 덧셈과 스칼라 곱이 정의되고 특정 공리를 만족하는 집합이다.",
        "formulas": [
          { "latex": "\\vec{u} + \\vec{v} \\in V", "description": "덧셈에 대해 닫혀 있음" },
          { "latex": "c\\vec{v} \\in V", "description": "스칼라 곱에 대해 닫혀 있음" }
        ],
        "examples": [
          {
            "problem": "ℝⁿ이 벡터 공간인지 확인하시오.",
            "solution": "덧셈과 스칼라 곱에 대해 닫혀 있고, 8가지 공리를 만족하므로 벡터 공간이다.",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "함수해석", "description": "함수 공간" },
          { "field": "양자역학", "description": "힐버트 공간" }
        ]
      },
      "en": {
        "definition": "A set with vector addition and scalar multiplication satisfying specific axioms.",
        "formulas": [
          { "latex": "\\vec{u} + \\vec{v} \\in V", "description": "Closed under addition" },
          { "latex": "c\\vec{v} \\in V", "description": "Closed under scalar multiplication" }
        ],
        "examples": [
          {
            "problem": "Verify that ℝⁿ is a vector space.",
            "solution": "It's closed under addition and scalar multiplication, and satisfies all 8 axioms, so it's a vector space.",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Functional Analysis", "description": "Function spaces" },
          { "field": "Quantum Mechanics", "description": "Hilbert spaces" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["vectors-basics"],
      "nextTopics": ["basis", "dimension"],
      "related": ["subspace"],
      "applications": ["applied-physics"]
    },
    "tags": ["linear-algebra", "vector-space", "abstract", "advanced"]
  },
  {
    "id": "basis-dimension",
    "name": { "ko": "기저와 차원", "en": "Basis and Dimension" },
    "field": "linear-algebra",
    "subfield": "advanced",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "기저는 벡터 공간을 생성하는 선형 독립인 벡터의 집합이고, 차원은 기저의 개수이다.",
        "formulas": [
          { "latex": "\\dim(V) = |\\text{basis}|", "description": "차원 = 기저 벡터의 개수" },
          { "latex": "\\dim(\\mathbb{R}^n) = n", "description": "ℝⁿ의 차원" }
        ],
        "examples": [
          {
            "problem": "ℝ²의 표준 기저를 구하시오.",
            "solution": "e₁ = (1, 0), e₂ = (0, 1)\n표준 기저: {e₁, e₂}",
            "difficulty": 2
          },
          {
            "problem": "(1, 2)와 (2, 4)가 ℝ²의 기저인지 확인하시오.",
            "solution": "(2, 4) = 2(1, 2)이므로 선형 종속\n따라서 기저가 아니다.",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "데이터 과학", "description": "특성 공간의 차원" },
          { "field": "물리학", "description": "자유도" }
        ]
      },
      "en": {
        "definition": "A basis is a set of linearly independent vectors that span the space. Dimension is the number of basis vectors.",
        "formulas": [
          {
            "latex": "\\dim(V) = |\\text{basis}|",
            "description": "Dimension = number of basis vectors"
          },
          { "latex": "\\dim(\\mathbb{R}^n) = n", "description": "Dimension of ℝⁿ" }
        ],
        "examples": [
          {
            "problem": "Find the standard basis of ℝ².",
            "solution": "e₁ = (1, 0), e₂ = (0, 1)\nStandard basis: {e₁, e₂}",
            "difficulty": 2
          },
          {
            "problem": "Check if (1, 2) and (2, 4) form a basis for ℝ².",
            "solution": "(2, 4) = 2(1, 2), so linearly dependent\nNot a basis.",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Data Science", "description": "Feature space dimensions" },
          { "field": "Physics", "description": "Degrees of freedom" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["vector-space"],
      "nextTopics": ["rank"],
      "related": ["linear-independence"],
      "applications": ["applied-cs", "applied-physics"]
    },
    "tags": ["linear-algebra", "basis", "dimension", "advanced"]
  },
  {
    "id": "probability-basics",
    "name": { "ko": "확률의 기초", "en": "Probability Basics" },
    "field": "probability",
    "subfield": "probability-theory",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "확률은 사건이 일어날 가능성을 0과 1 사이의 수로 나타낸 것입니다. 0은 불가능, 1은 확실함을 의미합니다.",
        "formulas": [
          {
            "latex": "P(A) = \\frac{\\text{A가 일어나는 경우의 수}}{\\text{전체 경우의 수}}",
            "description": "고전적 확률의 정의"
          },
          { "latex": "0 \\leq P(A) \\leq 1", "description": "확률의 범위" },
          { "latex": "P(A^c) = 1 - P(A)", "description": "여사건의 확률" }
        ],
        "examples": [
          {
            "problem": "주사위를 던져 3 이하가 나올 확률을 구하세요.",
            "solution": "3 이하: {1, 2, 3}, 전체: {1, 2, 3, 4, 5, 6}, P = 3/6 = 1/2"
          },
          {
            "problem": "동전을 두 번 던져 적어도 한 번 앞면이 나올 확률을 구하세요.",
            "solution": "여사건(둘 다 뒷면) = 1/4, 따라서 P = 1 - 1/4 = 3/4"
          }
        ],
        "history": {
          "discoveredBy": "파스칼과 페르마",
          "year": "1654년",
          "background": "도박 문제에서 시작된 서신 교환으로 확률론의 기초가 세워졌습니다."
        },
        "applications": [
          { "field": "보험", "description": "리스크 평가" },
          { "field": "기상학", "description": "날씨 예측" },
          { "field": "의학", "description": "진단 테스트 정확도" }
        ]
      },
      "en": {
        "definition": "Probability is a number between 0 and 1 representing the likelihood of an event occurring. 0 means impossible, 1 means certain.",
        "formulas": [
          {
            "latex": "P(A) = \\frac{\\text{favorable outcomes}}{\\text{total outcomes}}",
            "description": "Classical probability definition"
          },
          { "latex": "0 \\leq P(A) \\leq 1", "description": "Probability range" },
          { "latex": "P(A^c) = 1 - P(A)", "description": "Complement probability" }
        ],
        "examples": [
          {
            "problem": "Find the probability of rolling 3 or less on a die.",
            "solution": "3 or less: {1, 2, 3}, Total: {1, 2, 3, 4, 5, 6}, P = 3/6 = 1/2"
          },
          {
            "problem": "Find P(at least one head) when flipping a coin twice.",
            "solution": "Complement (both tails) = 1/4, so P = 1 - 1/4 = 3/4"
          }
        ],
        "history": {
          "discoveredBy": "Pascal and Fermat",
          "year": "1654",
          "background": "Correspondence about gambling problems led to the foundations of probability theory."
        },
        "applications": [
          { "field": "Insurance", "description": "Risk assessment" },
          { "field": "Meteorology", "description": "Weather forecasting" },
          { "field": "Medicine", "description": "Diagnostic test accuracy" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["fractions", "ratios"],
      "nextTopics": ["conditional-probability", "expected-value"],
      "related": ["combinatorics"]
    },
    "tags": ["확률", "기초", "probability", "basics"]
  },
  {
    "id": "conditional-probability",
    "name": { "ko": "조건부 확률", "en": "Conditional Probability" },
    "field": "probability",
    "subfield": "probability-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "조건부 확률 P(A|B)는 사건 B가 일어났을 때 사건 A가 일어날 확률입니다.",
        "formulas": [
          { "latex": "P(A|B) = \\frac{P(A \\cap B)}{P(B)}", "description": "조건부 확률의 정의" },
          { "latex": "P(A \\cap B) = P(A|B) \\cdot P(B)", "description": "곱셈 법칙" },
          { "latex": "P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}", "description": "베이즈 정리" }
        ],
        "examples": [
          {
            "problem": "52장의 카드에서 하트가 나왔을 때 그것이 킹일 확률을 구하세요.",
            "solution": "P(킹|하트) = P(하트 킹) / P(하트) = (1/52) / (13/52) = 1/13"
          }
        ],
        "applications": [
          { "field": "의학", "description": "질병 진단, 검사 결과 해석" },
          { "field": "스팸 필터", "description": "베이지안 스팸 분류" },
          { "field": "기계학습", "description": "나이브 베이즈 분류기" }
        ]
      },
      "en": {
        "definition": "Conditional probability P(A|B) is the probability of event A occurring given that event B has occurred.",
        "formulas": [
          {
            "latex": "P(A|B) = \\frac{P(A \\cap B)}{P(B)}",
            "description": "Definition of conditional probability"
          },
          { "latex": "P(A \\cap B) = P(A|B) \\cdot P(B)", "description": "Multiplication rule" },
          { "latex": "P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}", "description": "Bayes' theorem" }
        ],
        "examples": [
          {
            "problem": "From 52 cards, given that a heart was drawn, find P(it's a King).",
            "solution": "P(King|Heart) = P(King of Hearts) / P(Heart) = (1/52) / (13/52) = 1/13"
          }
        ],
        "applications": [
          { "field": "Medicine", "description": "Disease diagnosis, test interpretation" },
          { "field": "Spam Filtering", "description": "Bayesian spam classification" },
          { "field": "Machine Learning", "description": "Naive Bayes classifier" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["probability-basics"],
      "nextTopics": ["bayes-theorem", "independence"],
      "related": ["total-probability"]
    },
    "tags": ["조건부확률", "베이즈", "conditional", "probability"]
  },
  {
    "id": "expected-value",
    "name": { "ko": "기댓값", "en": "Expected Value" },
    "field": "probability",
    "subfield": "probability-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "기댓값(평균)은 확률변수의 가능한 값들을 각 확률로 가중 평균한 것입니다. 장기적인 평균을 나타냅니다.",
        "formulas": [
          {
            "latex": "E[X] = \\sum_{i} x_i \\cdot P(X = x_i)",
            "description": "이산 확률변수의 기댓값"
          },
          {
            "latex": "E[X] = \\int_{-\\infty}^{\\infty} x \\cdot f(x) \\, dx",
            "description": "연속 확률변수의 기댓값"
          },
          { "latex": "E[aX + b] = aE[X] + b", "description": "기댓값의 선형성" }
        ],
        "examples": [
          {
            "problem": "주사위를 던졌을 때 나오는 수의 기댓값을 구하세요.",
            "solution": "E[X] = (1+2+3+4+5+6)/6 = 21/6 = 3.5"
          },
          {
            "problem": "복권이 1/1000 확률로 1000원, 999/1000 확률로 0원일 때 기댓값은?",
            "solution": "E[X] = 1000 × (1/1000) + 0 × (999/1000) = 1원"
          }
        ],
        "applications": [
          { "field": "보험", "description": "보험료 산정" },
          { "field": "투자", "description": "예상 수익률 계산" },
          { "field": "게임 이론", "description": "전략 평가" }
        ]
      },
      "en": {
        "definition": "Expected value (mean) is the probability-weighted average of all possible values. It represents the long-run average.",
        "formulas": [
          {
            "latex": "E[X] = \\sum_{i} x_i \\cdot P(X = x_i)",
            "description": "Expected value (discrete)"
          },
          {
            "latex": "E[X] = \\int_{-\\infty}^{\\infty} x \\cdot f(x) \\, dx",
            "description": "Expected value (continuous)"
          },
          { "latex": "E[aX + b] = aE[X] + b", "description": "Linearity of expectation" }
        ],
        "examples": [
          {
            "problem": "Find the expected value when rolling a die.",
            "solution": "E[X] = (1+2+3+4+5+6)/6 = 21/6 = 3.5"
          },
          {
            "problem": "A lottery wins $1000 with P=1/1000, else $0. Find E[X].",
            "solution": "E[X] = 1000 × (1/1000) + 0 × (999/1000) = $1"
          }
        ],
        "applications": [
          { "field": "Insurance", "description": "Premium calculation" },
          { "field": "Investment", "description": "Expected return calculation" },
          { "field": "Game Theory", "description": "Strategy evaluation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["probability-basics"],
      "nextTopics": ["variance", "law-of-large-numbers"],
      "related": ["weighted-average"]
    },
    "tags": ["기댓값", "평균", "expected value", "mean"]
  },
  {
    "id": "variance",
    "name": { "ko": "분산과 표준편차", "en": "Variance and Standard Deviation" },
    "field": "probability",
    "subfield": "statistics",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "분산은 데이터가 평균으로부터 얼마나 퍼져 있는지를 측정합니다. 표준편차는 분산의 제곱근입니다.",
        "formulas": [
          {
            "latex": "\\text{Var}(X) = E[(X - \\mu)^2] = E[X^2] - (E[X])^2",
            "description": "분산의 정의"
          },
          { "latex": "\\sigma = \\sqrt{\\text{Var}(X)}", "description": "표준편차" },
          { "latex": "\\text{Var}(aX + b) = a^2 \\text{Var}(X)", "description": "분산의 성질" }
        ],
        "examples": [
          {
            "problem": "데이터 {1, 2, 3, 4, 5}의 분산을 구하세요.",
            "solution": "평균 μ = 3, Var = [(1-3)² + (2-3)² + (3-3)² + (4-3)² + (5-3)²]/5 = 10/5 = 2"
          }
        ],
        "applications": [
          { "field": "금융", "description": "투자 리스크 측정" },
          { "field": "품질 관리", "description": "제품 일관성 평가" },
          { "field": "실험 과학", "description": "측정 오차 분석" }
        ]
      },
      "en": {
        "definition": "Variance measures how spread out data is from the mean. Standard deviation is the square root of variance.",
        "formulas": [
          {
            "latex": "\\text{Var}(X) = E[(X - \\mu)^2] = E[X^2] - (E[X])^2",
            "description": "Variance definition"
          },
          { "latex": "\\sigma = \\sqrt{\\text{Var}(X)}", "description": "Standard deviation" },
          {
            "latex": "\\text{Var}(aX + b) = a^2 \\text{Var}(X)",
            "description": "Variance property"
          }
        ],
        "examples": [
          {
            "problem": "Find the variance of {1, 2, 3, 4, 5}.",
            "solution": "Mean μ = 3, Var = [(1-3)² + (2-3)² + (3-3)² + (4-3)² + (5-3)²]/5 = 10/5 = 2"
          }
        ],
        "applications": [
          { "field": "Finance", "description": "Investment risk measurement" },
          { "field": "Quality Control", "description": "Product consistency" },
          { "field": "Experimental Science", "description": "Measurement error analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["expected-value"],
      "nextTopics": ["normal-distribution", "central-limit-theorem"],
      "related": ["standard-score"]
    },
    "tags": ["분산", "표준편차", "variance", "standard deviation"]
  },
  {
    "id": "normal-distribution",
    "name": { "ko": "정규분포", "en": "Normal Distribution" },
    "field": "probability",
    "subfield": "distributions",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "정규분포(가우스 분포)는 평균을 중심으로 좌우 대칭인 종 모양의 연속 확률분포입니다. 자연현상과 사회현상에서 널리 나타납니다.",
        "formulas": [
          {
            "latex": "f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}",
            "description": "정규분포의 확률밀도함수"
          },
          { "latex": "Z = \\frac{X - \\mu}{\\sigma}", "description": "표준화 (Z-점수)" }
        ],
        "examples": [
          {
            "problem": "평균 170cm, 표준편차 10cm인 키 분포에서 180cm 이상일 확률은?",
            "solution": "Z = (180-170)/10 = 1, P(Z > 1) ≈ 0.1587 (약 15.87%)"
          }
        ],
        "history": {
          "discoveredBy": "카를 프리드리히 가우스",
          "year": "1809년",
          "background": "가우스가 천문학적 측정 오차를 분석하면서 정규분포를 발견했습니다."
        },
        "applications": [
          { "field": "품질 관리", "description": "6 시그마" },
          { "field": "금융", "description": "주가 변동 모델링" },
          { "field": "자연과학", "description": "측정 오차 분석" }
        ]
      },
      "en": {
        "definition": "The normal (Gaussian) distribution is a continuous probability distribution with a bell-shaped curve symmetric around the mean. It appears widely in nature and society.",
        "formulas": [
          {
            "latex": "f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}",
            "description": "Normal distribution PDF"
          },
          { "latex": "Z = \\frac{X - \\mu}{\\sigma}", "description": "Standardization (Z-score)" }
        ],
        "examples": [
          {
            "problem": "Heights have mean 170cm, SD 10cm. Find P(height > 180cm).",
            "solution": "Z = (180-170)/10 = 1, P(Z > 1) ≈ 0.1587 (about 15.87%)"
          }
        ],
        "history": {
          "discoveredBy": "Carl Friedrich Gauss",
          "year": "1809",
          "background": "Gauss discovered the normal distribution while analyzing astronomical measurement errors."
        },
        "applications": [
          { "field": "Quality Control", "description": "Six Sigma" },
          { "field": "Finance", "description": "Stock price modeling" },
          { "field": "Natural Sciences", "description": "Measurement error analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["variance", "expected-value"],
      "nextTopics": ["central-limit-theorem", "hypothesis-testing"],
      "related": ["binomial-distribution"]
    },
    "tags": ["정규분포", "가우스", "normal distribution", "Gaussian"]
  },
  {
    "id": "binomial-distribution",
    "name": { "ko": "이항분포", "en": "Binomial Distribution" },
    "field": "probability",
    "subfield": "distributions",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "이항분포는 성공 확률이 p인 독립 시행을 n번 반복할 때 성공 횟수의 분포입니다.",
        "formulas": [
          {
            "latex": "P(X = k) = \\binom{n}{k} p^k (1-p)^{n-k}",
            "description": "이항분포 확률질량함수"
          },
          { "latex": "E[X] = np", "description": "이항분포의 기댓값" },
          { "latex": "\\text{Var}(X) = np(1-p)", "description": "이항분포의 분산" }
        ],
        "examples": [
          {
            "problem": "동전을 10번 던져 정확히 6번 앞면이 나올 확률은?",
            "solution": "P(X=6) = C(10,6) × (1/2)⁶ × (1/2)⁴ = 210 × (1/1024) ≈ 0.205"
          }
        ],
        "applications": [
          { "field": "품질 검사", "description": "불량률 분석" },
          { "field": "의학", "description": "약물 효과 분석" },
          { "field": "선거", "description": "여론조사 분석" }
        ]
      },
      "en": {
        "definition": "The binomial distribution models the number of successes in n independent trials, each with success probability p.",
        "formulas": [
          { "latex": "P(X = k) = \\binom{n}{k} p^k (1-p)^{n-k}", "description": "Binomial PMF" },
          { "latex": "E[X] = np", "description": "Expected value of binomial" },
          { "latex": "\\text{Var}(X) = np(1-p)", "description": "Variance of binomial" }
        ],
        "examples": [
          {
            "problem": "Find P(exactly 6 heads) when flipping a coin 10 times.",
            "solution": "P(X=6) = C(10,6) × (1/2)⁶ × (1/2)⁴ = 210 × (1/1024) ≈ 0.205"
          }
        ],
        "applications": [
          { "field": "Quality Control", "description": "Defect rate analysis" },
          { "field": "Medicine", "description": "Drug efficacy analysis" },
          { "field": "Elections", "description": "Poll analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["probability-basics", "combinations"],
      "nextTopics": ["poisson-distribution", "normal-distribution"],
      "related": ["bernoulli-trial"]
    },
    "tags": ["이항분포", "확률분포", "binomial", "distribution"]
  },
  {
    "id": "central-limit-theorem",
    "name": { "ko": "중심극한정리", "en": "Central Limit Theorem" },
    "field": "probability",
    "subfield": "statistics",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "중심극한정리는 표본 크기가 충분히 크면, 표본 평균의 분포가 원래 분포와 관계없이 정규분포에 가까워진다는 정리입니다.",
        "formulas": [
          {
            "latex": "\\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma^2}{n}\\right)",
            "description": "표본 평균의 분포 (n이 클 때)"
          },
          {
            "latex": "\\frac{\\bar{X} - \\mu}{\\sigma / \\sqrt{n}} \\to N(0, 1)",
            "description": "표준화된 표본 평균"
          }
        ],
        "examples": [
          {
            "problem": "주사위를 100번 던졌을 때 평균이 3.3 이상 3.7 이하일 확률은?",
            "solution": "μ=3.5, σ²=35/12, 표본평균의 σ = √(35/12)/10 ≈ 0.171. Z 변환 후 정규분포표 사용."
          }
        ],
        "history": {
          "discoveredBy": "피에르시몽 라플라스",
          "year": "1810년",
          "background": "라플라스가 이항분포의 정규 근사를 연구하면서 발견했습니다."
        },
        "applications": [
          { "field": "통계적 추론", "description": "신뢰구간, 가설검정" },
          { "field": "품질 관리", "description": "표본 검사" },
          { "field": "여론조사", "description": "선거 예측" }
        ]
      },
      "en": {
        "definition": "The Central Limit Theorem states that with sufficient sample size, the distribution of sample means approaches a normal distribution regardless of the original distribution.",
        "formulas": [
          {
            "latex": "\\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma^2}{n}\\right)",
            "description": "Distribution of sample mean (large n)"
          },
          {
            "latex": "\\frac{\\bar{X} - \\mu}{\\sigma / \\sqrt{n}} \\to N(0, 1)",
            "description": "Standardized sample mean"
          }
        ],
        "examples": [
          {
            "problem": "When rolling a die 100 times, find P(3.3 ≤ mean ≤ 3.7).",
            "solution": "μ=3.5, σ²=35/12, SE = √(35/12)/10 ≈ 0.171. Use Z-transform and normal table."
          }
        ],
        "history": {
          "discoveredBy": "Pierre-Simon Laplace",
          "year": "1810",
          "background": "Laplace discovered it while studying normal approximation to binomial distribution."
        },
        "applications": [
          {
            "field": "Statistical Inference",
            "description": "Confidence intervals, hypothesis testing"
          },
          { "field": "Quality Control", "description": "Sampling inspection" },
          { "field": "Polling", "description": "Election prediction" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["normal-distribution", "expected-value", "variance"],
      "nextTopics": ["hypothesis-testing", "confidence-interval"],
      "related": ["law-of-large-numbers"]
    },
    "tags": ["중심극한정리", "정규분포", "central limit theorem", "CLT"]
  },
  {
    "id": "poisson-distribution",
    "name": { "ko": "포아송 분포", "en": "Poisson Distribution" },
    "field": "probability",
    "subfield": "distributions",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "일정 시간이나 공간에서 드물게 발생하는 사건의 횟수를 모델링하는 분포입니다.",
        "formulas": [
          {
            "latex": "P(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}",
            "description": "포아송 분포의 확률질량함수"
          },
          {
            "latex": "E[X] = \\lambda, \\quad \\text{Var}(X) = \\lambda",
            "description": "기댓값과 분산 (둘 다 λ)"
          }
        ],
        "examples": [
          {
            "problem": "시간당 평균 3통의 전화가 오는 콜센터에서 정확히 5통이 올 확률은?",
            "solution": "P(X=5) = (3⁵ × e⁻³) / 5! = 243 × 0.0498 / 120 ≈ 0.1008",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "보험", "description": "사고 발생 빈도" },
          { "field": "통신", "description": "네트워크 트래픽" },
          { "field": "생물학", "description": "돌연변이 발생" }
        ]
      },
      "en": {
        "definition": "A distribution modeling the number of rare events occurring in a fixed interval of time or space.",
        "formulas": [
          {
            "latex": "P(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}",
            "description": "Poisson PMF"
          },
          {
            "latex": "E[X] = \\lambda, \\quad \\text{Var}(X) = \\lambda",
            "description": "Expected value and variance (both λ)"
          }
        ],
        "examples": [
          {
            "problem": "A call center averages 3 calls/hour. Find P(exactly 5 calls).",
            "solution": "P(X=5) = (3⁵ × e⁻³) / 5! = 243 × 0.0498 / 120 ≈ 0.1008",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Insurance", "description": "Accident frequency" },
          { "field": "Telecom", "description": "Network traffic" },
          { "field": "Biology", "description": "Mutation occurrence" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["probability-basics", "exponential-function"],
      "nextTopics": ["exponential-distribution"],
      "related": ["binomial-distribution"]
    },
    "tags": ["포아송", "분포", "Poisson", "distribution"]
  },
  {
    "id": "independence",
    "name": { "ko": "독립 사건", "en": "Independent Events" },
    "field": "probability",
    "subfield": "probability-theory",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "두 사건이 독립이면 한 사건의 발생이 다른 사건의 확률에 영향을 주지 않습니다.",
        "formulas": [
          { "latex": "P(A \\cap B) = P(A) \\cdot P(B)", "description": "독립의 정의" },
          { "latex": "P(A|B) = P(A)", "description": "조건부 확률이 원래 확률과 같음" }
        ],
        "examples": [
          {
            "problem": "동전을 두 번 던질 때, 두 결과가 독립인지 확인하세요.",
            "solution": "P(첫째 앞면) = 1/2, P(둘째 앞면) = 1/2\nP(둘 다 앞면) = 1/4 = (1/2)(1/2) ✓ 독립",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "통계학", "description": "독립 표본 가정" },
          { "field": "신뢰성 공학", "description": "시스템 고장 확률" }
        ]
      },
      "en": {
        "definition": "Two events are independent if the occurrence of one doesn't affect the probability of the other.",
        "formulas": [
          {
            "latex": "P(A \\cap B) = P(A) \\cdot P(B)",
            "description": "Definition of independence"
          },
          {
            "latex": "P(A|B) = P(A)",
            "description": "Conditional equals unconditional probability"
          }
        ],
        "examples": [
          {
            "problem": "Are two coin flips independent?",
            "solution": "P(1st heads) = 1/2, P(2nd heads) = 1/2\nP(both heads) = 1/4 = (1/2)(1/2) ✓ Independent",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Statistics", "description": "Independent sample assumption" },
          { "field": "Reliability Engineering", "description": "System failure probability" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["probability-basics"],
      "nextTopics": ["conditional-probability"],
      "related": ["mutually-exclusive"]
    },
    "tags": ["독립", "사건", "independent", "events"]
  },
  {
    "id": "bayes-theorem",
    "name": { "ko": "베이즈 정리", "en": "Bayes' Theorem" },
    "field": "probability",
    "subfield": "probability-theory",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "사전 확률을 새로운 증거로 업데이트하여 사후 확률을 계산하는 정리입니다.",
        "formulas": [
          { "latex": "P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}", "description": "베이즈 정리" },
          { "latex": "P(B) = \\sum_i P(B|A_i) P(A_i)", "description": "전체 확률 법칙" }
        ],
        "examples": [
          {
            "problem": "검사 정확도 99%, 유병률 1%. 양성일 때 실제 질병일 확률은?",
            "solution": "P(질병|양성) = (0.99 × 0.01) / (0.99×0.01 + 0.01×0.99)\n= 0.0099 / 0.0198 = 50%",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "토마스 베이즈",
          "year": "1763년",
          "background": "베이즈 사후에 출판된 논문에서 발표되었습니다."
        },
        "applications": [
          { "field": "의학", "description": "진단 테스트 해석" },
          { "field": "머신러닝", "description": "나이브 베이즈, 베이지안 추론" },
          { "field": "스팸 필터", "description": "이메일 분류" }
        ]
      },
      "en": {
        "definition": "A theorem for updating prior probability with new evidence to compute posterior probability.",
        "formulas": [
          { "latex": "P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}", "description": "Bayes' theorem" },
          { "latex": "P(B) = \\sum_i P(B|A_i) P(A_i)", "description": "Law of total probability" }
        ],
        "examples": [
          {
            "problem": "Test accuracy 99%, disease prevalence 1%. If positive, what's P(disease)?",
            "solution": "P(disease|positive) = (0.99 × 0.01) / (0.99×0.01 + 0.01×0.99)\n= 0.0099 / 0.0198 = 50%",
            "difficulty": 4
          }
        ],
        "history": {
          "discoveredBy": "Thomas Bayes",
          "year": "1763",
          "background": "Published posthumously."
        },
        "applications": [
          { "field": "Medicine", "description": "Diagnostic test interpretation" },
          { "field": "Machine Learning", "description": "Naive Bayes, Bayesian inference" },
          { "field": "Spam Filtering", "description": "Email classification" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["conditional-probability"],
      "nextTopics": ["bayesian-inference"],
      "related": ["total-probability"]
    },
    "tags": ["베이즈", "정리", "Bayes", "theorem"]
  },
  {
    "id": "hypothesis-testing",
    "name": { "ko": "가설검정", "en": "Hypothesis Testing" },
    "field": "probability",
    "subfield": "statistics",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "표본 데이터를 사용하여 모집단에 대한 가설을 검증하는 통계적 방법입니다.",
        "formulas": [
          {
            "latex": "H_0: \\mu = \\mu_0, \\quad H_1: \\mu \\neq \\mu_0",
            "description": "귀무가설과 대립가설"
          },
          {
            "latex": "Z = \\frac{\\bar{X} - \\mu_0}{\\sigma / \\sqrt{n}}",
            "description": "Z 검정통계량"
          },
          { "latex": "t = \\frac{\\bar{X} - \\mu_0}{s / \\sqrt{n}}", "description": "t 검정통계량" }
        ],
        "examples": [
          {
            "problem": "평균이 50이라는 주장에 대해, 표본평균 52, 표준편차 10, n=25로 검정하시오 (α=0.05).",
            "solution": "Z = (52-50)/(10/5) = 1\n임계값 ±1.96. |Z| < 1.96이므로 귀무가설 채택",
            "difficulty": 4
          }
        ],
        "applications": [
          { "field": "의약품", "description": "임상시험 유효성 검증" },
          { "field": "품질관리", "description": "공정 이상 감지" },
          { "field": "사회과학", "description": "연구 결과 검증" }
        ]
      },
      "en": {
        "definition": "A statistical method to test claims about a population using sample data.",
        "formulas": [
          {
            "latex": "H_0: \\mu = \\mu_0, \\quad H_1: \\mu \\neq \\mu_0",
            "description": "Null and alternative hypotheses"
          },
          {
            "latex": "Z = \\frac{\\bar{X} - \\mu_0}{\\sigma / \\sqrt{n}}",
            "description": "Z test statistic"
          },
          {
            "latex": "t = \\frac{\\bar{X} - \\mu_0}{s / \\sqrt{n}}",
            "description": "t test statistic"
          }
        ],
        "examples": [
          {
            "problem": "Test μ=50 with sample mean 52, SD 10, n=25 (α=0.05).",
            "solution": "Z = (52-50)/(10/5) = 1\nCritical ±1.96. |Z| < 1.96, fail to reject H₀",
            "difficulty": 4
          }
        ],
        "applications": [
          { "field": "Pharmaceuticals", "description": "Clinical trial efficacy" },
          { "field": "Quality Control", "description": "Process anomaly detection" },
          { "field": "Social Science", "description": "Research validation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["normal-distribution", "central-limit-theorem"],
      "nextTopics": ["confidence-interval", "p-value"],
      "related": ["type-i-ii-errors"]
    },
    "tags": ["가설검정", "통계", "hypothesis", "testing"]
  },
  {
    "id": "correlation",
    "name": { "ko": "상관관계", "en": "Correlation" },
    "field": "probability",
    "subfield": "statistics",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "두 변수 사이의 선형 관계의 강도와 방향을 측정합니다. -1에서 1 사이의 값을 가집니다.",
        "formulas": [
          {
            "latex": "r = \\frac{\\sum (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum(x_i - \\bar{x})^2 \\sum(y_i - \\bar{y})^2}}",
            "description": "피어슨 상관계수"
          },
          { "latex": "-1 \\leq r \\leq 1", "description": "상관계수의 범위" }
        ],
        "examples": [
          {
            "problem": "r = 0.8의 의미를 설명하시오.",
            "solution": "강한 양의 상관관계. x가 증가하면 y도 증가하는 경향이 강함.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "금융", "description": "자산 간 상관관계" },
          { "field": "사회과학", "description": "변수 간 관계 분석" },
          { "field": "의학", "description": "위험 요인 분석" }
        ]
      },
      "en": {
        "definition": "Measures the strength and direction of a linear relationship between two variables. Ranges from -1 to 1.",
        "formulas": [
          {
            "latex": "r = \\frac{\\sum (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum(x_i - \\bar{x})^2 \\sum(y_i - \\bar{y})^2}}",
            "description": "Pearson correlation coefficient"
          },
          { "latex": "-1 \\leq r \\leq 1", "description": "Correlation coefficient range" }
        ],
        "examples": [
          {
            "problem": "Interpret r = 0.8.",
            "solution": "Strong positive correlation. As x increases, y tends to increase strongly.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Finance", "description": "Asset correlations" },
          { "field": "Social Science", "description": "Variable relationship analysis" },
          { "field": "Medicine", "description": "Risk factor analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["variance", "expected-value"],
      "nextTopics": ["regression"],
      "related": ["covariance"]
    },
    "tags": ["상관관계", "통계", "correlation", "statistics"]
  },
  {
    "id": "regression",
    "name": { "ko": "회귀분석", "en": "Regression Analysis" },
    "field": "probability",
    "subfield": "statistics",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "종속변수와 독립변수 사이의 관계를 모델링하고 예측하는 통계적 방법입니다.",
        "formulas": [
          {
            "latex": "y = \\beta_0 + \\beta_1 x + \\epsilon",
            "description": "단순 선형 회귀 모델"
          },
          {
            "latex": "\\hat{\\beta}_1 = \\frac{\\sum(x_i - \\bar{x})(y_i - \\bar{y})}{\\sum(x_i - \\bar{x})^2}",
            "description": "기울기 추정"
          },
          { "latex": "R^2 = 1 - \\frac{SS_{res}}{SS_{tot}}", "description": "결정계수 (설명력)" }
        ],
        "examples": [
          {
            "problem": "R² = 0.75의 의미를 설명하시오.",
            "solution": "독립변수가 종속변수 변동의 75%를 설명함.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "경제학", "description": "수요 예측" },
          { "field": "마케팅", "description": "매출 예측" },
          { "field": "기계학습", "description": "예측 모델의 기초" }
        ]
      },
      "en": {
        "definition": "A statistical method to model and predict the relationship between dependent and independent variables.",
        "formulas": [
          {
            "latex": "y = \\beta_0 + \\beta_1 x + \\epsilon",
            "description": "Simple linear regression model"
          },
          {
            "latex": "\\hat{\\beta}_1 = \\frac{\\sum(x_i - \\bar{x})(y_i - \\bar{y})}{\\sum(x_i - \\bar{x})^2}",
            "description": "Slope estimate"
          },
          {
            "latex": "R^2 = 1 - \\frac{SS_{res}}{SS_{tot}}",
            "description": "Coefficient of determination"
          }
        ],
        "examples": [
          {
            "problem": "Interpret R² = 0.75.",
            "solution": "The independent variable explains 75% of the variation in the dependent variable.",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Economics", "description": "Demand forecasting" },
          { "field": "Marketing", "description": "Sales prediction" },
          { "field": "Machine Learning", "description": "Foundation of predictive models" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["correlation"],
      "nextTopics": ["multiple-regression"],
      "related": ["least-squares"]
    },
    "tags": ["회귀", "분석", "regression", "analysis"]
  },
  {
    "id": "sets",
    "name": { "ko": "집합", "en": "Sets" },
    "field": "discrete",
    "subfield": "set-theory",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "집합은 명확하게 정의된 서로 다른 원소들의 모임입니다. 수학의 가장 기본적인 개념 중 하나입니다.",
        "formulas": [
          {
            "latex": "A \\cup B = \\{x : x \\in A \\text{ 또는 } x \\in B\\}",
            "description": "합집합"
          },
          {
            "latex": "A \\cap B = \\{x : x \\in A \\text{ 그리고 } x \\in B\\}",
            "description": "교집합"
          },
          {
            "latex": "A - B = \\{x : x \\in A \\text{ 그리고 } x \\notin B\\}",
            "description": "차집합"
          },
          { "latex": "|A \\cup B| = |A| + |B| - |A \\cap B|", "description": "포함-배제 원리" }
        ],
        "examples": [
          {
            "problem": "A = {1, 2, 3}, B = {2, 3, 4}일 때 A ∪ B와 A ∩ B를 구하세요.",
            "solution": "A ∪ B = {1, 2, 3, 4}, A ∩ B = {2, 3}"
          }
        ],
        "history": {
          "discoveredBy": "게오르크 칸토어",
          "year": "1874년",
          "background": "칸토어가 무한집합의 크기를 비교하는 방법을 연구하면서 집합론을 창시했습니다."
        },
        "applications": [
          { "field": "데이터베이스", "description": "SQL의 UNION, INTERSECT 연산" },
          { "field": "프로그래밍", "description": "Set 자료구조" },
          { "field": "논리학", "description": "명제의 진리집합" }
        ]
      },
      "en": {
        "definition": "A set is a collection of distinct, well-defined objects. It's one of the most fundamental concepts in mathematics.",
        "formulas": [
          {
            "latex": "A \\cup B = \\{x : x \\in A \\text{ or } x \\in B\\}",
            "description": "Union"
          },
          {
            "latex": "A \\cap B = \\{x : x \\in A \\text{ and } x \\in B\\}",
            "description": "Intersection"
          },
          {
            "latex": "A - B = \\{x : x \\in A \\text{ and } x \\notin B\\}",
            "description": "Difference"
          },
          {
            "latex": "|A \\cup B| = |A| + |B| - |A \\cap B|",
            "description": "Inclusion-exclusion principle"
          }
        ],
        "examples": [
          {
            "problem": "If A = {1, 2, 3} and B = {2, 3, 4}, find A ∪ B and A ∩ B.",
            "solution": "A ∪ B = {1, 2, 3, 4}, A ∩ B = {2, 3}"
          }
        ],
        "history": {
          "discoveredBy": "Georg Cantor",
          "year": "1874",
          "background": "Cantor founded set theory while studying how to compare sizes of infinite sets."
        },
        "applications": [
          { "field": "Databases", "description": "SQL UNION, INTERSECT operations" },
          { "field": "Programming", "description": "Set data structure" },
          { "field": "Logic", "description": "Truth sets of propositions" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["functions", "relations"],
      "related": ["venn-diagrams"]
    },
    "tags": ["집합", "이산수학", "set", "discrete math"]
  },
  {
    "id": "combinations",
    "name": { "ko": "조합", "en": "Combinations" },
    "field": "discrete",
    "subfield": "combinatorics",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "조합은 n개 중에서 r개를 순서 없이 선택하는 경우의 수입니다.",
        "formulas": [
          {
            "latex": "\\binom{n}{r} = C(n, r) = \\frac{n!}{r!(n-r)!}",
            "description": "조합의 공식"
          },
          { "latex": "\\binom{n}{r} = \\binom{n}{n-r}", "description": "대칭성" },
          {
            "latex": "\\binom{n}{r} = \\binom{n-1}{r-1} + \\binom{n-1}{r}",
            "description": "파스칼의 항등식"
          }
        ],
        "examples": [
          {
            "problem": "10명 중에서 3명의 대표를 뽑는 경우의 수를 구하세요.",
            "solution": "C(10,3) = 10!/(3!×7!) = (10×9×8)/(3×2×1) = 120"
          },
          {
            "problem": "52장의 카드에서 5장을 뽑는 경우의 수는?",
            "solution": "C(52,5) = 52!/(5!×47!) = 2,598,960"
          }
        ],
        "applications": [
          { "field": "확률론", "description": "이항분포 계산" },
          { "field": "통계학", "description": "표본 선택" },
          { "field": "암호학", "description": "키 조합" }
        ]
      },
      "en": {
        "definition": "A combination is the number of ways to select r items from n items without regard to order.",
        "formulas": [
          {
            "latex": "\\binom{n}{r} = C(n, r) = \\frac{n!}{r!(n-r)!}",
            "description": "Combination formula"
          },
          { "latex": "\\binom{n}{r} = \\binom{n}{n-r}", "description": "Symmetry property" },
          {
            "latex": "\\binom{n}{r} = \\binom{n-1}{r-1} + \\binom{n-1}{r}",
            "description": "Pascal's identity"
          }
        ],
        "examples": [
          {
            "problem": "Find the number of ways to choose 3 representatives from 10 people.",
            "solution": "C(10,3) = 10!/(3!×7!) = (10×9×8)/(3×2×1) = 120"
          },
          {
            "problem": "How many 5-card hands from a 52-card deck?",
            "solution": "C(52,5) = 52!/(5!×47!) = 2,598,960"
          }
        ],
        "applications": [
          { "field": "Probability", "description": "Binomial distribution" },
          { "field": "Statistics", "description": "Sample selection" },
          { "field": "Cryptography", "description": "Key combinations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["factorial"],
      "nextTopics": ["permutations", "binomial-theorem"],
      "related": ["pascal-triangle"]
    },
    "tags": ["조합", "경우의수", "combinations", "counting"]
  },
  {
    "id": "permutations",
    "name": { "ko": "순열", "en": "Permutations" },
    "field": "discrete",
    "subfield": "combinatorics",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "순열은 n개 중에서 r개를 순서를 고려하여 나열하는 경우의 수입니다.",
        "formulas": [
          { "latex": "P(n, r) = \\frac{n!}{(n-r)!}", "description": "순열의 공식" },
          {
            "latex": "n! = n \\times (n-1) \\times \\cdots \\times 2 \\times 1",
            "description": "팩토리얼"
          },
          {
            "latex": "P(n, r) = n \\times (n-1) \\times \\cdots \\times (n-r+1)",
            "description": "순열의 전개"
          }
        ],
        "examples": [
          {
            "problem": "5명이 일렬로 서는 경우의 수를 구하세요.",
            "solution": "P(5,5) = 5! = 5×4×3×2×1 = 120"
          },
          {
            "problem": "10명 중 회장, 부회장, 총무를 뽑는 경우의 수는?",
            "solution": "P(10,3) = 10×9×8 = 720"
          }
        ],
        "applications": [
          { "field": "암호학", "description": "비밀번호 경우의 수" },
          { "field": "스케줄링", "description": "작업 순서 배치" },
          { "field": "경마", "description": "순위 조합" }
        ]
      },
      "en": {
        "definition": "A permutation is the number of ways to arrange r items from n items where order matters.",
        "formulas": [
          { "latex": "P(n, r) = \\frac{n!}{(n-r)!}", "description": "Permutation formula" },
          {
            "latex": "n! = n \\times (n-1) \\times \\cdots \\times 2 \\times 1",
            "description": "Factorial"
          },
          {
            "latex": "P(n, r) = n \\times (n-1) \\times \\cdots \\times (n-r+1)",
            "description": "Permutation expanded"
          }
        ],
        "examples": [
          {
            "problem": "Find the number of ways 5 people can line up.",
            "solution": "P(5,5) = 5! = 5×4×3×2×1 = 120"
          },
          {
            "problem": "Choose president, VP, secretary from 10 people.",
            "solution": "P(10,3) = 10×9×8 = 720"
          }
        ],
        "applications": [
          { "field": "Cryptography", "description": "Password possibilities" },
          { "field": "Scheduling", "description": "Task ordering" },
          { "field": "Racing", "description": "Ranking combinations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["factorial"],
      "nextTopics": ["combinations"],
      "related": ["arrangements"]
    },
    "tags": ["순열", "경우의수", "permutations", "counting"]
  },
  {
    "id": "graph-theory",
    "name": { "ko": "그래프 이론 기초", "en": "Graph Theory Basics" },
    "field": "discrete",
    "subfield": "graph-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "그래프는 정점(vertex)과 간선(edge)으로 이루어진 구조입니다. 관계와 네트워크를 모델링하는 데 사용됩니다.",
        "formulas": [
          {
            "latex": "\\sum_{v \\in V} \\deg(v) = 2|E|",
            "description": "악수 정리 (차수의 합 = 간선 수의 2배)"
          },
          { "latex": "|V| - |E| + |F| = 2", "description": "오일러 공식 (평면 그래프)" }
        ],
        "examples": [
          {
            "problem": "5개의 정점이 있고 모든 정점이 연결된 완전 그래프의 간선 수는?",
            "solution": "완전 그래프 K₅의 간선 수 = C(5,2) = 10"
          }
        ],
        "history": {
          "discoveredBy": "레온하르트 오일러",
          "year": "1736년",
          "background": "오일러가 쾨니히스베르크의 다리 문제를 해결하면서 그래프 이론을 시작했습니다."
        },
        "applications": [
          { "field": "소셜 네트워크", "description": "친구 관계 분석" },
          { "field": "네트워크", "description": "라우팅 알고리즘" },
          { "field": "운영 연구", "description": "최단 경로, 최소 신장 트리" }
        ]
      },
      "en": {
        "definition": "A graph is a structure consisting of vertices and edges. It's used to model relationships and networks.",
        "formulas": [
          {
            "latex": "\\sum_{v \\in V} \\deg(v) = 2|E|",
            "description": "Handshaking lemma (sum of degrees = 2 × edges)"
          },
          { "latex": "|V| - |E| + |F| = 2", "description": "Euler's formula (planar graphs)" }
        ],
        "examples": [
          {
            "problem": "How many edges in a complete graph with 5 vertices?",
            "solution": "Complete graph K₅ has C(5,2) = 10 edges"
          }
        ],
        "history": {
          "discoveredBy": "Leonhard Euler",
          "year": "1736",
          "background": "Euler founded graph theory by solving the Seven Bridges of Königsberg problem."
        },
        "applications": [
          { "field": "Social Networks", "description": "Friend relationship analysis" },
          { "field": "Networks", "description": "Routing algorithms" },
          { "field": "Operations Research", "description": "Shortest path, MST" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sets"],
      "nextTopics": ["trees", "graph-algorithms"],
      "related": ["relations"]
    },
    "tags": ["그래프", "이산수학", "graph", "network"]
  },
  {
    "id": "recurrence-relations",
    "name": { "ko": "점화식", "en": "Recurrence Relations" },
    "field": "discrete",
    "subfield": "sequences",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "점화식은 수열의 항을 이전 항들로 정의하는 등식입니다. 재귀적 알고리즘의 복잡도 분석에 핵심적입니다.",
        "formulas": [
          { "latex": "a_n = a_{n-1} + a_{n-2}", "description": "피보나치 수열의 점화식" },
          { "latex": "T(n) = 2T(n/2) + n", "description": "병합 정렬의 점화식" },
          {
            "latex": "a_n = r \\cdot a_{n-1} \\Rightarrow a_n = a_1 \\cdot r^{n-1}",
            "description": "등비수열"
          }
        ],
        "examples": [
          {
            "problem": "a₁ = 1, aₙ = 2aₙ₋₁ + 1일 때 처음 5개 항을 구하세요.",
            "solution": "a₁=1, a₂=3, a₃=7, a₄=15, a₅=31 (aₙ = 2ⁿ - 1)"
          }
        ],
        "applications": [
          { "field": "알고리즘 분석", "description": "시간 복잡도 계산" },
          { "field": "동적 프로그래밍", "description": "최적화 문제" },
          { "field": "금융", "description": "복리 계산" }
        ]
      },
      "en": {
        "definition": "A recurrence relation defines sequence terms using previous terms. It's essential for analyzing recursive algorithm complexity.",
        "formulas": [
          { "latex": "a_n = a_{n-1} + a_{n-2}", "description": "Fibonacci recurrence" },
          { "latex": "T(n) = 2T(n/2) + n", "description": "Merge sort recurrence" },
          {
            "latex": "a_n = r \\cdot a_{n-1} \\Rightarrow a_n = a_1 \\cdot r^{n-1}",
            "description": "Geometric sequence"
          }
        ],
        "examples": [
          {
            "problem": "If a₁ = 1, aₙ = 2aₙ₋₁ + 1, find the first 5 terms.",
            "solution": "a₁=1, a₂=3, a₃=7, a₄=15, a₅=31 (aₙ = 2ⁿ - 1)"
          }
        ],
        "applications": [
          { "field": "Algorithm Analysis", "description": "Time complexity" },
          { "field": "Dynamic Programming", "description": "Optimization problems" },
          { "field": "Finance", "description": "Compound interest" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sequences"],
      "nextTopics": ["generating-functions", "master-theorem"],
      "related": ["fibonacci"]
    },
    "tags": ["점화식", "재귀", "recurrence", "recursion"]
  },
  {
    "id": "modular-arithmetic",
    "name": { "ko": "모듈러 연산", "en": "Modular Arithmetic" },
    "field": "discrete",
    "subfield": "number-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "모듈러 연산은 나눗셈의 나머지를 기반으로 하는 연산 체계입니다. 시계 산술이라고도 합니다.",
        "formulas": [
          {
            "latex": "a \\equiv b \\pmod{n} \\Leftrightarrow n | (a - b)",
            "description": "합동의 정의"
          },
          {
            "latex": "(a + b) \\mod n = ((a \\mod n) + (b \\mod n)) \\mod n",
            "description": "덧셈의 모듈러 성질"
          },
          {
            "latex": "(a \\times b) \\mod n = ((a \\mod n) \\times (b \\mod n)) \\mod n",
            "description": "곱셈의 모듈러 성질"
          }
        ],
        "examples": [
          { "problem": "17 mod 5를 구하세요.", "solution": "17 = 5×3 + 2이므로, 17 mod 5 = 2" },
          {
            "problem": "2^10 mod 7을 구하세요.",
            "solution": "2³ ≡ 1 (mod 7)이므로, 2^10 = 2^9 × 2 = (2³)³ × 2 ≡ 1×2 = 2 (mod 7)"
          }
        ],
        "applications": [
          { "field": "암호학", "description": "RSA 암호화" },
          { "field": "해시 함수", "description": "해시 테이블" },
          { "field": "오류 검출", "description": "체크섬, ISBN" }
        ]
      },
      "en": {
        "definition": "Modular arithmetic is a system based on remainders from division. Also called clock arithmetic.",
        "formulas": [
          {
            "latex": "a \\equiv b \\pmod{n} \\Leftrightarrow n | (a - b)",
            "description": "Definition of congruence"
          },
          {
            "latex": "(a + b) \\mod n = ((a \\mod n) + (b \\mod n)) \\mod n",
            "description": "Addition modular property"
          },
          {
            "latex": "(a \\times b) \\mod n = ((a \\mod n) \\times (b \\mod n)) \\mod n",
            "description": "Multiplication modular property"
          }
        ],
        "examples": [
          { "problem": "Find 17 mod 5.", "solution": "17 = 5×3 + 2, so 17 mod 5 = 2" },
          {
            "problem": "Find 2^10 mod 7.",
            "solution": "Since 2³ ≡ 1 (mod 7), 2^10 = 2^9 × 2 = (2³)³ × 2 ≡ 1×2 = 2 (mod 7)"
          }
        ],
        "applications": [
          { "field": "Cryptography", "description": "RSA encryption" },
          { "field": "Hash Functions", "description": "Hash tables" },
          { "field": "Error Detection", "description": "Checksums, ISBN" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["division"],
      "nextTopics": ["chinese-remainder-theorem", "fermats-little-theorem"],
      "related": ["number-theory"]
    },
    "tags": ["모듈러", "나머지", "modular", "congruence"]
  },
  {
    "id": "propositional-logic",
    "name": { "ko": "명제 논리", "en": "Propositional Logic" },
    "field": "discrete",
    "subfield": "logic",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "명제는 참 또는 거짓으로 판별할 수 있는 문장입니다. 논리 연산자로 복합 명제를 만듭니다.",
        "formulas": [
          { "latex": "\\neg p", "description": "부정 (NOT)" },
          { "latex": "p \\land q", "description": "논리곱 (AND)" },
          { "latex": "p \\lor q", "description": "논리합 (OR)" },
          { "latex": "p \\rightarrow q", "description": "조건문 (IF-THEN)" },
          { "latex": "p \\leftrightarrow q", "description": "쌍조건문 (IF AND ONLY IF)" }
        ],
        "examples": [
          {
            "problem": "p→q의 역, 이, 대우를 쓰시오.",
            "solution": "역: q→p\n이: ¬p→¬q\n대우: ¬q→¬p\n(원명제와 대우는 동치)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "프로그래밍", "description": "조건문, 불리언 로직" },
          { "field": "회로 설계", "description": "논리 게이트" },
          { "field": "인공지능", "description": "지식 표현" }
        ]
      },
      "en": {
        "definition": "A proposition is a statement that is either true or false. Logical operators combine propositions.",
        "formulas": [
          { "latex": "\\neg p", "description": "Negation (NOT)" },
          { "latex": "p \\land q", "description": "Conjunction (AND)" },
          { "latex": "p \\lor q", "description": "Disjunction (OR)" },
          { "latex": "p \\rightarrow q", "description": "Conditional (IF-THEN)" },
          { "latex": "p \\leftrightarrow q", "description": "Biconditional (IF AND ONLY IF)" }
        ],
        "examples": [
          {
            "problem": "Write the converse, inverse, and contrapositive of p→q.",
            "solution": "Converse: q→p\nInverse: ¬p→¬q\nContrapositive: ¬q→¬p\n(Original and contrapositive are equivalent)",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Programming", "description": "Conditionals, Boolean logic" },
          { "field": "Circuit Design", "description": "Logic gates" },
          { "field": "AI", "description": "Knowledge representation" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["boolean-algebra", "predicate-logic"],
      "related": ["truth-tables"]
    },
    "tags": ["논리", "명제", "logic", "proposition"]
  },
  {
    "id": "boolean-algebra",
    "name": { "ko": "불 대수", "en": "Boolean Algebra" },
    "field": "discrete",
    "subfield": "logic",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "0과 1(또는 참과 거짓)에 대한 대수 체계로, 논리 회로와 컴퓨터 과학의 기초입니다.",
        "formulas": [
          { "latex": "x + 0 = x, \\quad x \\cdot 1 = x", "description": "항등원" },
          { "latex": "x + x' = 1, \\quad x \\cdot x' = 0", "description": "보원" },
          {
            "latex": "(x + y)' = x' \\cdot y', \\quad (x \\cdot y)' = x' + y'",
            "description": "드모르간 법칙"
          }
        ],
        "examples": [
          {
            "problem": "x + x·y를 간소화하시오.",
            "solution": "x + x·y = x(1 + y) = x·1 = x (흡수 법칙)",
            "difficulty": 2
          }
        ],
        "history": {
          "discoveredBy": "조지 불",
          "year": "1854년",
          "background": "불이 '사고의 법칙'에서 논리를 대수적으로 표현했습니다."
        },
        "applications": [
          { "field": "디지털 회로", "description": "논리 게이트 설계" },
          { "field": "컴퓨터", "description": "CPU, 메모리 설계" },
          { "field": "검색 엔진", "description": "불리언 검색" }
        ]
      },
      "en": {
        "definition": "An algebraic system on 0 and 1 (or true and false), fundamental to logic circuits and computer science.",
        "formulas": [
          { "latex": "x + 0 = x, \\quad x \\cdot 1 = x", "description": "Identity laws" },
          { "latex": "x + x' = 1, \\quad x \\cdot x' = 0", "description": "Complement laws" },
          {
            "latex": "(x + y)' = x' \\cdot y', \\quad (x \\cdot y)' = x' + y'",
            "description": "De Morgan's laws"
          }
        ],
        "examples": [
          {
            "problem": "Simplify x + x·y.",
            "solution": "x + x·y = x(1 + y) = x·1 = x (Absorption law)",
            "difficulty": 2
          }
        ],
        "history": {
          "discoveredBy": "George Boole",
          "year": "1854",
          "background": "Boole expressed logic algebraically in 'The Laws of Thought'."
        },
        "applications": [
          { "field": "Digital Circuits", "description": "Logic gate design" },
          { "field": "Computers", "description": "CPU, memory design" },
          { "field": "Search Engines", "description": "Boolean search" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["propositional-logic"],
      "nextTopics": ["logic-gates"],
      "related": ["sets"]
    },
    "tags": ["불대수", "논리", "Boolean", "algebra"]
  },
  {
    "id": "trees",
    "name": { "ko": "트리", "en": "Trees" },
    "field": "discrete",
    "subfield": "graph-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "트리는 사이클이 없는 연결 그래프입니다. n개의 정점이 있으면 n-1개의 간선을 가집니다.",
        "formulas": [
          { "latex": "|E| = |V| - 1", "description": "트리의 간선 수" },
          {
            "latex": "\\text{leaves} \\geq 2",
            "description": "트리는 최소 2개의 잎(리프) 노드를 가짐"
          }
        ],
        "examples": [
          {
            "problem": "10개의 정점을 가진 트리의 간선 수는?",
            "solution": "|E| = 10 - 1 = 9개",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "컴퓨터 과학", "description": "이진 탐색 트리, 힙" },
          { "field": "파일 시스템", "description": "디렉토리 구조" },
          { "field": "네트워크", "description": "최소 신장 트리" }
        ]
      },
      "en": {
        "definition": "A tree is a connected graph with no cycles. With n vertices, it has n-1 edges.",
        "formulas": [
          { "latex": "|E| = |V| - 1", "description": "Number of edges in a tree" },
          { "latex": "\\text{leaves} \\geq 2", "description": "A tree has at least 2 leaf nodes" }
        ],
        "examples": [
          {
            "problem": "How many edges in a tree with 10 vertices?",
            "solution": "|E| = 10 - 1 = 9 edges",
            "difficulty": 1
          }
        ],
        "applications": [
          { "field": "Computer Science", "description": "Binary search trees, heaps" },
          { "field": "File Systems", "description": "Directory structure" },
          { "field": "Networking", "description": "Minimum spanning trees" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["graph-theory"],
      "nextTopics": ["binary-trees", "spanning-trees"],
      "related": ["forests"]
    },
    "tags": ["트리", "그래프", "tree", "graph"]
  },
  {
    "id": "binomial-theorem",
    "name": { "ko": "이항정리", "en": "Binomial Theorem" },
    "field": "discrete",
    "subfield": "combinatorics",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "두 항의 거듭제곱을 전개하는 공식으로, 조합을 계수로 사용합니다.",
        "formulas": [
          {
            "latex": "(x + y)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^{n-k} y^k",
            "description": "이항정리"
          },
          {
            "latex": "\\binom{n}{0} + \\binom{n}{1} + \\cdots + \\binom{n}{n} = 2^n",
            "description": "이항계수의 합"
          }
        ],
        "examples": [
          {
            "problem": "(x + 1)⁴를 전개하시오.",
            "solution": "= x⁴ + 4x³ + 6x² + 4x + 1\n(계수: 1, 4, 6, 4, 1 = 파스칼 삼각형 4행)",
            "difficulty": 2
          }
        ],
        "history": {
          "discoveredBy": "아이작 뉴턴",
          "year": "17세기",
          "background": "뉴턴이 음수/분수 지수로 일반화했습니다."
        },
        "applications": [
          { "field": "확률론", "description": "이항분포 유도" },
          { "field": "근사", "description": "(1+x)ⁿ의 근사" }
        ]
      },
      "en": {
        "definition": "A formula for expanding powers of binomials using combinations as coefficients.",
        "formulas": [
          {
            "latex": "(x + y)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^{n-k} y^k",
            "description": "Binomial theorem"
          },
          {
            "latex": "\\binom{n}{0} + \\binom{n}{1} + \\cdots + \\binom{n}{n} = 2^n",
            "description": "Sum of binomial coefficients"
          }
        ],
        "examples": [
          {
            "problem": "Expand (x + 1)⁴.",
            "solution": "= x⁴ + 4x³ + 6x² + 4x + 1\n(Coefficients: 1, 4, 6, 4, 1 = Pascal's triangle row 4)",
            "difficulty": 2
          }
        ],
        "history": {
          "discoveredBy": "Isaac Newton",
          "year": "17th century",
          "background": "Newton generalized to negative/fractional exponents."
        },
        "applications": [
          { "field": "Probability", "description": "Binomial distribution derivation" },
          { "field": "Approximation", "description": "(1+x)ⁿ approximations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["combinations"],
      "nextTopics": ["multinomial"],
      "related": ["pascal-triangle"]
    },
    "tags": ["이항정리", "조합", "binomial", "theorem"]
  },
  {
    "id": "big-o-notation",
    "name": { "ko": "빅오 표기법", "en": "Big O Notation" },
    "field": "discrete",
    "subfield": "algorithms",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "알고리즘의 시간/공간 복잡도를 표현하는 점근적 표기법입니다.",
        "formulas": [
          { "latex": "f(n) = O(g(n))", "description": "f는 g의 상한 (최악의 경우)" },
          {
            "latex": "O(1) < O(\\log n) < O(n) < O(n \\log n) < O(n^2) < O(2^n)",
            "description": "일반적인 복잡도 순서"
          }
        ],
        "examples": [
          {
            "problem": "버블 정렬의 시간 복잡도는?",
            "solution": "O(n²) - 중첩 반복문",
            "difficulty": 2
          },
          {
            "problem": "이진 탐색의 시간 복잡도는?",
            "solution": "O(log n) - 매 단계에서 반으로 줄임",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "알고리즘 분석", "description": "효율성 비교" },
          { "field": "시스템 설계", "description": "확장성 평가" }
        ]
      },
      "en": {
        "definition": "Asymptotic notation to express time/space complexity of algorithms.",
        "formulas": [
          { "latex": "f(n) = O(g(n))", "description": "f is upper-bounded by g (worst case)" },
          {
            "latex": "O(1) < O(\\log n) < O(n) < O(n \\log n) < O(n^2) < O(2^n)",
            "description": "Common complexity ordering"
          }
        ],
        "examples": [
          {
            "problem": "Time complexity of bubble sort?",
            "solution": "O(n²) - nested loops",
            "difficulty": 2
          },
          {
            "problem": "Time complexity of binary search?",
            "solution": "O(log n) - halves the search space each step",
            "difficulty": 2
          }
        ],
        "applications": [
          { "field": "Algorithm Analysis", "description": "Efficiency comparison" },
          { "field": "System Design", "description": "Scalability assessment" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["logarithm", "exponential-function"],
      "nextTopics": ["master-theorem"],
      "related": ["recurrence-relations"]
    },
    "tags": ["빅오", "복잡도", "Big O", "complexity"]
  },
  {
    "id": "prime-numbers",
    "name": { "ko": "소수", "en": "Prime Numbers" },
    "field": "number-theory",
    "subfield": "primes",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "소수는 1과 자기 자신만을 약수로 가지는 1보다 큰 자연수입니다. 모든 자연수는 소수의 곱으로 유일하게 표현됩니다.",
        "formulas": [
          {
            "latex": "\\pi(x) \\sim \\frac{x}{\\ln x}",
            "description": "소수 계수 함수의 점근 추정 (소수 정리)"
          }
        ],
        "examples": [
          {
            "problem": "100 이하의 소수를 나열하세요.",
            "solution": "2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 (25개)"
          },
          {
            "problem": "91이 소수인지 판별하세요.",
            "solution": "91 = 7 × 13이므로 소수가 아닙니다."
          }
        ],
        "history": {
          "discoveredBy": "유클리드",
          "year": "기원전 300년경",
          "background": "유클리드는 소수가 무한히 많음을 증명했습니다. 이것은 역사상 가장 우아한 증명 중 하나입니다."
        },
        "applications": [
          { "field": "암호학", "description": "RSA 암호화의 기반" },
          { "field": "해시 함수", "description": "충돌 방지" },
          { "field": "난수 생성", "description": "선형 합동 생성기" }
        ]
      },
      "en": {
        "definition": "A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Every natural number can be uniquely expressed as a product of primes.",
        "formulas": [
          {
            "latex": "\\pi(x) \\sim \\frac{x}{\\ln x}",
            "description": "Prime counting function estimate (Prime Number Theorem)"
          }
        ],
        "examples": [
          {
            "problem": "List all primes up to 100.",
            "solution": "2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 (25 primes)"
          },
          { "problem": "Is 91 prime?", "solution": "91 = 7 × 13, so it's not prime." }
        ],
        "history": {
          "discoveredBy": "Euclid",
          "year": "c. 300 BCE",
          "background": "Euclid proved there are infinitely many primes. This is one of the most elegant proofs in history."
        },
        "applications": [
          { "field": "Cryptography", "description": "Foundation of RSA" },
          { "field": "Hash Functions", "description": "Collision avoidance" },
          { "field": "Random Numbers", "description": "Linear congruential generators" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["division", "factors"],
      "nextTopics": ["fundamental-theorem-arithmetic", "gcd-lcm"],
      "related": ["composite-numbers"]
    },
    "tags": ["소수", "정수론", "prime", "number theory"]
  },
  {
    "id": "gcd-lcm",
    "name": { "ko": "최대공약수와 최소공배수", "en": "GCD and LCM" },
    "field": "number-theory",
    "subfield": "divisibility",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "최대공약수(GCD)는 두 수의 공통 약수 중 가장 큰 것이고, 최소공배수(LCM)는 공통 배수 중 가장 작은 것입니다.",
        "formulas": [
          {
            "latex": "\\gcd(a, b) \\times \\text{lcm}(a, b) = a \\times b",
            "description": "GCD와 LCM의 관계"
          },
          { "latex": "\\gcd(a, b) = \\gcd(b, a \\mod b)", "description": "유클리드 호제법" }
        ],
        "examples": [
          {
            "problem": "gcd(48, 18)을 유클리드 호제법으로 구하세요.",
            "solution": "gcd(48, 18) = gcd(18, 12) = gcd(12, 6) = gcd(6, 0) = 6"
          },
          {
            "problem": "lcm(12, 18)을 구하세요.",
            "solution": "gcd(12, 18) = 6이므로, lcm = (12 × 18) / 6 = 36"
          }
        ],
        "history": {
          "discoveredBy": "유클리드",
          "year": "기원전 300년경",
          "background": "유클리드의 원론에 나오는 알고리즘으로, 가장 오래된 알고리즘 중 하나입니다."
        },
        "applications": [
          { "field": "분수 계산", "description": "분수의 약분과 통분" },
          { "field": "암호학", "description": "RSA의 키 생성" },
          { "field": "스케줄링", "description": "주기적 이벤트 동기화" }
        ]
      },
      "en": {
        "definition": "GCD (Greatest Common Divisor) is the largest common divisor of two numbers. LCM (Least Common Multiple) is the smallest common multiple.",
        "formulas": [
          {
            "latex": "\\gcd(a, b) \\times \\text{lcm}(a, b) = a \\times b",
            "description": "Relationship between GCD and LCM"
          },
          { "latex": "\\gcd(a, b) = \\gcd(b, a \\mod b)", "description": "Euclidean algorithm" }
        ],
        "examples": [
          {
            "problem": "Find gcd(48, 18) using Euclidean algorithm.",
            "solution": "gcd(48, 18) = gcd(18, 12) = gcd(12, 6) = gcd(6, 0) = 6"
          },
          {
            "problem": "Find lcm(12, 18).",
            "solution": "gcd(12, 18) = 6, so lcm = (12 × 18) / 6 = 36"
          }
        ],
        "history": {
          "discoveredBy": "Euclid",
          "year": "c. 300 BCE",
          "background": "Algorithm from Euclid's Elements, one of the oldest algorithms known."
        },
        "applications": [
          { "field": "Fraction Arithmetic", "description": "Simplifying and adding fractions" },
          { "field": "Cryptography", "description": "RSA key generation" },
          { "field": "Scheduling", "description": "Periodic event synchronization" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["division", "prime-numbers"],
      "nextTopics": ["modular-arithmetic", "diophantine-equations"],
      "related": ["euclidean-algorithm"]
    },
    "tags": ["최대공약수", "최소공배수", "GCD", "LCM"]
  },
  {
    "id": "fermats-little-theorem",
    "name": { "ko": "페르마의 소정리", "en": "Fermat's Little Theorem" },
    "field": "number-theory",
    "subfield": "modular-theory",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "p가 소수이고 a가 p로 나누어지지 않으면, a^(p-1) ≡ 1 (mod p)입니다.",
        "formulas": [
          { "latex": "a^{p-1} \\equiv 1 \\pmod{p}", "description": "페르마의 소정리" },
          { "latex": "a^p \\equiv a \\pmod{p}", "description": "페르마의 소정리 (변형)" }
        ],
        "examples": [
          {
            "problem": "2^10 mod 11을 페르마의 소정리로 구하세요.",
            "solution": "11은 소수이고 gcd(2,11)=1이므로, 2^10 ≡ 1 (mod 11)"
          },
          {
            "problem": "3^100 mod 7을 구하세요.",
            "solution": "3^6 ≡ 1 (mod 7), 100 = 6×16 + 4이므로, 3^100 ≡ 3^4 = 81 ≡ 4 (mod 7)"
          }
        ],
        "history": {
          "discoveredBy": "피에르 드 페르마",
          "year": "1640년",
          "background": "페르마가 메르센에게 보낸 편지에서 처음 언급했으며, 오일러가 증명했습니다."
        },
        "applications": [
          { "field": "암호학", "description": "RSA 암호화, 소수 판정" },
          { "field": "알고리즘", "description": "빠른 거듭제곱 연산" }
        ]
      },
      "en": {
        "definition": "If p is prime and a is not divisible by p, then a^(p-1) ≡ 1 (mod p).",
        "formulas": [
          { "latex": "a^{p-1} \\equiv 1 \\pmod{p}", "description": "Fermat's Little Theorem" },
          { "latex": "a^p \\equiv a \\pmod{p}", "description": "Fermat's Little Theorem (variant)" }
        ],
        "examples": [
          {
            "problem": "Find 2^10 mod 11 using Fermat's Little Theorem.",
            "solution": "11 is prime and gcd(2,11)=1, so 2^10 ≡ 1 (mod 11)"
          },
          {
            "problem": "Find 3^100 mod 7.",
            "solution": "3^6 ≡ 1 (mod 7), 100 = 6×16 + 4, so 3^100 ≡ 3^4 = 81 ≡ 4 (mod 7)"
          }
        ],
        "history": {
          "discoveredBy": "Pierre de Fermat",
          "year": "1640",
          "background": "First mentioned in a letter to Mersenne; proved by Euler."
        },
        "applications": [
          { "field": "Cryptography", "description": "RSA, primality testing" },
          { "field": "Algorithms", "description": "Fast exponentiation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["modular-arithmetic", "prime-numbers"],
      "nextTopics": ["eulers-theorem", "rsa"],
      "related": ["chinese-remainder-theorem"]
    },
    "tags": ["페르마", "소정리", "Fermat", "little theorem"]
  },
  {
    "id": "fibonacci",
    "name": { "ko": "피보나치 수열", "en": "Fibonacci Sequence" },
    "field": "number-theory",
    "subfield": "sequences",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "피보나치 수열은 앞의 두 항의 합이 다음 항이 되는 수열입니다. F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2).",
        "formulas": [
          { "latex": "F_n = F_{n-1} + F_{n-2}", "description": "피보나치 점화식" },
          {
            "latex": "F_n = \\frac{\\phi^n - \\psi^n}{\\sqrt{5}}",
            "description": "비네 공식 (φ = 황금비)"
          },
          {
            "latex": "\\lim_{n \\to \\infty} \\frac{F_{n+1}}{F_n} = \\phi = \\frac{1+\\sqrt{5}}{2}",
            "description": "황금비로의 수렴"
          }
        ],
        "examples": [
          {
            "problem": "피보나치 수열의 처음 10개 항을 나열하세요.",
            "solution": "1, 1, 2, 3, 5, 8, 13, 21, 34, 55"
          }
        ],
        "history": {
          "discoveredBy": "레오나르도 피보나치",
          "year": "1202년",
          "background": "피보나치가 토끼 번식 문제를 설명하면서 이 수열을 소개했습니다."
        },
        "applications": [
          { "field": "자연", "description": "해바라기 씨앗 배열, 조개껍질 나선" },
          { "field": "금융", "description": "피보나치 되돌림" },
          { "field": "알고리즘", "description": "피보나치 힙, 동적 프로그래밍 예제" }
        ]
      },
      "en": {
        "definition": "The Fibonacci sequence is where each term is the sum of the two preceding terms. F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2).",
        "formulas": [
          { "latex": "F_n = F_{n-1} + F_{n-2}", "description": "Fibonacci recurrence" },
          {
            "latex": "F_n = \\frac{\\phi^n - \\psi^n}{\\sqrt{5}}",
            "description": "Binet's formula (φ = golden ratio)"
          },
          {
            "latex": "\\lim_{n \\to \\infty} \\frac{F_{n+1}}{F_n} = \\phi = \\frac{1+\\sqrt{5}}{2}",
            "description": "Convergence to golden ratio"
          }
        ],
        "examples": [
          {
            "problem": "List the first 10 Fibonacci numbers.",
            "solution": "1, 1, 2, 3, 5, 8, 13, 21, 34, 55"
          }
        ],
        "history": {
          "discoveredBy": "Leonardo Fibonacci",
          "year": "1202",
          "background": "Fibonacci introduced this sequence while explaining rabbit breeding."
        },
        "applications": [
          { "field": "Nature", "description": "Sunflower seeds, shell spirals" },
          { "field": "Finance", "description": "Fibonacci retracement" },
          { "field": "Algorithms", "description": "Fibonacci heap, DP example" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sequences"],
      "nextTopics": ["golden-ratio", "recurrence-relations"],
      "related": ["lucas-numbers"]
    },
    "tags": ["피보나치", "수열", "Fibonacci", "sequence"]
  },
  {
    "id": "diophantine-equations",
    "name": { "ko": "디오판토스 방정식", "en": "Diophantine Equations" },
    "field": "number-theory",
    "subfield": "equations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "디오판토스 방정식은 정수 해만을 찾는 다항 방정식입니다. 해의 존재 여부와 모든 해를 찾는 것이 주요 문제입니다.",
        "formulas": [
          { "latex": "ax + by = c", "description": "일차 디오판토스 방정식" },
          { "latex": "\\gcd(a,b) | c \\text{이면 해가 존재}", "description": "해의 존재 조건" },
          {
            "latex": "x^n + y^n = z^n",
            "description": "페르마의 마지막 정리 (n≥3일 때 정수해 없음)"
          }
        ],
        "examples": [
          {
            "problem": "3x + 5y = 1의 정수 해를 찾으세요.",
            "solution": "확장 유클리드: 3(2) + 5(-1) = 1, 따라서 x=2, y=-1. 일반해: x=2+5t, y=-1-3t"
          }
        ],
        "history": {
          "discoveredBy": "디오판토스",
          "year": "3세기경",
          "background": "알렉산드리아의 디오판토스가 그의 저서 '산술'에서 이러한 문제들을 다루었습니다."
        },
        "applications": [
          { "field": "암호학", "description": "RSA의 확장 유클리드 알고리즘" },
          { "field": "조합론", "description": "동전 교환 문제" }
        ]
      },
      "en": {
        "definition": "Diophantine equations are polynomial equations seeking integer solutions. Key problems are existence and finding all solutions.",
        "formulas": [
          { "latex": "ax + by = c", "description": "Linear Diophantine equation" },
          {
            "latex": "\\gcd(a,b) | c \\text{ implies solution exists}",
            "description": "Existence condition"
          },
          {
            "latex": "x^n + y^n = z^n",
            "description": "Fermat's Last Theorem (no integer solutions for n≥3)"
          }
        ],
        "examples": [
          {
            "problem": "Find integer solutions to 3x + 5y = 1.",
            "solution": "Extended Euclidean: 3(2) + 5(-1) = 1, so x=2, y=-1. General: x=2+5t, y=-1-3t"
          }
        ],
        "history": {
          "discoveredBy": "Diophantus",
          "year": "c. 3rd century",
          "background": "Diophantus of Alexandria studied these problems in his work 'Arithmetica'."
        },
        "applications": [
          { "field": "Cryptography", "description": "Extended Euclidean in RSA" },
          { "field": "Combinatorics", "description": "Coin change problem" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["gcd-lcm", "modular-arithmetic"],
      "nextTopics": ["fermats-last-theorem"],
      "related": ["linear-algebra"]
    },
    "tags": ["디오판토스", "정수론", "Diophantine", "integer equations"]
  },
  {
    "id": "modular-arithmetic",
    "name": { "ko": "모듈러 산술", "en": "Modular Arithmetic" },
    "field": "number-theory",
    "subfield": "modular-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "모듈러 산술은 정수를 어떤 수(법)로 나눈 나머지로 계산하는 체계입니다. 시계 산술이라고도 불립니다.",
        "formulas": [
          {
            "latex": "a \\equiv b \\pmod{n} \\Leftrightarrow n | (a-b)",
            "description": "합동의 정의"
          },
          {
            "latex": "(a + b) \\mod n = ((a \\mod n) + (b \\mod n)) \\mod n",
            "description": "덧셈의 모듈러 성질"
          },
          {
            "latex": "(a \\cdot b) \\mod n = ((a \\mod n) \\cdot (b \\mod n)) \\mod n",
            "description": "곱셈의 모듈러 성질"
          }
        ],
        "examples": [
          {
            "problem": "17 ≡ ? (mod 5)를 구하세요.",
            "solution": "17 = 5 × 3 + 2이므로 17 ≡ 2 (mod 5)"
          },
          {
            "problem": "2^10 mod 7을 구하세요.",
            "solution": "2^3 = 8 ≡ 1 (mod 7). 2^10 = 2^9 × 2 = (2^3)^3 × 2 ≡ 1 × 2 = 2 (mod 7)"
          }
        ],
        "applications": [
          { "field": "암호학", "description": "RSA, AES 암호화" },
          { "field": "해시 함수", "description": "데이터 분산" },
          { "field": "오류 검출", "description": "ISBN, 신용카드 검증" }
        ]
      },
      "en": {
        "definition": "Modular arithmetic is a system where calculations are done with remainders after division by a modulus. Also called clock arithmetic.",
        "formulas": [
          {
            "latex": "a \\equiv b \\pmod{n} \\Leftrightarrow n | (a-b)",
            "description": "Definition of congruence"
          },
          {
            "latex": "(a + b) \\mod n = ((a \\mod n) + (b \\mod n)) \\mod n",
            "description": "Addition modular property"
          },
          {
            "latex": "(a \\cdot b) \\mod n = ((a \\mod n) \\cdot (b \\mod n)) \\mod n",
            "description": "Multiplication modular property"
          }
        ],
        "examples": [
          { "problem": "Find 17 ≡ ? (mod 5).", "solution": "17 = 5 × 3 + 2, so 17 ≡ 2 (mod 5)" },
          {
            "problem": "Find 2^10 mod 7.",
            "solution": "2^3 = 8 ≡ 1 (mod 7). 2^10 = 2^9 × 2 = (2^3)^3 × 2 ≡ 1 × 2 = 2 (mod 7)"
          }
        ],
        "applications": [
          { "field": "Cryptography", "description": "RSA, AES encryption" },
          { "field": "Hash Functions", "description": "Data distribution" },
          { "field": "Error Detection", "description": "ISBN, credit card verification" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["division", "integers"],
      "nextTopics": ["fermats-little-theorem", "chinese-remainder-theorem"],
      "related": ["gcd-lcm"]
    },
    "tags": ["모듈러", "합동", "modular", "congruence"]
  },
  {
    "id": "chinese-remainder-theorem",
    "name": { "ko": "중국인의 나머지 정리", "en": "Chinese Remainder Theorem" },
    "field": "number-theory",
    "subfield": "modular-theory",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "서로소인 법들에 대한 연립 합동식은 유일한 해를 가집니다. 큰 수의 계산을 작은 계산으로 분해할 수 있게 합니다.",
        "formulas": [
          {
            "latex": "x \\equiv a_1 \\pmod{n_1}, \\ldots, x \\equiv a_k \\pmod{n_k}",
            "description": "연립 합동식"
          },
          {
            "latex": "x \\equiv \\sum_{i} a_i N_i M_i \\pmod{N}",
            "description": "해의 공식 (N = n₁...nₖ, Nᵢ = N/nᵢ, MᵢNᵢ ≡ 1 mod nᵢ)"
          }
        ],
        "examples": [
          {
            "problem": "x ≡ 2 (mod 3), x ≡ 3 (mod 5)를 만족하는 x를 구하세요.",
            "solution": "N = 15. N₁ = 5, N₂ = 3. 5M₁ ≡ 1 (mod 3)에서 M₁ = 2. 3M₂ ≡ 1 (mod 5)에서 M₂ = 2. x = 2×5×2 + 3×3×2 = 20 + 18 = 38 ≡ 8 (mod 15)"
          }
        ],
        "history": {
          "discoveredBy": "손자 (중국 수학자)",
          "year": "3세기경",
          "background": "손자산경에서 처음 등장했으며, 병사 수를 세는 문제로 유명합니다."
        },
        "applications": [
          { "field": "암호학", "description": "RSA 복호화 가속" },
          { "field": "컴퓨터 대수", "description": "큰 수 연산 분해" },
          { "field": "스케줄링", "description": "주기적 이벤트 계산" }
        ]
      },
      "en": {
        "definition": "A system of congruences with pairwise coprime moduli has a unique solution. It allows decomposing large computations into smaller ones.",
        "formulas": [
          {
            "latex": "x \\equiv a_1 \\pmod{n_1}, \\ldots, x \\equiv a_k \\pmod{n_k}",
            "description": "System of congruences"
          },
          {
            "latex": "x \\equiv \\sum_{i} a_i N_i M_i \\pmod{N}",
            "description": "Solution formula (N = n₁...nₖ, Nᵢ = N/nᵢ, MᵢNᵢ ≡ 1 mod nᵢ)"
          }
        ],
        "examples": [
          {
            "problem": "Find x where x ≡ 2 (mod 3), x ≡ 3 (mod 5).",
            "solution": "N = 15. N₁ = 5, N₂ = 3. 5M₁ ≡ 1 (mod 3) gives M₁ = 2. 3M₂ ≡ 1 (mod 5) gives M₂ = 2. x = 2×5×2 + 3×3×2 = 38 ≡ 8 (mod 15)"
          }
        ],
        "history": {
          "discoveredBy": "Sunzi (Chinese mathematician)",
          "year": "c. 3rd century",
          "background": "First appeared in Sunzi Suanjing, famous for counting soldiers problem."
        },
        "applications": [
          { "field": "Cryptography", "description": "RSA decryption speedup" },
          { "field": "Computer Algebra", "description": "Large number decomposition" },
          { "field": "Scheduling", "description": "Periodic event calculation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["modular-arithmetic", "gcd-lcm"],
      "nextTopics": ["eulers-theorem"],
      "related": ["fermats-little-theorem"]
    },
    "tags": ["중국인나머지", "연립합동", "CRT", "Chinese remainder"]
  },
  {
    "id": "euler-totient",
    "name": { "ko": "오일러 피 함수", "en": "Euler's Totient Function" },
    "field": "number-theory",
    "subfield": "multiplicative-functions",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "오일러 피 함수 φ(n)은 n 이하의 양의 정수 중 n과 서로소인 것의 개수입니다. RSA 암호의 핵심입니다.",
        "formulas": [
          {
            "latex": "\\phi(n) = |\\{k : 1 \\leq k \\leq n, \\gcd(k,n) = 1\\}|",
            "description": "오일러 피 함수의 정의"
          },
          { "latex": "\\phi(p) = p - 1", "description": "소수의 경우" },
          { "latex": "\\phi(p^k) = p^{k-1}(p-1)", "description": "소수 거듭제곱의 경우" },
          {
            "latex": "\\phi(mn) = \\phi(m)\\phi(n) \\text{ if } \\gcd(m,n) = 1",
            "description": "곱셈적 함수 성질"
          }
        ],
        "examples": [
          {
            "problem": "φ(12)를 구하세요.",
            "solution": "12와 서로소인 수: 1, 5, 7, 11 (4개). 또는 φ(12) = φ(4)φ(3) = 2 × 2 = 4"
          },
          {
            "problem": "φ(100)을 구하세요.",
            "solution": "100 = 4 × 25 = 2² × 5². φ(100) = φ(4)φ(25) = 2 × 20 = 40"
          }
        ],
        "history": {
          "discoveredBy": "레온하르트 오일러",
          "year": "1763년",
          "background": "오일러가 페르마의 소정리를 일반화하면서 이 함수를 도입했습니다."
        },
        "applications": [
          { "field": "암호학", "description": "RSA의 핵심 (공개키/개인키 생성)" },
          { "field": "정수론", "description": "오일러 정리, 원시근" },
          { "field": "그룹론", "description": "순환군의 위수" }
        ]
      },
      "en": {
        "definition": "Euler's totient function φ(n) counts positive integers up to n that are coprime to n. It's central to RSA cryptography.",
        "formulas": [
          {
            "latex": "\\phi(n) = |\\{k : 1 \\leq k \\leq n, \\gcd(k,n) = 1\\}|",
            "description": "Definition of Euler's totient"
          },
          { "latex": "\\phi(p) = p - 1", "description": "For prime p" },
          { "latex": "\\phi(p^k) = p^{k-1}(p-1)", "description": "For prime power" },
          {
            "latex": "\\phi(mn) = \\phi(m)\\phi(n) \\text{ if } \\gcd(m,n) = 1",
            "description": "Multiplicative property"
          }
        ],
        "examples": [
          {
            "problem": "Find φ(12).",
            "solution": "Numbers coprime to 12: 1, 5, 7, 11 (4 numbers). Or φ(12) = φ(4)φ(3) = 2 × 2 = 4"
          },
          {
            "problem": "Find φ(100).",
            "solution": "100 = 4 × 25 = 2² × 5². φ(100) = φ(4)φ(25) = 2 × 20 = 40"
          }
        ],
        "history": {
          "discoveredBy": "Leonhard Euler",
          "year": "1763",
          "background": "Euler introduced this function while generalizing Fermat's little theorem."
        },
        "applications": [
          { "field": "Cryptography", "description": "RSA key generation" },
          { "field": "Number Theory", "description": "Euler's theorem, primitive roots" },
          { "field": "Group Theory", "description": "Order of cyclic groups" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["gcd-lcm", "prime-numbers"],
      "nextTopics": ["eulers-theorem", "primitive-roots"],
      "related": ["fermats-little-theorem"]
    },
    "tags": ["오일러", "피함수", "totient", "phi function"]
  },
  {
    "id": "quadratic-residues",
    "name": { "ko": "이차 잉여", "en": "Quadratic Residues" },
    "field": "number-theory",
    "subfield": "modular-theory",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "정수 a가 mod n에서 이차 잉여라는 것은 x² ≡ a (mod n)을 만족하는 x가 존재한다는 것입니다.",
        "formulas": [
          {
            "latex": "\\left(\\frac{a}{p}\\right) = \\begin{cases} 1 & \\text{이차 잉여} \\\\ -1 & \\text{이차 비잉여} \\\\ 0 & p|a \\end{cases}",
            "description": "르장드르 기호"
          },
          {
            "latex": "\\left(\\frac{a}{p}\\right) \\equiv a^{(p-1)/2} \\pmod{p}",
            "description": "오일러 판정법"
          },
          {
            "latex": "\\left(\\frac{-1}{p}\\right) = (-1)^{(p-1)/2}",
            "description": "-1의 이차 잉여 조건"
          }
        ],
        "examples": [
          {
            "problem": "mod 7에서 이차 잉여를 모두 찾으세요.",
            "solution": "1² ≡ 1, 2² ≡ 4, 3² ≡ 2, 4² ≡ 2, 5² ≡ 4, 6² ≡ 1. 이차 잉여: {1, 2, 4}"
          },
          {
            "problem": "3이 mod 11에서 이차 잉여인지 판별하세요.",
            "solution": "오일러 판정: 3^5 = 243 = 22×11 + 1 ≡ 1 (mod 11). 이차 잉여입니다."
          }
        ],
        "applications": [
          { "field": "암호학", "description": "제곱근 계산, 영지식 증명" },
          { "field": "정수론", "description": "이차 상호법칙" },
          { "field": "소수 판정", "description": "Solovay-Strassen 테스트" }
        ]
      },
      "en": {
        "definition": "An integer a is a quadratic residue mod n if there exists x such that x² ≡ a (mod n).",
        "formulas": [
          {
            "latex": "\\left(\\frac{a}{p}\\right) = \\begin{cases} 1 & \\text{QR} \\\\ -1 & \\text{QNR} \\\\ 0 & p|a \\end{cases}",
            "description": "Legendre symbol"
          },
          {
            "latex": "\\left(\\frac{a}{p}\\right) \\equiv a^{(p-1)/2} \\pmod{p}",
            "description": "Euler's criterion"
          },
          {
            "latex": "\\left(\\frac{-1}{p}\\right) = (-1)^{(p-1)/2}",
            "description": "Condition for -1 being QR"
          }
        ],
        "examples": [
          {
            "problem": "Find all quadratic residues mod 7.",
            "solution": "1² ≡ 1, 2² ≡ 4, 3² ≡ 2, 4² ≡ 2, 5² ≡ 4, 6² ≡ 1. QRs: {1, 2, 4}"
          },
          {
            "problem": "Is 3 a quadratic residue mod 11?",
            "solution": "Euler's criterion: 3^5 = 243 = 22×11 + 1 ≡ 1 (mod 11). Yes, it's a QR."
          }
        ],
        "applications": [
          { "field": "Cryptography", "description": "Square root computation, zero-knowledge" },
          { "field": "Number Theory", "description": "Quadratic reciprocity" },
          { "field": "Primality Testing", "description": "Solovay-Strassen test" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["modular-arithmetic", "fermats-little-theorem"],
      "nextTopics": ["quadratic-reciprocity"],
      "related": ["euler-totient"]
    },
    "tags": ["이차잉여", "르장드르", "quadratic residue", "Legendre"]
  },
  {
    "id": "topological-space",
    "name": { "ko": "위상공간", "en": "Topological Space" },
    "field": "topology",
    "subfield": "general-topology",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "위상공간은 집합과 그 위에 정의된 열린 집합들의 모임(위상)으로 이루어진 구조입니다. 연속성, 수렴, 연결성 등을 정의할 수 있게 합니다.",
        "formulas": [
          { "latex": "\\emptyset, X \\in \\tau", "description": "공집합과 전체집합은 열린집합" },
          {
            "latex": "\\bigcup_{\\alpha} U_\\alpha \\in \\tau",
            "description": "열린집합의 임의의 합집합은 열린집합"
          },
          {
            "latex": "U_1 \\cap U_2 \\in \\tau",
            "description": "열린집합의 유한 교집합은 열린집합"
          }
        ],
        "examples": [
          {
            "problem": "실수 직선 ℝ에서 열린 구간이 열린집합임을 설명하세요.",
            "solution": "표준 위상에서 (a,b)는 열린집합입니다. 모든 점 x ∈ (a,b)에 대해 x를 포함하는 열린 구간이 (a,b) 안에 있기 때문입니다."
          }
        ],
        "history": {
          "discoveredBy": "펠릭스 하우스도르프",
          "year": "1914년",
          "background": "하우스도르프가 위상공간의 공리적 정의를 제시했습니다."
        },
        "applications": [
          { "field": "해석학", "description": "연속함수의 일반화" },
          { "field": "대수기하학", "description": "다양체의 정의" },
          { "field": "양자역학", "description": "힐베르트 공간" }
        ]
      },
      "en": {
        "definition": "A topological space is a structure consisting of a set and a collection of open sets (topology). It allows defining continuity, convergence, and connectedness.",
        "formulas": [
          {
            "latex": "\\emptyset, X \\in \\tau",
            "description": "Empty set and whole set are open"
          },
          {
            "latex": "\\bigcup_{\\alpha} U_\\alpha \\in \\tau",
            "description": "Arbitrary union of open sets is open"
          },
          {
            "latex": "U_1 \\cap U_2 \\in \\tau",
            "description": "Finite intersection of open sets is open"
          }
        ],
        "examples": [
          {
            "problem": "Explain why open intervals are open sets in ℝ.",
            "solution": "In standard topology, (a,b) is open because for every x ∈ (a,b), there exists an open interval containing x within (a,b)."
          }
        ],
        "history": {
          "discoveredBy": "Felix Hausdorff",
          "year": "1914",
          "background": "Hausdorff gave the axiomatic definition of topological spaces."
        },
        "applications": [
          { "field": "Analysis", "description": "Generalization of continuous functions" },
          { "field": "Algebraic Geometry", "description": "Definition of manifolds" },
          { "field": "Quantum Mechanics", "description": "Hilbert spaces" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sets", "real-analysis"],
      "nextTopics": ["continuity-topology", "compactness"],
      "related": ["metric-space"]
    },
    "tags": ["위상공간", "열린집합", "topological space", "open set"]
  },
  {
    "id": "continuity-topology",
    "name": { "ko": "연속성 (위상적)", "en": "Continuity (Topological)" },
    "field": "topology",
    "subfield": "general-topology",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "위상공간 사이의 함수 f: X → Y가 연속이라는 것은 Y의 모든 열린집합의 역상이 X에서 열린집합인 것입니다.",
        "formulas": [
          {
            "latex": "f^{-1}(V) \\in \\tau_X \\text{ for all } V \\in \\tau_Y",
            "description": "연속의 위상적 정의"
          }
        ],
        "examples": [
          {
            "problem": "상수함수가 연속임을 보이세요.",
            "solution": "f(x) = c일 때, 열린집합 V의 역상은 c ∈ V이면 X 전체, c ∉ V이면 공집합입니다. 둘 다 열린집합입니다."
          }
        ],
        "applications": [
          { "field": "해석학", "description": "ε-δ 연속성의 일반화" },
          { "field": "위상적 성질", "description": "연속 변환 하에서 보존되는 성질" }
        ]
      },
      "en": {
        "definition": "A function f: X → Y between topological spaces is continuous if the preimage of every open set in Y is open in X.",
        "formulas": [
          {
            "latex": "f^{-1}(V) \\in \\tau_X \\text{ for all } V \\in \\tau_Y",
            "description": "Topological definition of continuity"
          }
        ],
        "examples": [
          {
            "problem": "Show that constant functions are continuous.",
            "solution": "For f(x) = c, preimage of open V is X if c ∈ V, or ∅ if c ∉ V. Both are open."
          }
        ],
        "applications": [
          { "field": "Analysis", "description": "Generalization of ε-δ continuity" },
          {
            "field": "Topological Properties",
            "description": "Properties preserved under continuous maps"
          }
        ]
      }
    },
    "relations": {
      "prerequisites": ["topological-space", "function"],
      "nextTopics": ["homeomorphism", "compactness"],
      "related": ["limits"]
    },
    "tags": ["연속", "위상", "continuity", "topology"]
  },
  {
    "id": "homeomorphism",
    "name": { "ko": "위상동형사상", "en": "Homeomorphism" },
    "field": "topology",
    "subfield": "general-topology",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "위상동형사상은 연속이고 역함수도 연속인 전단사 함수입니다. 위상동형인 공간은 위상적으로 같은 것으로 봅니다.",
        "formulas": [
          {
            "latex": "f: X \\to Y \\text{ homeomorphism} \\Leftrightarrow f, f^{-1} \\text{ continuous bijection}",
            "description": "위상동형사상의 정의"
          }
        ],
        "examples": [
          {
            "problem": "구와 정육면체가 위상동형임을 설명하세요.",
            "solution": "구를 연속적으로 변형하여 정육면체로 만들 수 있습니다(자르거나 붙이지 않고). 둘 다 종수 0인 닫힌 곡면입니다."
          },
          {
            "problem": "원과 직선이 위상동형이 아님을 설명하세요.",
            "solution": "원에서 한 점을 제거하면 연결되지만, 직선에서 한 점을 제거하면 두 조각으로 나뉩니다."
          }
        ],
        "applications": [
          { "field": "분류 문제", "description": "위상공간의 분류" },
          { "field": "물리학", "description": "상전이, 위상적 결함" }
        ]
      },
      "en": {
        "definition": "A homeomorphism is a continuous bijection with a continuous inverse. Homeomorphic spaces are topologically identical.",
        "formulas": [
          {
            "latex": "f: X \\to Y \\text{ homeomorphism} \\Leftrightarrow f, f^{-1} \\text{ continuous bijection}",
            "description": "Definition of homeomorphism"
          }
        ],
        "examples": [
          {
            "problem": "Explain why a sphere and cube are homeomorphic.",
            "solution": "A sphere can be continuously deformed into a cube (without cutting or gluing). Both are closed surfaces of genus 0."
          },
          {
            "problem": "Explain why a circle and line are not homeomorphic.",
            "solution": "Removing a point from a circle leaves it connected, but removing a point from a line disconnects it."
          }
        ],
        "applications": [
          { "field": "Classification", "description": "Classification of spaces" },
          { "field": "Physics", "description": "Phase transitions, topological defects" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["continuity-topology", "bijection"],
      "nextTopics": ["fundamental-group", "manifolds"],
      "related": ["isomorphism"]
    },
    "tags": ["위상동형", "연속", "homeomorphism", "topology"]
  },
  {
    "id": "compactness",
    "name": { "ko": "컴팩트성", "en": "Compactness" },
    "field": "topology",
    "subfield": "general-topology",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "위상공간이 컴팩트하다는 것은 모든 열린 덮개가 유한 부분덮개를 가진다는 것입니다. ℝⁿ에서는 닫혀 있고 유계인 것과 동치입니다.",
        "formulas": [
          {
            "latex": "X = \\bigcup_{\\alpha} U_\\alpha \\Rightarrow X = \\bigcup_{i=1}^{n} U_{\\alpha_i}",
            "description": "컴팩트성의 정의"
          }
        ],
        "examples": [
          {
            "problem": "[0, 1]이 컴팩트함을 하이네-보렐 정리로 설명하세요.",
            "solution": "[0, 1]은 닫혀 있고 유계이므로 하이네-보렐 정리에 의해 컴팩트합니다."
          },
          {
            "problem": "(0, 1)이 컴팩트하지 않음을 보이세요.",
            "solution": "열린 덮개 {(1/n, 1) : n ≥ 2}는 유한 부분덮개가 없습니다."
          }
        ],
        "applications": [
          { "field": "해석학", "description": "연속함수의 최대최소 존재" },
          { "field": "함수해석학", "description": "컴팩트 연산자" }
        ]
      },
      "en": {
        "definition": "A space is compact if every open cover has a finite subcover. In ℝⁿ, this is equivalent to being closed and bounded.",
        "formulas": [
          {
            "latex": "X = \\bigcup_{\\alpha} U_\\alpha \\Rightarrow X = \\bigcup_{i=1}^{n} U_{\\alpha_i}",
            "description": "Definition of compactness"
          }
        ],
        "examples": [
          {
            "problem": "Explain why [0, 1] is compact using Heine-Borel.",
            "solution": "[0, 1] is closed and bounded, so by Heine-Borel theorem it's compact."
          },
          {
            "problem": "Show (0, 1) is not compact.",
            "solution": "The open cover {(1/n, 1) : n ≥ 2} has no finite subcover."
          }
        ],
        "applications": [
          { "field": "Analysis", "description": "Existence of max/min of continuous functions" },
          { "field": "Functional Analysis", "description": "Compact operators" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["topological-space"],
      "nextTopics": ["heine-borel", "sequential-compactness"],
      "related": ["completeness"]
    },
    "tags": ["컴팩트", "열린덮개", "compact", "open cover"]
  },
  {
    "id": "connectedness",
    "name": { "ko": "연결성", "en": "Connectedness" },
    "field": "topology",
    "subfield": "general-topology",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "위상공간이 연결되었다는 것은 두 개의 서로소인 비어있지 않은 열린집합으로 분리될 수 없다는 것입니다.",
        "formulas": [
          {
            "latex": "X \\neq U \\cup V \\text{ for disjoint nonempty open } U, V",
            "description": "연결성의 정의"
          }
        ],
        "examples": [
          {
            "problem": "실수 직선 ℝ이 연결됨을 설명하세요.",
            "solution": "ℝ을 두 서로소 열린집합으로 나눌 수 없습니다. 중간값 정리가 이를 보장합니다."
          },
          {
            "problem": "ℚ (유리수)가 연결되지 않음을 보이세요.",
            "solution": "ℚ = (ℚ ∩ (-∞, √2)) ∪ (ℚ ∩ (√2, ∞))로 나뉩니다."
          }
        ],
        "applications": [
          { "field": "해석학", "description": "중간값 정리" },
          { "field": "그래프 이론", "description": "연결 그래프" }
        ]
      },
      "en": {
        "definition": "A topological space is connected if it cannot be separated into two disjoint nonempty open sets.",
        "formulas": [
          {
            "latex": "X \\neq U \\cup V \\text{ for disjoint nonempty open } U, V",
            "description": "Definition of connectedness"
          }
        ],
        "examples": [
          {
            "problem": "Explain why ℝ is connected.",
            "solution": "ℝ cannot be split into two disjoint open sets. The intermediate value theorem ensures this."
          },
          {
            "problem": "Show ℚ is not connected.",
            "solution": "ℚ = (ℚ ∩ (-∞, √2)) ∪ (ℚ ∩ (√2, ∞)) gives a separation."
          }
        ],
        "applications": [
          { "field": "Analysis", "description": "Intermediate value theorem" },
          { "field": "Graph Theory", "description": "Connected graphs" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["topological-space"],
      "nextTopics": ["path-connectedness", "components"],
      "related": ["intermediate-value-theorem"]
    },
    "tags": ["연결", "위상", "connected", "topology"]
  },
  {
    "id": "euler-characteristic",
    "name": { "ko": "오일러 지표", "en": "Euler Characteristic" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "오일러 지표는 위상공간의 위상불변량으로, 다면체의 경우 꼭짓점 - 모서리 + 면으로 계산됩니다.",
        "formulas": [
          { "latex": "\\chi = V - E + F", "description": "다면체의 오일러 공식" },
          {
            "latex": "\\chi(S^2) = 2, \\quad \\chi(T^2) = 0",
            "description": "구와 토러스의 오일러 지표"
          },
          { "latex": "\\chi = 2 - 2g", "description": "종수 g인 곡면의 오일러 지표" }
        ],
        "examples": [
          {
            "problem": "정육면체의 오일러 지표를 계산하세요.",
            "solution": "V=8, E=12, F=6이므로 χ = 8 - 12 + 6 = 2"
          },
          {
            "problem": "도넛(토러스)의 오일러 지표는?",
            "solution": "토러스는 종수 1이므로 χ = 2 - 2(1) = 0"
          }
        ],
        "history": {
          "discoveredBy": "레온하르트 오일러",
          "year": "1752년",
          "background": "오일러가 다면체에 대해 V - E + F = 2를 발견했습니다."
        },
        "applications": [
          { "field": "기하학", "description": "곡면 분류" },
          { "field": "컴퓨터 그래픽스", "description": "메시 검증" },
          { "field": "분자화학", "description": "분자 구조 분석" }
        ]
      },
      "en": {
        "definition": "The Euler characteristic is a topological invariant, calculated for polyhedra as vertices - edges + faces.",
        "formulas": [
          { "latex": "\\chi = V - E + F", "description": "Euler's formula for polyhedra" },
          {
            "latex": "\\chi(S^2) = 2, \\quad \\chi(T^2) = 0",
            "description": "Euler characteristic of sphere and torus"
          },
          { "latex": "\\chi = 2 - 2g", "description": "Euler characteristic of genus g surface" }
        ],
        "examples": [
          {
            "problem": "Calculate the Euler characteristic of a cube.",
            "solution": "V=8, E=12, F=6, so χ = 8 - 12 + 6 = 2"
          },
          {
            "problem": "What is the Euler characteristic of a torus?",
            "solution": "A torus has genus 1, so χ = 2 - 2(1) = 0"
          }
        ],
        "history": {
          "discoveredBy": "Leonhard Euler",
          "year": "1752",
          "background": "Euler discovered V - E + F = 2 for polyhedra."
        },
        "applications": [
          { "field": "Geometry", "description": "Surface classification" },
          { "field": "Computer Graphics", "description": "Mesh validation" },
          { "field": "Chemistry", "description": "Molecular structure analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["graph-theory"],
      "nextTopics": ["genus", "homology"],
      "related": ["polyhedra"]
    },
    "tags": ["오일러", "위상불변량", "Euler", "characteristic"]
  },
  {
    "id": "metric-space",
    "name": { "ko": "거리공간", "en": "Metric Space" },
    "field": "topology",
    "subfield": "general-topology",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "거리공간은 두 점 사이의 거리를 정의하는 함수(거리함수)가 주어진 집합입니다. 위상공간의 특별한 경우입니다.",
        "formulas": [
          {
            "latex": "d(x, y) \\geq 0, \\quad d(x,y) = 0 \\Leftrightarrow x = y",
            "description": "비음수성과 항등성"
          },
          { "latex": "d(x, y) = d(y, x)", "description": "대칭성" },
          { "latex": "d(x, z) \\leq d(x, y) + d(y, z)", "description": "삼각 부등식" }
        ],
        "examples": [
          {
            "problem": "ℝ²에서 유클리드 거리를 정의하세요.",
            "solution": "d((x₁,y₁), (x₂,y₂)) = √((x₂-x₁)² + (y₂-y₁)²). 피타고라스 정리에 기반합니다."
          },
          {
            "problem": "맨해튼 거리(택시 거리)를 정의하세요.",
            "solution": "d((x₁,y₁), (x₂,y₂)) = |x₂-x₁| + |y₂-y₁|. 격자 위를 따라 이동하는 거리입니다."
          }
        ],
        "applications": [
          { "field": "해석학", "description": "수렴, 연속성, 완비성" },
          { "field": "기계학습", "description": "클러스터링, k-NN" },
          { "field": "최적화", "description": "거리 기반 알고리즘" }
        ]
      },
      "en": {
        "definition": "A metric space is a set equipped with a distance function (metric) between points. It's a special case of topological spaces.",
        "formulas": [
          {
            "latex": "d(x, y) \\geq 0, \\quad d(x,y) = 0 \\Leftrightarrow x = y",
            "description": "Non-negativity and identity"
          },
          { "latex": "d(x, y) = d(y, x)", "description": "Symmetry" },
          { "latex": "d(x, z) \\leq d(x, y) + d(y, z)", "description": "Triangle inequality" }
        ],
        "examples": [
          {
            "problem": "Define Euclidean distance in ℝ².",
            "solution": "d((x₁,y₁), (x₂,y₂)) = √((x₂-x₁)² + (y₂-y₁)²). Based on Pythagorean theorem."
          },
          {
            "problem": "Define Manhattan (taxicab) distance.",
            "solution": "d((x₁,y₁), (x₂,y₂)) = |x₂-x₁| + |y₂-y₁|. Distance along grid lines."
          }
        ],
        "applications": [
          { "field": "Analysis", "description": "Convergence, continuity, completeness" },
          { "field": "Machine Learning", "description": "Clustering, k-NN" },
          { "field": "Optimization", "description": "Distance-based algorithms" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["real-numbers", "functions"],
      "nextTopics": ["topological-space", "completeness"],
      "related": ["norm"]
    },
    "tags": ["거리공간", "거리함수", "metric space", "distance"]
  },
  {
    "id": "manifold",
    "name": { "ko": "다양체", "en": "Manifold" },
    "field": "topology",
    "subfield": "differential-topology",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "다양체는 국소적으로 유클리드 공간과 닮은 위상공간입니다. 미분다양체는 부드러운 구조를 추가로 가집니다.",
        "formulas": [
          {
            "latex": "\\forall p \\in M, \\exists U \\ni p : U \\cong \\mathbb{R}^n",
            "description": "국소 유클리드 성질"
          },
          {
            "latex": "\\phi_\\beta \\circ \\phi_\\alpha^{-1} : \\mathbb{R}^n \\to \\mathbb{R}^n",
            "description": "전이 함수 (미분동형)"
          }
        ],
        "examples": [
          {
            "problem": "구면 S²가 2차원 다양체임을 설명하세요.",
            "solution": "구면의 각 점은 작은 조각을 취하면 평면과 위상동형입니다. 남극/북극을 제외한 부분은 평면에 사영됩니다."
          },
          {
            "problem": "토러스(도넛)의 차원은?",
            "solution": "토러스는 2차원 다양체입니다. S¹ × S¹로 표현되며 각 점 근방이 ℝ²와 닮았습니다."
          }
        ],
        "history": {
          "discoveredBy": "베른하르트 리만",
          "year": "1854년",
          "background": "리만이 일반 n차원 공간의 개념을 도입하며 다양체 이론의 기초를 놓았습니다."
        },
        "applications": [
          { "field": "일반상대성이론", "description": "시공간의 기하학" },
          { "field": "기계학습", "description": "다양체 학습, 차원 축소" },
          { "field": "로봇공학", "description": "구성 공간" }
        ]
      },
      "en": {
        "definition": "A manifold is a topological space locally resembling Euclidean space. Smooth manifolds additionally have differentiable structure.",
        "formulas": [
          {
            "latex": "\\forall p \\in M, \\exists U \\ni p : U \\cong \\mathbb{R}^n",
            "description": "Locally Euclidean property"
          },
          {
            "latex": "\\phi_\\beta \\circ \\phi_\\alpha^{-1} : \\mathbb{R}^n \\to \\mathbb{R}^n",
            "description": "Transition functions (diffeomorphism)"
          }
        ],
        "examples": [
          {
            "problem": "Explain why sphere S² is a 2-manifold.",
            "solution": "Each point on a sphere has a neighborhood homeomorphic to a plane. Parts excluding poles can be projected to plane."
          },
          {
            "problem": "What is the dimension of a torus?",
            "solution": "Torus is a 2-manifold. Expressed as S¹ × S¹, each point has neighborhood resembling ℝ²."
          }
        ],
        "history": {
          "discoveredBy": "Bernhard Riemann",
          "year": "1854",
          "background": "Riemann laid foundations of manifold theory by introducing general n-dimensional spaces."
        },
        "applications": [
          { "field": "General Relativity", "description": "Geometry of spacetime" },
          {
            "field": "Machine Learning",
            "description": "Manifold learning, dimensionality reduction"
          },
          { "field": "Robotics", "description": "Configuration spaces" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["topological-space", "differentiability"],
      "nextTopics": ["tangent-space", "riemannian-geometry"],
      "related": ["homeomorphism"]
    },
    "tags": ["다양체", "리만", "manifold", "Riemann"]
  },
  {
    "id": "fundamental-group",
    "name": { "ko": "기본군", "en": "Fundamental Group" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "기본군 π₁(X)는 공간 X의 점에서 시작하고 끝나는 루프(닫힌 경로)들의 호모토피 동치류로 이루어진 군입니다.",
        "formulas": [
          {
            "latex": "\\pi_1(X, x_0) = \\{[\\gamma] : \\gamma(0) = \\gamma(1) = x_0\\}",
            "description": "기본군의 정의"
          },
          { "latex": "\\pi_1(S^1) \\cong \\mathbb{Z}", "description": "원의 기본군" },
          {
            "latex": "\\pi_1(S^n) = 0 \\text{ for } n \\geq 2",
            "description": "고차원 구의 기본군"
          }
        ],
        "examples": [
          {
            "problem": "평면에서 한 점을 뺀 공간의 기본군은?",
            "solution": "ℝ² - {0}의 기본군은 ℤ입니다. 원점을 몇 번 감는지가 루프를 분류합니다."
          },
          {
            "problem": "토러스의 기본군은?",
            "solution": "π₁(T²) ≅ ℤ × ℤ. 두 개의 독립적인 루프(가로, 세로)가 있습니다."
          }
        ],
        "history": {
          "discoveredBy": "앙리 푸앵카레",
          "year": "1895년",
          "background": "푸앵카레가 대수적 위상수학을 창시하며 기본군 개념을 도입했습니다."
        },
        "applications": [
          { "field": "위상수학", "description": "공간 분류" },
          { "field": "물리학", "description": "양자장론, 위상적 결함" },
          { "field": "로봇공학", "description": "경로 계획" }
        ]
      },
      "en": {
        "definition": "The fundamental group π₁(X) consists of homotopy equivalence classes of loops (closed paths) starting and ending at a point in space X.",
        "formulas": [
          {
            "latex": "\\pi_1(X, x_0) = \\{[\\gamma] : \\gamma(0) = \\gamma(1) = x_0\\}",
            "description": "Definition of fundamental group"
          },
          {
            "latex": "\\pi_1(S^1) \\cong \\mathbb{Z}",
            "description": "Fundamental group of circle"
          },
          {
            "latex": "\\pi_1(S^n) = 0 \\text{ for } n \\geq 2",
            "description": "Fundamental group of higher spheres"
          }
        ],
        "examples": [
          {
            "problem": "What is the fundamental group of plane minus a point?",
            "solution": "π₁(ℝ² - {0}) ≅ ℤ. Loops are classified by winding number around origin."
          },
          {
            "problem": "What is the fundamental group of a torus?",
            "solution": "π₁(T²) ≅ ℤ × ℤ. Two independent loops (horizontal, vertical)."
          }
        ],
        "history": {
          "discoveredBy": "Henri Poincaré",
          "year": "1895",
          "background": "Poincaré introduced fundamental groups while founding algebraic topology."
        },
        "applications": [
          { "field": "Topology", "description": "Space classification" },
          { "field": "Physics", "description": "Quantum field theory, topological defects" },
          { "field": "Robotics", "description": "Path planning" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["topological-space", "group-theory"],
      "nextTopics": ["covering-spaces", "homology"],
      "related": ["homotopy"]
    },
    "tags": ["기본군", "푸앵카레", "fundamental group", "homotopy"]
  },
  {
    "id": "homotopy",
    "name": { "ko": "호모토피", "en": "Homotopy" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "호모토피는 두 연속함수 사이의 연속적인 변형입니다. 호모토피 동치인 공간은 위상적으로 '같은 모양'입니다.",
        "formulas": [
          {
            "latex": "H: X \\times [0,1] \\to Y, \\quad H(x,0) = f(x), H(x,1) = g(x)",
            "description": "호모토피의 정의"
          },
          { "latex": "f \\simeq g", "description": "f와 g가 호모토픽 (호모토피로 연결)" },
          {
            "latex": "X \\simeq Y \\Leftrightarrow \\exists f: X \\to Y, g: Y \\to X : g \\circ f \\simeq id_X, f \\circ g \\simeq id_Y",
            "description": "호모토피 동치"
          }
        ],
        "examples": [
          {
            "problem": "원판 D²과 한 점이 호모토피 동치임을 설명하세요.",
            "solution": "원판을 연속적으로 수축하여 중심 한 점으로 만들 수 있습니다. H(x,t) = (1-t)x가 호모토피입니다."
          },
          {
            "problem": "커피잔과 도넛이 호모토피 동치인 이유는?",
            "solution": "둘 다 하나의 구멍이 있습니다. 연속적으로 변형하여 서로 만들 수 있습니다."
          }
        ],
        "applications": [
          { "field": "위상수학", "description": "공간 분류, 불변량" },
          { "field": "대수기하학", "description": "호모토피 대수" },
          { "field": "컴퓨터 과학", "description": "호모토피 타입 이론" }
        ]
      },
      "en": {
        "definition": "Homotopy is a continuous deformation between two continuous functions. Homotopy equivalent spaces have the 'same shape' topologically.",
        "formulas": [
          {
            "latex": "H: X \\times [0,1] \\to Y, \\quad H(x,0) = f(x), H(x,1) = g(x)",
            "description": "Definition of homotopy"
          },
          { "latex": "f \\simeq g", "description": "f and g are homotopic" },
          {
            "latex": "X \\simeq Y \\Leftrightarrow \\exists f: X \\to Y, g: Y \\to X : g \\circ f \\simeq id_X, f \\circ g \\simeq id_Y",
            "description": "Homotopy equivalence"
          }
        ],
        "examples": [
          {
            "problem": "Explain why disk D² is homotopy equivalent to a point.",
            "solution": "Disk can be continuously shrunk to its center point. H(x,t) = (1-t)x is the homotopy."
          },
          {
            "problem": "Why are coffee cup and donut homotopy equivalent?",
            "solution": "Both have exactly one hole. Can be continuously deformed into each other."
          }
        ],
        "applications": [
          { "field": "Topology", "description": "Space classification, invariants" },
          { "field": "Algebraic Geometry", "description": "Homotopy algebra" },
          { "field": "Computer Science", "description": "Homotopy type theory" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["continuity-topology", "topological-space"],
      "nextTopics": ["fundamental-group", "higher-homotopy-groups"],
      "related": ["homeomorphism"]
    },
    "tags": ["호모토피", "변형", "homotopy", "deformation"]
  },
  {
    "id": "propositional-logic",
    "name": { "ko": "명제 논리", "en": "Propositional Logic" },
    "field": "logic",
    "subfield": "propositional",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "명제 논리는 참 또는 거짓 값을 가지는 명제들과 논리 연결사(AND, OR, NOT 등)를 다루는 형식 체계입니다.",
        "formulas": [
          { "latex": "\\neg p", "description": "부정 (NOT)" },
          { "latex": "p \\land q", "description": "논리곱 (AND)" },
          { "latex": "p \\lor q", "description": "논리합 (OR)" },
          { "latex": "p \\to q \\equiv \\neg p \\lor q", "description": "조건문 (IF-THEN)" },
          {
            "latex": "p \\leftrightarrow q \\equiv (p \\to q) \\land (q \\to p)",
            "description": "쌍조건문 (IFF)"
          }
        ],
        "examples": [
          {
            "problem": "p = '비가 온다', q = '땅이 젖는다'일 때 p → q의 의미는?",
            "solution": "'비가 오면 땅이 젖는다'. 비가 오지 않으면 결과와 관계없이 참입니다."
          }
        ],
        "applications": [
          { "field": "컴퓨터 과학", "description": "불리언 대수, 회로 설계" },
          { "field": "수학", "description": "증명 기초" },
          { "field": "AI", "description": "지식 표현" }
        ]
      },
      "en": {
        "definition": "Propositional logic is a formal system dealing with propositions (true/false) and logical connectives (AND, OR, NOT, etc.).",
        "formulas": [
          { "latex": "\\neg p", "description": "Negation (NOT)" },
          { "latex": "p \\land q", "description": "Conjunction (AND)" },
          { "latex": "p \\lor q", "description": "Disjunction (OR)" },
          { "latex": "p \\to q \\equiv \\neg p \\lor q", "description": "Implication (IF-THEN)" },
          {
            "latex": "p \\leftrightarrow q \\equiv (p \\to q) \\land (q \\to p)",
            "description": "Biconditional (IFF)"
          }
        ],
        "examples": [
          {
            "problem": "If p = 'It rains', q = 'Ground is wet', what does p → q mean?",
            "solution": "'If it rains, the ground is wet'. True when it doesn't rain regardless of q."
          }
        ],
        "applications": [
          { "field": "Computer Science", "description": "Boolean algebra, circuit design" },
          { "field": "Mathematics", "description": "Proof foundations" },
          { "field": "AI", "description": "Knowledge representation" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["predicate-logic", "boolean-algebra"],
      "related": ["sets"]
    },
    "tags": ["명제", "논리", "propositional", "logic"]
  },
  {
    "id": "predicate-logic",
    "name": { "ko": "술어 논리", "en": "Predicate Logic" },
    "field": "logic",
    "subfield": "predicate",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "술어 논리(1차 논리)는 명제 논리를 확장하여 변수, 양화사(∀, ∃), 술어를 포함합니다. 수학적 명제를 정확히 표현할 수 있습니다.",
        "formulas": [
          { "latex": "\\forall x \\, P(x)", "description": "전칭 양화사 (모든 x에 대해)" },
          { "latex": "\\exists x \\, P(x)", "description": "존재 양화사 (어떤 x가 존재하여)" },
          {
            "latex": "\\neg (\\forall x \\, P(x)) \\equiv \\exists x \\, \\neg P(x)",
            "description": "양화사 부정"
          }
        ],
        "examples": [
          {
            "problem": "'모든 인간은 죽는다'를 술어 논리로 표현하세요.",
            "solution": "∀x (Human(x) → Mortal(x))"
          },
          {
            "problem": "'모든 자연수에는 더 큰 소수가 있다'를 표현하세요.",
            "solution": "∀n ∃p (Prime(p) ∧ p > n)"
          }
        ],
        "applications": [
          { "field": "수학", "description": "공리계, 정리 증명" },
          { "field": "AI", "description": "자동 정리 증명, 지식 베이스" },
          { "field": "데이터베이스", "description": "SQL 쿼리의 이론적 기반" }
        ]
      },
      "en": {
        "definition": "Predicate logic (first-order logic) extends propositional logic with variables, quantifiers (∀, ∃), and predicates. It can express mathematical statements precisely.",
        "formulas": [
          { "latex": "\\forall x \\, P(x)", "description": "Universal quantifier (for all x)" },
          {
            "latex": "\\exists x \\, P(x)",
            "description": "Existential quantifier (there exists x)"
          },
          {
            "latex": "\\neg (\\forall x \\, P(x)) \\equiv \\exists x \\, \\neg P(x)",
            "description": "Quantifier negation"
          }
        ],
        "examples": [
          {
            "problem": "Express 'All humans are mortal' in predicate logic.",
            "solution": "∀x (Human(x) → Mortal(x))"
          },
          {
            "problem": "Express 'For every natural number, there's a larger prime'.",
            "solution": "∀n ∃p (Prime(p) ∧ p > n)"
          }
        ],
        "applications": [
          { "field": "Mathematics", "description": "Axiomatic systems, theorem proving" },
          { "field": "AI", "description": "Automated theorem proving, knowledge bases" },
          { "field": "Databases", "description": "Theoretical foundation of SQL" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["propositional-logic"],
      "nextTopics": ["proof-theory", "model-theory"],
      "related": ["sets"]
    },
    "tags": ["술어", "양화사", "predicate", "quantifier"]
  },
  {
    "id": "proof-methods",
    "name": { "ko": "증명 방법", "en": "Proof Methods" },
    "field": "logic",
    "subfield": "proof-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수학적 증명은 공리와 이미 증명된 정리로부터 논리적으로 결론을 도출하는 과정입니다. 직접 증명, 귀류법, 수학적 귀납법 등이 있습니다.",
        "formulas": [
          { "latex": "P \\to Q \\text{ (직접 증명)}", "description": "P가 참이면 Q가 참임을 보임" },
          {
            "latex": "\\neg Q \\to \\neg P \\text{ (대우 증명)}",
            "description": "Q의 부정에서 P의 부정을 도출"
          },
          {
            "latex": "\\neg P \\to \\text{모순} \\Rightarrow P \\text{ (귀류법)}",
            "description": "P의 부정이 모순을 유도하면 P는 참"
          }
        ],
        "examples": [
          {
            "problem": "√2가 무리수임을 귀류법으로 증명하세요.",
            "solution": "√2 = a/b (기약분수)라 가정. 2 = a²/b²이므로 a² = 2b². a는 짝수, a = 2k라 하면 4k² = 2b², b² = 2k². b도 짝수. 이는 기약분수 가정에 모순."
          }
        ],
        "applications": [
          { "field": "수학", "description": "정리 증명" },
          { "field": "컴퓨터 과학", "description": "알고리즘 정확성 증명" },
          { "field": "형식 검증", "description": "소프트웨어 검증" }
        ]
      },
      "en": {
        "definition": "Mathematical proof is the process of deriving conclusions logically from axioms and proven theorems. Methods include direct proof, contradiction, and induction.",
        "formulas": [
          {
            "latex": "P \\to Q \\text{ (direct proof)}",
            "description": "Assume P true, show Q true"
          },
          {
            "latex": "\\neg Q \\to \\neg P \\text{ (contrapositive)}",
            "description": "Derive ¬P from ¬Q"
          },
          {
            "latex": "\\neg P \\to \\text{contradiction} \\Rightarrow P \\text{ (proof by contradiction)}",
            "description": "If ¬P leads to contradiction, P is true"
          }
        ],
        "examples": [
          {
            "problem": "Prove √2 is irrational by contradiction.",
            "solution": "Assume √2 = a/b in lowest terms. 2 = a²/b², so a² = 2b². a is even, let a = 2k. Then 4k² = 2b², b² = 2k². b is also even. Contradicts lowest terms."
          }
        ],
        "applications": [
          { "field": "Mathematics", "description": "Theorem proving" },
          { "field": "Computer Science", "description": "Algorithm correctness" },
          { "field": "Formal Verification", "description": "Software verification" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["propositional-logic"],
      "nextTopics": ["mathematical-induction"],
      "related": ["sets"]
    },
    "tags": ["증명", "귀류법", "proof", "contradiction"]
  },
  {
    "id": "mathematical-induction",
    "name": { "ko": "수학적 귀납법", "en": "Mathematical Induction" },
    "field": "logic",
    "subfield": "proof-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수학적 귀납법은 자연수에 대한 명제를 증명하는 방법입니다. 기초 단계(n=1)와 귀납 단계(n=k → n=k+1)로 구성됩니다.",
        "formulas": [
          {
            "latex": "P(1) \\land (\\forall k \\, (P(k) \\to P(k+1))) \\Rightarrow \\forall n \\, P(n)",
            "description": "수학적 귀납법의 원리"
          }
        ],
        "examples": [
          {
            "problem": "1 + 2 + ... + n = n(n+1)/2임을 귀납법으로 증명하세요.",
            "solution": "기초: n=1일 때 1 = 1×2/2 ✓. 귀납: 1+...+k = k(k+1)/2 가정. 1+...+k+(k+1) = k(k+1)/2 + (k+1) = (k+1)(k+2)/2 ✓"
          }
        ],
        "history": {
          "discoveredBy": "파스칼, 페르마",
          "year": "17세기",
          "background": "귀납법의 원리는 자연수의 정의에 내재되어 있으며, 명시적으로 사용된 것은 17세기부터입니다."
        },
        "applications": [
          { "field": "수학", "description": "급수 공식, 부등식 증명" },
          { "field": "컴퓨터 과학", "description": "재귀 알고리즘 분석" },
          { "field": "형식 언어", "description": "문법 성질 증명" }
        ]
      },
      "en": {
        "definition": "Mathematical induction proves statements about natural numbers. It consists of base case (n=1) and inductive step (n=k → n=k+1).",
        "formulas": [
          {
            "latex": "P(1) \\land (\\forall k \\, (P(k) \\to P(k+1))) \\Rightarrow \\forall n \\, P(n)",
            "description": "Principle of mathematical induction"
          }
        ],
        "examples": [
          {
            "problem": "Prove 1 + 2 + ... + n = n(n+1)/2 by induction.",
            "solution": "Base: n=1, 1 = 1×2/2 ✓. Inductive: Assume for k. Then 1+...+k+(k+1) = k(k+1)/2 + (k+1) = (k+1)(k+2)/2 ✓"
          }
        ],
        "history": {
          "discoveredBy": "Pascal, Fermat",
          "year": "17th century",
          "background": "The principle is inherent in natural number definition, explicitly used from 17th century."
        },
        "applications": [
          { "field": "Mathematics", "description": "Series formulas, inequality proofs" },
          { "field": "Computer Science", "description": "Recursive algorithm analysis" },
          { "field": "Formal Languages", "description": "Grammar property proofs" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["natural-numbers", "proof-methods"],
      "nextTopics": ["strong-induction", "structural-induction"],
      "related": ["recursion"]
    },
    "tags": ["귀납법", "증명", "induction", "proof"]
  },
  {
    "id": "godels-incompleteness",
    "name": { "ko": "괴델의 불완전성 정리", "en": "Gödel's Incompleteness Theorems" },
    "field": "logic",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "괴델의 불완전성 정리는 충분히 강력한 수학 체계에서는 증명도 반증도 할 수 없는 참인 명제가 존재함을 보여줍니다.",
        "formulas": [
          {
            "latex": "\\text{Con}(F) \\to \\exists G \\, (F \\nvdash G \\land F \\nvdash \\neg G)",
            "description": "제1 불완전성 정리 (비형식적)"
          },
          {
            "latex": "\\text{Con}(F) \\to F \\nvdash \\text{Con}(F)",
            "description": "제2 불완전성 정리"
          }
        ],
        "examples": [
          {
            "problem": "괴델 문장의 아이디어를 설명하세요.",
            "solution": "'이 문장은 증명될 수 없다'를 형식화. 만약 증명 가능하면 거짓인 것이 증명됨(모순). 증명 불가능하면 참이지만 증명 불가."
          }
        ],
        "history": {
          "discoveredBy": "쿠르트 괴델",
          "year": "1931년",
          "background": "힐베르트 프로그램에 대한 응답으로, 수학의 완전한 형식화가 불가능함을 보였습니다."
        },
        "applications": [
          { "field": "수학기초론", "description": "형식 체계의 한계" },
          { "field": "컴퓨터 과학", "description": "정지 문제, 계산가능성" },
          { "field": "철학", "description": "진리와 증명의 관계" }
        ]
      },
      "en": {
        "definition": "Gödel's incompleteness theorems show that in any sufficiently powerful mathematical system, there exist true statements that cannot be proved or disproved.",
        "formulas": [
          {
            "latex": "\\text{Con}(F) \\to \\exists G \\, (F \\nvdash G \\land F \\nvdash \\neg G)",
            "description": "First incompleteness theorem (informal)"
          },
          {
            "latex": "\\text{Con}(F) \\to F \\nvdash \\text{Con}(F)",
            "description": "Second incompleteness theorem"
          }
        ],
        "examples": [
          {
            "problem": "Explain the idea of Gödel sentence.",
            "solution": "Formalize 'This statement is unprovable'. If provable, proves a false statement (contradiction). If unprovable, it's true but unprovable."
          }
        ],
        "history": {
          "discoveredBy": "Kurt Gödel",
          "year": "1931",
          "background": "Response to Hilbert's program, showing complete formalization of mathematics is impossible."
        },
        "applications": [
          { "field": "Foundations", "description": "Limits of formal systems" },
          { "field": "Computer Science", "description": "Halting problem, computability" },
          { "field": "Philosophy", "description": "Truth vs. provability" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["predicate-logic", "proof-theory"],
      "nextTopics": ["computability"],
      "related": ["halting-problem"]
    },
    "tags": ["괴델", "불완전성", "Gödel", "incompleteness"]
  },
  {
    "id": "dynamical-systems",
    "name": { "ko": "동역학계", "en": "Dynamical Systems" },
    "field": "dynamics",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "동역학계는 시간에 따라 상태가 변화하는 시스템을 수학적으로 모델링한 것입니다. 미분방정식이나 차분방정식으로 표현됩니다.",
        "formulas": [
          { "latex": "\\frac{dx}{dt} = f(x)", "description": "연속 동역학계 (자율 시스템)" },
          { "latex": "x_{n+1} = f(x_n)", "description": "이산 동역학계" }
        ],
        "examples": [
          {
            "problem": "인구 성장 모델 dP/dt = rP를 풀이하세요.",
            "solution": "변수분리: dP/P = r dt, ln|P| = rt + C, P(t) = P₀e^(rt) (지수 성장)"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "행성 운동, 진자 운동" },
          { "field": "생물학", "description": "인구 동태, 생태계 모델" },
          { "field": "경제학", "description": "경기 순환, 시장 동역학" }
        ]
      },
      "en": {
        "definition": "A dynamical system mathematically models how states evolve over time. It's expressed through differential or difference equations.",
        "formulas": [
          {
            "latex": "\\frac{dx}{dt} = f(x)",
            "description": "Continuous dynamical system (autonomous)"
          },
          { "latex": "x_{n+1} = f(x_n)", "description": "Discrete dynamical system" }
        ],
        "examples": [
          {
            "problem": "Solve the population growth model dP/dt = rP.",
            "solution": "Separation: dP/P = r dt, ln|P| = rt + C, P(t) = P₀e^(rt) (exponential growth)"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Planetary motion, pendulum" },
          { "field": "Biology", "description": "Population dynamics, ecosystem models" },
          { "field": "Economics", "description": "Business cycles, market dynamics" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["differential-equations", "derivative"],
      "nextTopics": ["chaos-theory", "fixed-points"],
      "related": ["phase-space"]
    },
    "tags": ["동역학", "시스템", "dynamical", "system"]
  },
  {
    "id": "chaos-theory",
    "name": { "ko": "카오스 이론", "en": "Chaos Theory" },
    "field": "dynamics",
    "subfield": "chaos",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "카오스는 결정론적 시스템에서 나타나는 비예측적 행동입니다. 초기 조건에 극도로 민감하며(나비 효과), 장기 예측이 불가능합니다.",
        "formulas": [
          { "latex": "x_{n+1} = rx_n(1 - x_n)", "description": "로지스틱 맵 (카오스의 대표적 예)" },
          {
            "latex": "\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=0}^{n-1} \\ln|f'(x_i)|",
            "description": "리아푸노프 지수"
          }
        ],
        "examples": [
          {
            "problem": "r = 4인 로지스틱 맵이 카오스적임을 설명하세요.",
            "solution": "r = 4일 때 리아푸노프 지수가 양수(λ = ln 2)이며, 초기값의 작은 차이가 지수적으로 확대됩니다."
          }
        ],
        "history": {
          "discoveredBy": "에드워드 로렌츠",
          "year": "1963년",
          "background": "기상학자 로렌츠가 날씨 모델에서 초기조건 민감성을 발견하며 카오스 이론이 시작되었습니다."
        },
        "applications": [
          { "field": "기상학", "description": "날씨 예측의 한계" },
          { "field": "암호학", "description": "카오스 기반 암호" },
          { "field": "생태학", "description": "개체군 변동" }
        ]
      },
      "en": {
        "definition": "Chaos is unpredictable behavior in deterministic systems. It shows extreme sensitivity to initial conditions (butterfly effect), making long-term prediction impossible.",
        "formulas": [
          {
            "latex": "x_{n+1} = rx_n(1 - x_n)",
            "description": "Logistic map (classic chaos example)"
          },
          {
            "latex": "\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=0}^{n-1} \\ln|f'(x_i)|",
            "description": "Lyapunov exponent"
          }
        ],
        "examples": [
          {
            "problem": "Explain why logistic map with r = 4 is chaotic.",
            "solution": "At r = 4, Lyapunov exponent is positive (λ = ln 2), small differences in initial values grow exponentially."
          }
        ],
        "history": {
          "discoveredBy": "Edward Lorenz",
          "year": "1963",
          "background": "Meteorologist Lorenz discovered sensitivity to initial conditions in weather models, initiating chaos theory."
        },
        "applications": [
          { "field": "Meteorology", "description": "Weather prediction limits" },
          { "field": "Cryptography", "description": "Chaos-based encryption" },
          { "field": "Ecology", "description": "Population fluctuations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["dynamical-systems"],
      "nextTopics": ["fractals", "strange-attractors"],
      "related": ["butterfly-effect"]
    },
    "tags": ["카오스", "나비효과", "chaos", "butterfly effect"]
  },
  {
    "id": "fractals",
    "name": { "ko": "프랙탈", "en": "Fractals" },
    "field": "dynamics",
    "subfield": "fractals",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "프랙탈은 부분이 전체와 유사한 구조(자기유사성)를 가진 기하학적 도형입니다. 비정수 차원을 가질 수 있습니다.",
        "formulas": [
          {
            "latex": "D = \\frac{\\log N}{\\log s}",
            "description": "프랙탈 차원 (N: 조각 수, s: 배율)"
          },
          { "latex": "z_{n+1} = z_n^2 + c", "description": "만델브로 집합의 점화식" }
        ],
        "examples": [
          {
            "problem": "시에르핀스키 삼각형의 차원을 구하세요.",
            "solution": "매 단계 3조각, 배율 2. D = log(3)/log(2) ≈ 1.585"
          },
          {
            "problem": "코흐 눈송이의 차원은?",
            "solution": "매 단계 4조각, 배율 3. D = log(4)/log(3) ≈ 1.262"
          }
        ],
        "history": {
          "discoveredBy": "브누아 만델브로",
          "year": "1975년",
          "background": "만델브로가 '프랙탈'이라는 용어를 만들고 이 분야를 체계화했습니다."
        },
        "applications": [
          { "field": "컴퓨터 그래픽스", "description": "자연 지형 생성" },
          { "field": "생물학", "description": "혈관, 폐의 구조" },
          { "field": "안테나 설계", "description": "프랙탈 안테나" }
        ]
      },
      "en": {
        "definition": "Fractals are geometric shapes where parts resemble the whole (self-similarity). They can have non-integer dimensions.",
        "formulas": [
          {
            "latex": "D = \\frac{\\log N}{\\log s}",
            "description": "Fractal dimension (N: pieces, s: scale)"
          },
          { "latex": "z_{n+1} = z_n^2 + c", "description": "Mandelbrot set iteration" }
        ],
        "examples": [
          {
            "problem": "Find the dimension of Sierpinski triangle.",
            "solution": "Each step: 3 pieces, scale 2. D = log(3)/log(2) ≈ 1.585"
          },
          {
            "problem": "What is the dimension of Koch snowflake?",
            "solution": "Each step: 4 pieces, scale 3. D = log(4)/log(3) ≈ 1.262"
          }
        ],
        "history": {
          "discoveredBy": "Benoit Mandelbrot",
          "year": "1975",
          "background": "Mandelbrot coined the term 'fractal' and systematized the field."
        },
        "applications": [
          { "field": "Computer Graphics", "description": "Natural terrain generation" },
          { "field": "Biology", "description": "Blood vessels, lung structure" },
          { "field": "Antenna Design", "description": "Fractal antennas" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["complex-numbers", "iteration"],
      "nextTopics": ["mandelbrot-set", "julia-sets"],
      "related": ["self-similarity"]
    },
    "tags": ["프랙탈", "자기유사", "fractal", "self-similar"]
  },
  {
    "id": "fixed-points",
    "name": { "ko": "고정점과 안정성", "en": "Fixed Points and Stability" },
    "field": "dynamics",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "고정점은 동역학계에서 시간이 지나도 변하지 않는 상태입니다. 고정점은 안정(끌개), 불안정, 또는 안장점일 수 있습니다.",
        "formulas": [
          {
            "latex": "f(x^*) = x^* \\text{ (이산)}, \\quad f(x^*) = 0 \\text{ (연속)}",
            "description": "고정점의 조건"
          },
          {
            "latex": "|f'(x^*)| < 1 \\text{ : 안정}, \\quad |f'(x^*)| > 1 \\text{ : 불안정}",
            "description": "이산 시스템의 안정성"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x² - x - 1의 고정점과 안정성을 분석하세요.",
            "solution": "x = x² - x - 1에서 x² - 2x - 1 = 0, x = 1 ± √2. f'(x) = 2x - 1. |f'(1+√2)| = |1+2√2| > 1 (불안정), |f'(1-√2)| = |1-2√2| < 1 (안정)"
          }
        ],
        "applications": [
          { "field": "제어 이론", "description": "시스템 안정화" },
          { "field": "생태학", "description": "평형 개체군" },
          { "field": "경제학", "description": "시장 균형" }
        ]
      },
      "en": {
        "definition": "A fixed point is a state that doesn't change over time in a dynamical system. Fixed points can be stable (attractors), unstable, or saddle points.",
        "formulas": [
          {
            "latex": "f(x^*) = x^* \\text{ (discrete)}, \\quad f(x^*) = 0 \\text{ (continuous)}",
            "description": "Fixed point condition"
          },
          {
            "latex": "|f'(x^*)| < 1 \\text{ : stable}, \\quad |f'(x^*)| > 1 \\text{ : unstable}",
            "description": "Stability in discrete systems"
          }
        ],
        "examples": [
          {
            "problem": "Analyze fixed points and stability of f(x) = x² - x - 1.",
            "solution": "x = x² - x - 1 gives x² - 2x - 1 = 0, x = 1 ± √2. f'(x) = 2x - 1. |f'(1+√2)| = |1+2√2| > 1 (unstable), |f'(1-√2)| = |1-2√2| < 1 (stable)"
          }
        ],
        "applications": [
          { "field": "Control Theory", "description": "System stabilization" },
          { "field": "Ecology", "description": "Equilibrium populations" },
          { "field": "Economics", "description": "Market equilibrium" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "dynamical-systems"],
      "nextTopics": ["bifurcation", "attractors"],
      "related": ["equilibrium"]
    },
    "tags": ["고정점", "안정성", "fixed point", "stability"]
  },
  {
    "id": "bifurcation",
    "name": { "ko": "분기", "en": "Bifurcation" },
    "field": "dynamics",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "분기는 매개변수가 변할 때 동역학계의 질적 행동이 갑자기 변하는 현상입니다. 새로운 고정점이 생기거나 안정성이 바뀝니다.",
        "formulas": [
          { "latex": "x_{n+1} = rx_n(1-x_n)", "description": "로지스틱 맵 (r에 따라 분기)" }
        ],
        "examples": [
          {
            "problem": "로지스틱 맵의 분기 과정을 설명하세요.",
            "solution": "r < 1: 소멸, r = 1: 초월분기, 1 < r < 3: 하나의 안정점, r = 3: 주기배가 분기 시작, r ≈ 3.57: 카오스 시작"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "상전이" },
          { "field": "생태학", "description": "개체군 폭발/붕괴" },
          { "field": "공학", "description": "시스템 불안정 예측" }
        ]
      },
      "en": {
        "definition": "Bifurcation is when qualitative behavior of a dynamical system suddenly changes as a parameter varies. New fixed points may appear or stability may change.",
        "formulas": [
          { "latex": "x_{n+1} = rx_n(1-x_n)", "description": "Logistic map (bifurcates with r)" }
        ],
        "examples": [
          {
            "problem": "Describe the bifurcation process in logistic map.",
            "solution": "r < 1: extinction, r = 1: transcritical, 1 < r < 3: one stable point, r = 3: period doubling begins, r ≈ 3.57: chaos onset"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Phase transitions" },
          { "field": "Ecology", "description": "Population boom/crash" },
          { "field": "Engineering", "description": "System instability prediction" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["fixed-points", "dynamical-systems"],
      "nextTopics": ["chaos-theory"],
      "related": ["phase-transition"]
    },
    "tags": ["분기", "주기배가", "bifurcation", "period doubling"]
  },
  {
    "id": "ordinary-differential-equation",
    "name": { "ko": "상미분방정식", "en": "Ordinary Differential Equations" },
    "field": "dynamics",
    "subfield": "differential-equations",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "상미분방정식(ODE)은 하나의 독립변수에 대한 미지함수와 그 도함수 사이의 관계식입니다. 물리, 공학의 기본 언어입니다.",
        "formulas": [
          { "latex": "\\frac{dy}{dx} = f(x, y)", "description": "1차 ODE의 일반형" },
          { "latex": "y'' + p(x)y' + q(x)y = g(x)", "description": "2차 선형 ODE" },
          { "latex": "\\frac{d^n y}{dx^n} = F(x, y, y', ..., y^{(n-1)})", "description": "n차 ODE" }
        ],
        "examples": [
          { "problem": "dy/dx = 2x를 풀이하세요.", "solution": "양변을 적분: y = ∫2x dx = x² + C" },
          {
            "problem": "y' + y = 0을 풀이하세요.",
            "solution": "특성방정식: r + 1 = 0, r = -1. 일반해: y = Ce^(-x)"
          }
        ],
        "history": {
          "discoveredBy": "아이작 뉴턴, 라이프니츠",
          "year": "17세기",
          "background": "미적분학의 발명과 함께 물리 법칙을 수학적으로 표현하기 위해 발전했습니다."
        },
        "applications": [
          { "field": "물리학", "description": "뉴턴 역학, 전자기학" },
          { "field": "공학", "description": "회로, 제어 시스템" },
          { "field": "생물학", "description": "개체군 모델, 전염병" }
        ]
      },
      "en": {
        "definition": "An ordinary differential equation (ODE) relates an unknown function of one variable to its derivatives. It's the fundamental language of physics and engineering.",
        "formulas": [
          { "latex": "\\frac{dy}{dx} = f(x, y)", "description": "General form of first-order ODE" },
          { "latex": "y'' + p(x)y' + q(x)y = g(x)", "description": "Second-order linear ODE" },
          {
            "latex": "\\frac{d^n y}{dx^n} = F(x, y, y', ..., y^{(n-1)})",
            "description": "nth-order ODE"
          }
        ],
        "examples": [
          {
            "problem": "Solve dy/dx = 2x.",
            "solution": "Integrate both sides: y = ∫2x dx = x² + C"
          },
          {
            "problem": "Solve y' + y = 0.",
            "solution": "Characteristic equation: r + 1 = 0, r = -1. General solution: y = Ce^(-x)"
          }
        ],
        "history": {
          "discoveredBy": "Isaac Newton, Leibniz",
          "year": "17th century",
          "background": "Developed alongside calculus to mathematically express physical laws."
        },
        "applications": [
          { "field": "Physics", "description": "Newtonian mechanics, electromagnetism" },
          { "field": "Engineering", "description": "Circuits, control systems" },
          { "field": "Biology", "description": "Population models, epidemiology" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "integration"],
      "nextTopics": ["dynamical-systems", "numerical-ode"],
      "related": ["partial-differential-equation"]
    },
    "tags": ["미분방정식", "ODE", "differential equation", "ordinary"]
  },
  {
    "id": "partial-differential-equation",
    "name": { "ko": "편미분방정식", "en": "Partial Differential Equations" },
    "field": "dynamics",
    "subfield": "differential-equations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "편미분방정식(PDE)은 두 개 이상의 독립변수에 대한 미지함수의 편도함수를 포함하는 방정식입니다. 파동, 열전달, 양자역학 등을 기술합니다.",
        "formulas": [
          {
            "latex": "\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u",
            "description": "파동 방정식"
          },
          {
            "latex": "\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u",
            "description": "열 방정식 (확산 방정식)"
          },
          { "latex": "\\nabla^2 u = 0", "description": "라플라스 방정식" },
          {
            "latex": "i\\hbar \\frac{\\partial \\Psi}{\\partial t} = \\hat{H}\\Psi",
            "description": "슈뢰딩거 방정식"
          }
        ],
        "examples": [
          {
            "problem": "1차원 열 방정식의 물리적 의미를 설명하세요.",
            "solution": "∂u/∂t = α∂²u/∂x²는 온도 u가 시간에 따라 어떻게 변하는지를 나타냅니다. α는 열확산계수입니다."
          }
        ],
        "history": {
          "discoveredBy": "다니엘 베르누이, 달랑베르",
          "year": "18세기",
          "background": "현 진동과 열전도 문제를 해결하면서 PDE 이론이 발전했습니다."
        },
        "applications": [
          { "field": "물리학", "description": "파동, 열역학, 양자역학" },
          { "field": "공학", "description": "유체역학, 구조해석" },
          { "field": "금융", "description": "옵션 가격 결정 (블랙-숄즈)" }
        ]
      },
      "en": {
        "definition": "A partial differential equation (PDE) involves partial derivatives of an unknown function with respect to multiple independent variables. Describes waves, heat transfer, quantum mechanics.",
        "formulas": [
          {
            "latex": "\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u",
            "description": "Wave equation"
          },
          {
            "latex": "\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u",
            "description": "Heat equation (diffusion)"
          },
          { "latex": "\\nabla^2 u = 0", "description": "Laplace equation" },
          {
            "latex": "i\\hbar \\frac{\\partial \\Psi}{\\partial t} = \\hat{H}\\Psi",
            "description": "Schrödinger equation"
          }
        ],
        "examples": [
          {
            "problem": "Explain the physical meaning of 1D heat equation.",
            "solution": "∂u/∂t = α∂²u/∂x² describes how temperature u changes over time. α is thermal diffusivity."
          }
        ],
        "history": {
          "discoveredBy": "Daniel Bernoulli, d'Alembert",
          "year": "18th century",
          "background": "PDE theory developed while solving string vibration and heat conduction problems."
        },
        "applications": [
          { "field": "Physics", "description": "Waves, thermodynamics, quantum mechanics" },
          { "field": "Engineering", "description": "Fluid dynamics, structural analysis" },
          { "field": "Finance", "description": "Option pricing (Black-Scholes)" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["partial-derivative", "ordinary-differential-equation"],
      "nextTopics": ["fourier-series", "finite-element"],
      "related": ["laplacian"]
    },
    "tags": ["편미분방정식", "PDE", "partial differential", "wave"]
  },
  {
    "id": "phase-space",
    "name": { "ko": "위상공간 (상공간)", "en": "Phase Space" },
    "field": "dynamics",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "위상공간(상공간)은 동역학계의 모든 가능한 상태를 좌표로 나타낸 공간입니다. 시스템의 진화를 궤적으로 시각화할 수 있습니다.",
        "formulas": [
          {
            "latex": "(q_1, ..., q_n, p_1, ..., p_n) \\in \\mathbb{R}^{2n}",
            "description": "n 자유도 시스템의 위상공간 좌표"
          },
          {
            "latex": "\\dot{q}_i = \\frac{\\partial H}{\\partial p_i}, \\quad \\dot{p}_i = -\\frac{\\partial H}{\\partial q_i}",
            "description": "해밀턴 방정식"
          }
        ],
        "examples": [
          {
            "problem": "단진자의 위상공간을 그리세요.",
            "solution": "x축: 각도 θ, y축: 각속도 θ̇. 작은 진동은 타원 궤적, 큰 진동은 물결 모양, 회전 운동은 열린 곡선입니다."
          },
          {
            "problem": "조화 진동자의 위상공간 궤적은?",
            "solution": "x축: 위치 x, y축: 운동량 p. 에너지 보존으로 인해 완전한 타원 궤적을 그립니다."
          }
        ],
        "history": {
          "discoveredBy": "조제프 리우빌, 윌리엄 해밀턴",
          "year": "19세기",
          "background": "해석역학의 발전과 함께 시스템의 상태를 기하학적으로 분석하는 방법이 발전했습니다."
        },
        "applications": [
          { "field": "고전역학", "description": "행성 운동, 진자 운동" },
          { "field": "통계역학", "description": "앙상블 이론" },
          { "field": "제어 이론", "description": "시스템 안정성 분석" }
        ]
      },
      "en": {
        "definition": "Phase space represents all possible states of a dynamical system as coordinates. System evolution can be visualized as trajectories.",
        "formulas": [
          {
            "latex": "(q_1, ..., q_n, p_1, ..., p_n) \\in \\mathbb{R}^{2n}",
            "description": "Phase space coordinates for n-degree system"
          },
          {
            "latex": "\\dot{q}_i = \\frac{\\partial H}{\\partial p_i}, \\quad \\dot{p}_i = -\\frac{\\partial H}{\\partial q_i}",
            "description": "Hamilton's equations"
          }
        ],
        "examples": [
          {
            "problem": "Draw phase space for simple pendulum.",
            "solution": "x-axis: angle θ, y-axis: angular velocity θ̇. Small oscillations: ellipses, large: wave-like, rotation: open curves."
          },
          {
            "problem": "What is the phase space trajectory of harmonic oscillator?",
            "solution": "x-axis: position x, y-axis: momentum p. Energy conservation gives perfect elliptical trajectories."
          }
        ],
        "history": {
          "discoveredBy": "Joseph Liouville, William Hamilton",
          "year": "19th century",
          "background": "Geometric analysis of system states developed alongside analytical mechanics."
        },
        "applications": [
          { "field": "Classical Mechanics", "description": "Planetary motion, pendulum" },
          { "field": "Statistical Mechanics", "description": "Ensemble theory" },
          { "field": "Control Theory", "description": "System stability analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["dynamical-systems", "derivative"],
      "nextTopics": ["attractors", "liouville-theorem"],
      "related": ["hamiltonian-mechanics"]
    },
    "tags": ["위상공간", "상공간", "phase space", "trajectory"]
  },
  {
    "id": "attractors",
    "name": { "ko": "끌개", "en": "Attractors" },
    "field": "dynamics",
    "subfield": "chaos",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "끌개는 동역학계에서 궤적들이 시간이 지남에 따라 수렴하는 상태나 상태들의 집합입니다. 점, 주기궤도, 이상한 끌개 등이 있습니다.",
        "formulas": [
          { "latex": "\\lim_{t \\to \\infty} d(x(t), A) = 0", "description": "끌개 A로의 수렴" },
          {
            "latex": "\\begin{cases} \\dot{x} = \\sigma(y-x) \\\\ \\dot{y} = x(\\rho - z) - y \\\\ \\dot{z} = xy - \\beta z \\end{cases}",
            "description": "로렌츠 방정식 (이상한 끌개)"
          }
        ],
        "examples": [
          {
            "problem": "점 끌개, 한계 순환, 이상한 끌개의 차이를 설명하세요.",
            "solution": "점 끌개: 정지 상태. 한계 순환: 주기적 진동. 이상한 끌개: 비주기적, 프랙탈 구조, 카오스적."
          },
          {
            "problem": "로렌츠 끌개의 특징은?",
            "solution": "나비 모양의 이상한 끌개. 궤적이 두 날개 사이를 예측 불가능하게 이동합니다. 프랙탈 차원 ≈ 2.06."
          }
        ],
        "history": {
          "discoveredBy": "에드워드 로렌츠",
          "year": "1963년",
          "background": "기상 모델에서 발견된 로렌츠 끌개는 카오스 이론의 상징이 되었습니다."
        },
        "applications": [
          { "field": "기상학", "description": "대기 모델" },
          { "field": "신경과학", "description": "뇌 활동 패턴" },
          { "field": "경제학", "description": "시장 동역학" }
        ]
      },
      "en": {
        "definition": "An attractor is a state or set of states that trajectories converge to over time in a dynamical system. Types include point, periodic orbit, and strange attractors.",
        "formulas": [
          {
            "latex": "\\lim_{t \\to \\infty} d(x(t), A) = 0",
            "description": "Convergence to attractor A"
          },
          {
            "latex": "\\begin{cases} \\dot{x} = \\sigma(y-x) \\\\ \\dot{y} = x(\\rho - z) - y \\\\ \\dot{z} = xy - \\beta z \\end{cases}",
            "description": "Lorenz equations (strange attractor)"
          }
        ],
        "examples": [
          {
            "problem": "Explain difference between point, limit cycle, and strange attractors.",
            "solution": "Point: stationary state. Limit cycle: periodic oscillation. Strange: aperiodic, fractal structure, chaotic."
          },
          {
            "problem": "What characterizes the Lorenz attractor?",
            "solution": "Butterfly-shaped strange attractor. Trajectory moves unpredictably between two wings. Fractal dimension ≈ 2.06."
          }
        ],
        "history": {
          "discoveredBy": "Edward Lorenz",
          "year": "1963",
          "background": "Discovered in weather model, Lorenz attractor became iconic in chaos theory."
        },
        "applications": [
          { "field": "Meteorology", "description": "Atmospheric models" },
          { "field": "Neuroscience", "description": "Brain activity patterns" },
          { "field": "Economics", "description": "Market dynamics" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["dynamical-systems", "phase-space"],
      "nextTopics": ["chaos-theory", "fractals"],
      "related": ["fixed-points"]
    },
    "tags": ["끌개", "로렌츠", "attractor", "Lorenz"]
  },
  {
    "id": "optimization-basics",
    "name": { "ko": "최적화 기초", "en": "Optimization Basics" },
    "field": "optimization",
    "subfield": "foundations",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "최적화는 주어진 조건 하에서 목적함수를 최대화하거나 최소화하는 변수 값을 찾는 것입니다.",
        "formulas": [
          {
            "latex": "\\min_{x} f(x) \\quad \\text{subject to} \\quad g(x) \\leq 0, h(x) = 0",
            "description": "일반적인 최적화 문제"
          },
          { "latex": "\\nabla f(x^*) = 0", "description": "무제약 최적화의 필요조건" }
        ],
        "examples": [
          {
            "problem": "f(x) = x² - 4x + 5의 최솟값을 구하세요.",
            "solution": "f'(x) = 2x - 4 = 0에서 x = 2. f''(2) = 2 > 0이므로 최솟값. f(2) = 4 - 8 + 5 = 1"
          }
        ],
        "applications": [
          { "field": "기계학습", "description": "손실함수 최소화" },
          { "field": "경제학", "description": "효용 최대화" },
          { "field": "공학", "description": "설계 최적화" }
        ]
      },
      "en": {
        "definition": "Optimization is finding variable values that maximize or minimize an objective function under given constraints.",
        "formulas": [
          {
            "latex": "\\min_{x} f(x) \\quad \\text{subject to} \\quad g(x) \\leq 0, h(x) = 0",
            "description": "General optimization problem"
          },
          {
            "latex": "\\nabla f(x^*) = 0",
            "description": "Necessary condition for unconstrained optimization"
          }
        ],
        "examples": [
          {
            "problem": "Find the minimum of f(x) = x² - 4x + 5.",
            "solution": "f'(x) = 2x - 4 = 0 gives x = 2. f''(2) = 2 > 0, so minimum. f(2) = 4 - 8 + 5 = 1"
          }
        ],
        "applications": [
          { "field": "Machine Learning", "description": "Loss function minimization" },
          { "field": "Economics", "description": "Utility maximization" },
          { "field": "Engineering", "description": "Design optimization" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "gradient"],
      "nextTopics": ["gradient-descent", "lagrange-multipliers"],
      "related": ["calculus"]
    },
    "tags": ["최적화", "최솟값", "optimization", "minimum"]
  },
  {
    "id": "gradient-descent",
    "name": { "ko": "경사 하강법", "en": "Gradient Descent" },
    "field": "optimization",
    "subfield": "algorithms",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "경사 하강법은 함수의 그래디언트(기울기) 반대 방향으로 반복적으로 이동하여 최솟값을 찾는 최적화 알고리즘입니다.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\alpha \\nabla f(x_n)",
            "description": "경사 하강법 업데이트 규칙"
          },
          { "latex": "\\alpha", "description": "학습률 (step size)" }
        ],
        "examples": [
          {
            "problem": "f(x) = x²에 경사 하강법을 x₀ = 4, α = 0.5로 적용하세요.",
            "solution": "f'(x) = 2x. x₁ = 4 - 0.5(8) = 0. 한 번의 반복으로 최솟값에 도달."
          }
        ],
        "applications": [
          { "field": "딥러닝", "description": "신경망 학습" },
          { "field": "기계학습", "description": "모델 파라미터 최적화" },
          { "field": "데이터 과학", "description": "회귀 분석" }
        ]
      },
      "en": {
        "definition": "Gradient descent is an optimization algorithm that iteratively moves in the opposite direction of the gradient to find the minimum.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\alpha \\nabla f(x_n)",
            "description": "Gradient descent update rule"
          },
          { "latex": "\\alpha", "description": "Learning rate (step size)" }
        ],
        "examples": [
          {
            "problem": "Apply gradient descent to f(x) = x² with x₀ = 4, α = 0.5.",
            "solution": "f'(x) = 2x. x₁ = 4 - 0.5(8) = 0. Reaches minimum in one iteration."
          }
        ],
        "applications": [
          { "field": "Deep Learning", "description": "Neural network training" },
          { "field": "Machine Learning", "description": "Model parameter optimization" },
          { "field": "Data Science", "description": "Regression analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["gradient", "derivative"],
      "nextTopics": ["stochastic-gd", "adam-optimizer"],
      "related": ["backpropagation"]
    },
    "tags": ["경사하강", "기울기", "gradient descent", "optimization"]
  },
  {
    "id": "lagrange-multipliers",
    "name": { "ko": "라그랑주 승수법", "en": "Lagrange Multipliers" },
    "field": "optimization",
    "subfield": "constrained",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "라그랑주 승수법은 등식 제약 조건이 있는 최적화 문제를 푸는 방법입니다. 제약 조건을 새로운 변수(승수)와 결합합니다.",
        "formulas": [
          {
            "latex": "\\mathcal{L}(x, \\lambda) = f(x) - \\lambda g(x)",
            "description": "라그랑지안"
          },
          { "latex": "\\nabla f = \\lambda \\nabla g", "description": "최적점에서의 조건" }
        ],
        "examples": [
          {
            "problem": "x + y = 10 제약 하에서 xy를 최대화하세요.",
            "solution": "L = xy - λ(x+y-10). ∂L/∂x = y - λ = 0, ∂L/∂y = x - λ = 0. x = y이고 x + y = 10이므로 x = y = 5. 최댓값 = 25"
          }
        ],
        "history": {
          "discoveredBy": "조제프루이 라그랑주",
          "year": "1788년",
          "background": "라그랑주가 역학 문제를 풀면서 이 방법을 개발했습니다."
        },
        "applications": [
          { "field": "경제학", "description": "예산 제약 하 효용 최대화" },
          { "field": "물리학", "description": "역학적 제약 조건" },
          { "field": "기계학습", "description": "SVM의 최적화" }
        ]
      },
      "en": {
        "definition": "Lagrange multipliers method solves optimization problems with equality constraints by combining constraints with new variables (multipliers).",
        "formulas": [
          {
            "latex": "\\mathcal{L}(x, \\lambda) = f(x) - \\lambda g(x)",
            "description": "Lagrangian"
          },
          { "latex": "\\nabla f = \\lambda \\nabla g", "description": "Condition at optimum" }
        ],
        "examples": [
          {
            "problem": "Maximize xy subject to x + y = 10.",
            "solution": "L = xy - λ(x+y-10). ∂L/∂x = y - λ = 0, ∂L/∂y = x - λ = 0. x = y and x + y = 10, so x = y = 5. Maximum = 25"
          }
        ],
        "history": {
          "discoveredBy": "Joseph-Louis Lagrange",
          "year": "1788",
          "background": "Lagrange developed this method while solving mechanics problems."
        },
        "applications": [
          { "field": "Economics", "description": "Utility maximization under budget" },
          { "field": "Physics", "description": "Mechanical constraints" },
          { "field": "Machine Learning", "description": "SVM optimization" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["gradient", "optimization-basics"],
      "nextTopics": ["kkt-conditions", "convex-optimization"],
      "related": ["multivariable-calculus"]
    },
    "tags": ["라그랑주", "제약", "Lagrange", "constraint"]
  },
  {
    "id": "linear-programming",
    "name": { "ko": "선형 계획법", "en": "Linear Programming" },
    "field": "optimization",
    "subfield": "linear",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "선형 계획법은 선형 목적함수를 선형 제약조건 하에서 최적화하는 방법입니다. 심플렉스 알고리즘으로 효율적으로 풀 수 있습니다.",
        "formulas": [
          {
            "latex": "\\max c^T x \\quad \\text{s.t.} \\quad Ax \\leq b, x \\geq 0",
            "description": "표준형 선형 계획 문제"
          }
        ],
        "examples": [
          {
            "problem": "max 3x + 2y, s.t. x + y ≤ 4, 2x + y ≤ 6, x,y ≥ 0을 푸세요.",
            "solution": "꼭짓점 검사: (0,0)→0, (0,4)→8, (2,2)→10, (3,0)→9. 최적해: (2,2), 최댓값: 10"
          }
        ],
        "history": {
          "discoveredBy": "조지 단치그",
          "year": "1947년",
          "background": "단치그가 심플렉스 알고리즘을 개발하여 선형 계획법을 실용적으로 만들었습니다."
        },
        "applications": [
          { "field": "운영 연구", "description": "자원 배분, 스케줄링" },
          { "field": "물류", "description": "운송 최적화" },
          { "field": "금융", "description": "포트폴리오 최적화" }
        ]
      },
      "en": {
        "definition": "Linear programming optimizes a linear objective function under linear constraints. The simplex algorithm solves it efficiently.",
        "formulas": [
          {
            "latex": "\\max c^T x \\quad \\text{s.t.} \\quad Ax \\leq b, x \\geq 0",
            "description": "Standard form linear program"
          }
        ],
        "examples": [
          {
            "problem": "Solve max 3x + 2y, s.t. x + y ≤ 4, 2x + y ≤ 6, x,y ≥ 0.",
            "solution": "Check vertices: (0,0)→0, (0,4)→8, (2,2)→10, (3,0)→9. Optimal: (2,2), max: 10"
          }
        ],
        "history": {
          "discoveredBy": "George Dantzig",
          "year": "1947",
          "background": "Dantzig developed the simplex algorithm, making linear programming practical."
        },
        "applications": [
          { "field": "Operations Research", "description": "Resource allocation, scheduling" },
          { "field": "Logistics", "description": "Transportation optimization" },
          { "field": "Finance", "description": "Portfolio optimization" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["linear-algebra", "inequalities"],
      "nextTopics": ["integer-programming", "duality"],
      "related": ["simplex-algorithm"]
    },
    "tags": ["선형계획", "심플렉스", "linear programming", "LP"]
  },
  {
    "id": "convex-optimization",
    "name": { "ko": "볼록 최적화", "en": "Convex Optimization" },
    "field": "optimization",
    "subfield": "convex",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "볼록 최적화는 볼록 집합에서 볼록 함수를 최소화하는 문제입니다. 지역 최솟값이 전역 최솟값이 되어 효율적으로 풀 수 있습니다.",
        "formulas": [
          {
            "latex": "f(\\theta x + (1-\\theta)y) \\leq \\theta f(x) + (1-\\theta)f(y)",
            "description": "볼록 함수의 정의"
          },
          {
            "latex": "\\nabla^2 f(x) \\succeq 0",
            "description": "볼록성의 이계 조건 (헤시안이 양반정치)"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x²이 볼록함을 보이세요.",
            "solution": "f''(x) = 2 > 0 (항상 양수), 따라서 볼록합니다. 또는: f(θa + (1-θ)b) ≤ θf(a) + (1-θ)f(b)를 직접 확인."
          }
        ],
        "applications": [
          { "field": "기계학습", "description": "로지스틱 회귀, SVM" },
          { "field": "신호 처리", "description": "필터 설계" },
          { "field": "제어 이론", "description": "LQR 제어" }
        ]
      },
      "en": {
        "definition": "Convex optimization minimizes a convex function over a convex set. Local minima are global minima, making it efficiently solvable.",
        "formulas": [
          {
            "latex": "f(\\theta x + (1-\\theta)y) \\leq \\theta f(x) + (1-\\theta)f(y)",
            "description": "Definition of convex function"
          },
          {
            "latex": "\\nabla^2 f(x) \\succeq 0",
            "description": "Second-order convexity condition (Hessian PSD)"
          }
        ],
        "examples": [
          {
            "problem": "Show f(x) = x² is convex.",
            "solution": "f''(x) = 2 > 0 (always positive), so convex. Or verify: f(θa + (1-θ)b) ≤ θf(a) + (1-θ)f(b)."
          }
        ],
        "applications": [
          { "field": "Machine Learning", "description": "Logistic regression, SVM" },
          { "field": "Signal Processing", "description": "Filter design" },
          { "field": "Control Theory", "description": "LQR control" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["optimization-basics", "linear-algebra"],
      "nextTopics": ["interior-point-methods"],
      "related": ["linear-programming"]
    },
    "tags": ["볼록", "최적화", "convex", "optimization"]
  },
  {
    "id": "numerical-error",
    "name": { "ko": "수치 오차", "en": "Numerical Error" },
    "field": "numerical",
    "subfield": "error-analysis",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수치 오차는 컴퓨터 계산에서 발생하는 오차입니다. 반올림 오차, 절단 오차, 전파 오차 등이 있습니다.",
        "formulas": [
          { "latex": "\\text{절대 오차} = |x - \\tilde{x}|", "description": "절대 오차" },
          {
            "latex": "\\text{상대 오차} = \\frac{|x - \\tilde{x}|}{|x|}",
            "description": "상대 오차"
          },
          {
            "latex": "\\epsilon_{\\text{machine}} \\approx 2.2 \\times 10^{-16}",
            "description": "배정밀도 기계 엡실론"
          }
        ],
        "examples": [
          {
            "problem": "참값이 π이고 근사값이 3.14일 때 상대 오차는?",
            "solution": "상대 오차 = |π - 3.14| / |π| ≈ 0.00159 / 3.14159 ≈ 0.05%"
          }
        ],
        "applications": [
          { "field": "과학 계산", "description": "계산 신뢰도 평가" },
          { "field": "금융", "description": "정밀 계산" },
          { "field": "공학", "description": "시뮬레이션 정확도" }
        ]
      },
      "en": {
        "definition": "Numerical error arises in computer calculations. Types include rounding error, truncation error, and propagation error.",
        "formulas": [
          { "latex": "\\text{Absolute error} = |x - \\tilde{x}|", "description": "Absolute error" },
          {
            "latex": "\\text{Relative error} = \\frac{|x - \\tilde{x}|}{|x|}",
            "description": "Relative error"
          },
          {
            "latex": "\\epsilon_{\\text{machine}} \\approx 2.2 \\times 10^{-16}",
            "description": "Double precision machine epsilon"
          }
        ],
        "examples": [
          {
            "problem": "If true value is π and approximation is 3.14, find relative error.",
            "solution": "Relative error = |π - 3.14| / |π| ≈ 0.00159 / 3.14159 ≈ 0.05%"
          }
        ],
        "applications": [
          { "field": "Scientific Computing", "description": "Calculation reliability" },
          { "field": "Finance", "description": "Precision calculations" },
          { "field": "Engineering", "description": "Simulation accuracy" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["floating-point"],
      "nextTopics": ["stability-analysis", "conditioning"],
      "related": ["approximation"]
    },
    "tags": ["오차", "수치해석", "error", "numerical"]
  },
  {
    "id": "newton-method",
    "name": { "ko": "뉴턴-랩슨 방법", "en": "Newton-Raphson Method" },
    "field": "numerical",
    "subfield": "root-finding",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "뉴턴-랩슨 방법은 f(x) = 0의 근을 찾는 반복법입니다. 접선을 이용해 빠르게 수렴합니다.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}",
            "description": "뉴턴-랩슨 반복 공식"
          }
        ],
        "examples": [
          {
            "problem": "√2를 뉴턴법으로 구하세요 (f(x) = x² - 2, x₀ = 1).",
            "solution": "x₁ = 1 - (1-2)/(2·1) = 1.5, x₂ = 1.5 - (0.25)/(3) ≈ 1.4167, x₃ ≈ 1.4142..."
          }
        ],
        "history": {
          "discoveredBy": "아이작 뉴턴, 조제프 랩슨",
          "year": "17세기",
          "background": "뉴턴이 다항식 근을 찾기 위해 개발했고, 랩슨이 일반화했습니다."
        },
        "applications": [
          { "field": "공학", "description": "비선형 방정식 풀이" },
          { "field": "최적화", "description": "뉴턴 최적화" },
          { "field": "컴퓨터 그래픽스", "description": "레이 트레이싱" }
        ]
      },
      "en": {
        "definition": "Newton-Raphson method is an iterative technique for finding roots of f(x) = 0. It uses tangent lines for fast convergence.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}",
            "description": "Newton-Raphson iteration formula"
          }
        ],
        "examples": [
          {
            "problem": "Find √2 using Newton's method (f(x) = x² - 2, x₀ = 1).",
            "solution": "x₁ = 1 - (1-2)/(2·1) = 1.5, x₂ = 1.5 - (0.25)/(3) ≈ 1.4167, x₃ ≈ 1.4142..."
          }
        ],
        "history": {
          "discoveredBy": "Isaac Newton, Joseph Raphson",
          "year": "17th century",
          "background": "Newton developed it for polynomial roots; Raphson generalized it."
        },
        "applications": [
          { "field": "Engineering", "description": "Nonlinear equation solving" },
          { "field": "Optimization", "description": "Newton optimization" },
          { "field": "Computer Graphics", "description": "Ray tracing" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "limits"],
      "nextTopics": ["secant-method", "fixed-point-iteration"],
      "related": ["bisection"]
    },
    "tags": ["뉴턴", "근찾기", "Newton", "root finding"]
  },
  {
    "id": "numerical-integration",
    "name": { "ko": "수치 적분", "en": "Numerical Integration" },
    "field": "numerical",
    "subfield": "integration",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수치 적분은 정적분의 값을 근사적으로 계산하는 방법입니다. 사다리꼴 공식, 심프슨 공식 등이 있습니다.",
        "formulas": [
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{2}(f(a) + f(b))",
            "description": "사다리꼴 공식 (단일 구간)"
          },
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{3}(f(a) + 4f(m) + f(b))",
            "description": "심프슨 1/3 공식"
          }
        ],
        "examples": [
          {
            "problem": "심프슨 공식으로 ∫₀² x² dx를 계산하세요.",
            "solution": "h = 1, m = 1. S = (1/3)(0 + 4(1) + 4) = (1/3)(8) = 8/3 ≈ 2.67. 정확값 = 8/3 ✓"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "궤적 계산" },
          { "field": "통계학", "description": "누적분포함수" },
          { "field": "공학", "description": "면적, 부피 계산" }
        ]
      },
      "en": {
        "definition": "Numerical integration approximates definite integral values. Methods include trapezoidal rule and Simpson's rule.",
        "formulas": [
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{2}(f(a) + f(b))",
            "description": "Trapezoidal rule (single interval)"
          },
          {
            "latex": "\\int_a^b f(x)dx \\approx \\frac{h}{3}(f(a) + 4f(m) + f(b))",
            "description": "Simpson's 1/3 rule"
          }
        ],
        "examples": [
          {
            "problem": "Calculate ∫₀² x² dx using Simpson's rule.",
            "solution": "h = 1, m = 1. S = (1/3)(0 + 4(1) + 4) = (1/3)(8) = 8/3 ≈ 2.67. Exact value = 8/3 ✓"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Trajectory calculation" },
          { "field": "Statistics", "description": "Cumulative distribution" },
          { "field": "Engineering", "description": "Area, volume calculation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["integral"],
      "nextTopics": ["gaussian-quadrature", "monte-carlo-integration"],
      "related": ["riemann-sum"]
    },
    "tags": ["수치적분", "심프슨", "numerical integration", "quadrature"]
  },
  {
    "id": "interpolation",
    "name": { "ko": "보간법", "en": "Interpolation" },
    "field": "numerical",
    "subfield": "approximation",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "보간법은 주어진 데이터 점들 사이의 값을 추정하는 방법입니다. 다항식 보간, 스플라인 보간 등이 있습니다.",
        "formulas": [
          {
            "latex": "L(x) = \\sum_{i=0}^{n} y_i \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j}",
            "description": "라그랑주 보간 다항식"
          }
        ],
        "examples": [
          {
            "problem": "(0,1), (1,3), (2,7)을 지나는 라그랑주 보간다항식을 구하세요.",
            "solution": "L(x) = 1·(x-1)(x-2)/((0-1)(0-2)) + 3·x(x-2)/((1-0)(1-2)) + 7·x(x-1)/((2-0)(2-1)) = x² + x + 1"
          }
        ],
        "applications": [
          { "field": "컴퓨터 그래픽스", "description": "곡선/곡면 생성" },
          { "field": "신호 처리", "description": "리샘플링" },
          { "field": "데이터 분석", "description": "결측값 추정" }
        ]
      },
      "en": {
        "definition": "Interpolation estimates values between given data points. Methods include polynomial interpolation and spline interpolation.",
        "formulas": [
          {
            "latex": "L(x) = \\sum_{i=0}^{n} y_i \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j}",
            "description": "Lagrange interpolation polynomial"
          }
        ],
        "examples": [
          {
            "problem": "Find the Lagrange polynomial through (0,1), (1,3), (2,7).",
            "solution": "L(x) = 1·(x-1)(x-2)/((0-1)(0-2)) + 3·x(x-2)/((1-0)(1-2)) + 7·x(x-1)/((2-0)(2-1)) = x² + x + 1"
          }
        ],
        "applications": [
          { "field": "Computer Graphics", "description": "Curve/surface generation" },
          { "field": "Signal Processing", "description": "Resampling" },
          { "field": "Data Analysis", "description": "Missing value estimation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["polynomial", "linear-algebra"],
      "nextTopics": ["spline", "least-squares"],
      "related": ["curve-fitting"]
    },
    "tags": ["보간", "라그랑주", "interpolation", "Lagrange"]
  },
  {
    "id": "numerical-ode",
    "name": { "ko": "미분방정식의 수치해법", "en": "Numerical ODE Methods" },
    "field": "numerical",
    "subfield": "ode",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "미분방정식의 수치해법은 해석적 해를 구하기 어려운 미분방정식의 해를 근사적으로 구하는 방법입니다.",
        "formulas": [
          { "latex": "y_{n+1} = y_n + h f(t_n, y_n)", "description": "오일러 방법 (전진)" },
          {
            "latex": "y_{n+1} = y_n + h f(t_n + h/2, y_n + \\frac{h}{2}f(t_n, y_n))",
            "description": "중점법 (2차 룽게-쿠타)"
          }
        ],
        "examples": [
          {
            "problem": "dy/dt = y, y(0) = 1을 오일러법으로 풀이하세요 (h = 0.1).",
            "solution": "y₁ = 1 + 0.1(1) = 1.1, y₂ = 1.1 + 0.1(1.1) = 1.21, ... (정확해: e^t)"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "운동 시뮬레이션" },
          { "field": "공학", "description": "회로, 제어 시스템" },
          { "field": "생물학", "description": "개체군 모델" }
        ]
      },
      "en": {
        "definition": "Numerical ODE methods approximate solutions to differential equations that are difficult to solve analytically.",
        "formulas": [
          { "latex": "y_{n+1} = y_n + h f(t_n, y_n)", "description": "Euler method (forward)" },
          {
            "latex": "y_{n+1} = y_n + h f(t_n + h/2, y_n + \\frac{h}{2}f(t_n, y_n))",
            "description": "Midpoint method (RK2)"
          }
        ],
        "examples": [
          {
            "problem": "Solve dy/dt = y, y(0) = 1 using Euler method (h = 0.1).",
            "solution": "y₁ = 1 + 0.1(1) = 1.1, y₂ = 1.1 + 0.1(1.1) = 1.21, ... (exact: e^t)"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Motion simulation" },
          { "field": "Engineering", "description": "Circuits, control systems" },
          { "field": "Biology", "description": "Population models" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "differential-equations"],
      "nextTopics": ["runge-kutta", "stiff-equations"],
      "related": ["stability"]
    },
    "tags": ["미분방정식", "오일러", "ODE", "Euler"]
  },
  {
    "id": "bisection-method",
    "name": { "ko": "이분법", "en": "Bisection Method" },
    "field": "numerical",
    "subfield": "root-finding",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "이분법은 연속함수의 근을 찾는 가장 간단한 방법입니다. 구간을 반으로 나누어 부호가 바뀌는 쪽으로 좁혀갑니다.",
        "formulas": [
          { "latex": "c = \\frac{a + b}{2}", "description": "중점 계산" },
          {
            "latex": "\\text{if } f(a)f(c) < 0: b = c, \\text{ else } a = c",
            "description": "구간 갱신 규칙"
          },
          {
            "latex": "|x_n - r| \\leq \\frac{b-a}{2^{n+1}}",
            "description": "n번 반복 후 오차 상한"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x² - 2의 근을 [1, 2]에서 이분법으로 찾으세요.",
            "solution": "f(1) = -1 < 0, f(2) = 2 > 0. c = 1.5, f(1.5) = 0.25 > 0. 새 구간 [1, 1.5]. c = 1.25, f(1.25) = -0.4375 < 0. [1.25, 1.5]... 계속하면 √2 ≈ 1.414로 수렴"
          }
        ],
        "applications": [
          { "field": "공학", "description": "안전한 근 탐색" },
          { "field": "컴퓨터 과학", "description": "이진 탐색의 수학적 기반" },
          { "field": "금융", "description": "손익분기점 계산" }
        ]
      },
      "en": {
        "definition": "Bisection method is the simplest root-finding method for continuous functions. It halves the interval, narrowing toward sign changes.",
        "formulas": [
          { "latex": "c = \\frac{a + b}{2}", "description": "Midpoint calculation" },
          {
            "latex": "\\text{if } f(a)f(c) < 0: b = c, \\text{ else } a = c",
            "description": "Interval update rule"
          },
          {
            "latex": "|x_n - r| \\leq \\frac{b-a}{2^{n+1}}",
            "description": "Error bound after n iterations"
          }
        ],
        "examples": [
          {
            "problem": "Find root of f(x) = x² - 2 in [1, 2] using bisection.",
            "solution": "f(1) = -1 < 0, f(2) = 2 > 0. c = 1.5, f(1.5) = 0.25 > 0. New interval [1, 1.5]. c = 1.25, f(1.25) = -0.4375 < 0. [1.25, 1.5]... Converges to √2 ≈ 1.414"
          }
        ],
        "applications": [
          { "field": "Engineering", "description": "Safe root finding" },
          { "field": "Computer Science", "description": "Mathematical basis of binary search" },
          { "field": "Finance", "description": "Break-even calculation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["continuous-function", "intermediate-value-theorem"],
      "nextTopics": ["newton-method", "secant-method"],
      "related": ["binary-search"]
    },
    "tags": ["이분법", "근찾기", "bisection", "root finding"]
  },
  {
    "id": "runge-kutta",
    "name": { "ko": "룽게-쿠타 방법", "en": "Runge-Kutta Methods" },
    "field": "numerical",
    "subfield": "ode",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "룽게-쿠타 방법은 미분방정식의 수치해를 구하는 고정밀 방법입니다. 4차 방법(RK4)이 가장 널리 사용됩니다.",
        "formulas": [
          { "latex": "k_1 = f(t_n, y_n)", "description": "첫 번째 기울기" },
          {
            "latex": "k_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1)",
            "description": "두 번째 기울기"
          },
          {
            "latex": "k_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2)",
            "description": "세 번째 기울기"
          },
          { "latex": "k_4 = f(t_n + h, y_n + hk_3)", "description": "네 번째 기울기" },
          {
            "latex": "y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)",
            "description": "RK4 업데이트 공식"
          }
        ],
        "examples": [
          {
            "problem": "dy/dt = y, y(0) = 1에 RK4를 적용하세요 (h = 0.1).",
            "solution": "k₁ = 1, k₂ = 1.05, k₃ = 1.0525, k₄ = 1.10525. y₁ = 1 + (0.1/6)(1 + 2.1 + 2.105 + 1.10525) = 1.10517... (정확해 e^0.1 ≈ 1.10517)"
          }
        ],
        "history": {
          "discoveredBy": "카를 룽게, 마르틴 쿠타",
          "year": "1901년",
          "background": "오일러 방법의 정확도를 개선하기 위해 여러 기울기를 조합하는 방법을 개발했습니다."
        },
        "applications": [
          { "field": "물리 시뮬레이션", "description": "행성 궤도, 입자 운동" },
          { "field": "게임 개발", "description": "물리 엔진" },
          { "field": "공학", "description": "제어 시스템 시뮬레이션" }
        ]
      },
      "en": {
        "definition": "Runge-Kutta methods are high-precision techniques for numerical solutions of differential equations. Fourth-order (RK4) is most widely used.",
        "formulas": [
          { "latex": "k_1 = f(t_n, y_n)", "description": "First slope" },
          {
            "latex": "k_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1)",
            "description": "Second slope"
          },
          {
            "latex": "k_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2)",
            "description": "Third slope"
          },
          { "latex": "k_4 = f(t_n + h, y_n + hk_3)", "description": "Fourth slope" },
          {
            "latex": "y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)",
            "description": "RK4 update formula"
          }
        ],
        "examples": [
          {
            "problem": "Apply RK4 to dy/dt = y, y(0) = 1 with h = 0.1.",
            "solution": "k₁ = 1, k₂ = 1.05, k₃ = 1.0525, k₄ = 1.10525. y₁ = 1 + (0.1/6)(1 + 2.1 + 2.105 + 1.10525) = 1.10517... (exact e^0.1 ≈ 1.10517)"
          }
        ],
        "history": {
          "discoveredBy": "Carl Runge, Martin Kutta",
          "year": "1901",
          "background": "Developed combining multiple slopes to improve Euler method accuracy."
        },
        "applications": [
          { "field": "Physics Simulation", "description": "Orbital mechanics, particle motion" },
          { "field": "Game Development", "description": "Physics engines" },
          { "field": "Engineering", "description": "Control system simulation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["numerical-ode", "taylor-series"],
      "nextTopics": ["adaptive-methods", "stiff-equations"],
      "related": ["euler-method"]
    },
    "tags": ["룽게쿠타", "RK4", "Runge-Kutta", "ODE solver"]
  },
  {
    "id": "matrix-factorization",
    "name": { "ko": "행렬 분해", "en": "Matrix Factorization" },
    "field": "numerical",
    "subfield": "linear-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "행렬 분해는 행렬을 더 간단한 행렬들의 곱으로 표현하는 것입니다. 연립방정식 풀이, 고유값 계산, 데이터 압축 등에 사용됩니다.",
        "formulas": [
          { "latex": "A = LU", "description": "LU 분해 (하삼각 × 상삼각)" },
          { "latex": "A = QR", "description": "QR 분해 (직교 × 상삼각)" },
          { "latex": "A = U\\Sigma V^T", "description": "특이값 분해 (SVD)" },
          { "latex": "A = LDL^T", "description": "촐레스키 분해 (대칭 양정치)" }
        ],
        "examples": [
          {
            "problem": "LU 분해를 이용해 Ax = b를 푸는 방법을 설명하세요.",
            "solution": "A = LU로 분해. Ly = b를 전진대입으로 풀고, Ux = y를 후진대입으로 풉니다. 같은 A에 대해 여러 b를 풀 때 효율적입니다."
          }
        ],
        "applications": [
          { "field": "수치선형대수", "description": "연립방정식 풀이" },
          { "field": "기계학습", "description": "차원 축소, 추천 시스템" },
          { "field": "이미지 처리", "description": "압축, 노이즈 제거" }
        ]
      },
      "en": {
        "definition": "Matrix factorization expresses a matrix as product of simpler matrices. Used for solving systems, eigenvalue computation, and data compression.",
        "formulas": [
          { "latex": "A = LU", "description": "LU decomposition (lower × upper triangular)" },
          { "latex": "A = QR", "description": "QR decomposition (orthogonal × upper triangular)" },
          { "latex": "A = U\\Sigma V^T", "description": "Singular Value Decomposition (SVD)" },
          {
            "latex": "A = LDL^T",
            "description": "Cholesky decomposition (symmetric positive definite)"
          }
        ],
        "examples": [
          {
            "problem": "Explain how to solve Ax = b using LU decomposition.",
            "solution": "Factor A = LU. Solve Ly = b by forward substitution, then Ux = y by back substitution. Efficient for multiple b with same A."
          }
        ],
        "applications": [
          { "field": "Numerical Linear Algebra", "description": "Solving linear systems" },
          {
            "field": "Machine Learning",
            "description": "Dimensionality reduction, recommender systems"
          },
          { "field": "Image Processing", "description": "Compression, denoising" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["matrices-basics", "determinant"],
      "nextTopics": ["eigenvalues-eigenvectors", "iterative-methods"],
      "related": ["gaussian-elimination"]
    },
    "tags": ["행렬분해", "LU", "SVD", "matrix factorization"]
  },
  {
    "id": "finite-difference",
    "name": { "ko": "유한 차분법", "en": "Finite Difference Method" },
    "field": "numerical",
    "subfield": "pde",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "유한 차분법은 미분을 차분으로 근사하여 미분방정식을 대수방정식으로 변환합니다. PDE의 수치해를 구하는 기본 방법입니다.",
        "formulas": [
          { "latex": "f'(x) \\approx \\frac{f(x+h) - f(x)}{h}", "description": "전진 차분" },
          { "latex": "f'(x) \\approx \\frac{f(x) - f(x-h)}{h}", "description": "후진 차분" },
          { "latex": "f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}", "description": "중심 차분" },
          {
            "latex": "f''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2}",
            "description": "2차 미분 근사"
          }
        ],
        "examples": [
          {
            "problem": "열 방정식 ∂u/∂t = α∂²u/∂x²를 차분으로 근사하세요.",
            "solution": "u(x,t+Δt) - u(x,t))/Δt = α(u(x+Δx,t) - 2u(x,t) + u(x-Δx,t))/Δx². 이를 정리하면 명시적 시간 진행 스킴이 됩니다."
          }
        ],
        "applications": [
          { "field": "전산유체역학", "description": "유동 시뮬레이션" },
          { "field": "열전달", "description": "온도 분포 계산" },
          { "field": "구조공학", "description": "응력 해석" }
        ]
      },
      "en": {
        "definition": "Finite difference method approximates derivatives with differences, converting differential equations to algebraic equations. Fundamental for numerical PDE solutions.",
        "formulas": [
          {
            "latex": "f'(x) \\approx \\frac{f(x+h) - f(x)}{h}",
            "description": "Forward difference"
          },
          {
            "latex": "f'(x) \\approx \\frac{f(x) - f(x-h)}{h}",
            "description": "Backward difference"
          },
          {
            "latex": "f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}",
            "description": "Central difference"
          },
          {
            "latex": "f''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2}",
            "description": "Second derivative approximation"
          }
        ],
        "examples": [
          {
            "problem": "Approximate heat equation ∂u/∂t = α∂²u/∂x² with finite differences.",
            "solution": "(u(x,t+Δt) - u(x,t))/Δt = α(u(x+Δx,t) - 2u(x,t) + u(x-Δx,t))/Δx². Rearranging gives explicit time-stepping scheme."
          }
        ],
        "applications": [
          { "field": "CFD", "description": "Flow simulation" },
          { "field": "Heat Transfer", "description": "Temperature distribution" },
          { "field": "Structural Engineering", "description": "Stress analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "partial-differential-equation"],
      "nextTopics": ["finite-element", "stability-analysis"],
      "related": ["interpolation"]
    },
    "tags": ["유한차분", "PDE", "finite difference", "numerical PDE"]
  },
  {
    "id": "fourier-series",
    "name": { "ko": "푸리에 급수", "en": "Fourier Series" },
    "field": "applied",
    "subfield": "fourier-analysis",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "푸리에 급수는 주기 함수를 사인과 코사인의 무한 급수로 표현하는 방법입니다. 모든 주기 함수는 진동 성분으로 분해될 수 있습니다.",
        "formulas": [
          {
            "latex": "f(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} (a_n \\cos nx + b_n \\sin nx)",
            "description": "푸리에 급수"
          },
          {
            "latex": "a_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(nx) dx",
            "description": "푸리에 계수 (코사인)"
          },
          {
            "latex": "b_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(nx) dx",
            "description": "푸리에 계수 (사인)"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x (-π < x < π)의 푸리에 급수를 구하세요.",
            "solution": "a_n = 0 (기함수), b_n = 2(-1)^(n+1)/n. f(x) = 2(sin x - sin 2x/2 + sin 3x/3 - ...)"
          }
        ],
        "history": {
          "discoveredBy": "조제프 푸리에",
          "year": "1822년",
          "background": "푸리에가 열전도 방정식을 풀기 위해 개발했습니다."
        },
        "applications": [
          { "field": "신호 처리", "description": "주파수 분석" },
          { "field": "음향학", "description": "음파 분석, 음성 인식" },
          { "field": "이미지 처리", "description": "JPEG 압축" }
        ]
      },
      "en": {
        "definition": "Fourier series represents periodic functions as infinite sums of sines and cosines. Any periodic function can be decomposed into oscillatory components.",
        "formulas": [
          {
            "latex": "f(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} (a_n \\cos nx + b_n \\sin nx)",
            "description": "Fourier series"
          },
          {
            "latex": "a_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(nx) dx",
            "description": "Fourier coefficient (cosine)"
          },
          {
            "latex": "b_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(nx) dx",
            "description": "Fourier coefficient (sine)"
          }
        ],
        "examples": [
          {
            "problem": "Find the Fourier series of f(x) = x for -π < x < π.",
            "solution": "a_n = 0 (odd function), b_n = 2(-1)^(n+1)/n. f(x) = 2(sin x - sin 2x/2 + sin 3x/3 - ...)"
          }
        ],
        "history": {
          "discoveredBy": "Joseph Fourier",
          "year": "1822",
          "background": "Fourier developed this to solve the heat equation."
        },
        "applications": [
          { "field": "Signal Processing", "description": "Frequency analysis" },
          { "field": "Acoustics", "description": "Sound analysis, speech recognition" },
          { "field": "Image Processing", "description": "JPEG compression" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["integral", "trigonometry"],
      "nextTopics": ["fourier-transform", "discrete-fourier"],
      "related": ["harmonic-analysis"]
    },
    "tags": ["푸리에", "급수", "Fourier", "series"]
  },
  {
    "id": "differential-equations",
    "name": { "ko": "미분방정식", "en": "Differential Equations" },
    "field": "applied",
    "subfield": "differential-eq",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "미분방정식은 미지 함수와 그 도함수들 사이의 관계를 나타내는 방정식입니다. 물리 현상을 모델링하는 기본 도구입니다.",
        "formulas": [
          { "latex": "\\frac{dy}{dx} = f(x, y)", "description": "1계 미분방정식" },
          {
            "latex": "\\frac{d^2y}{dx^2} + p\\frac{dy}{dx} + qy = 0",
            "description": "2계 선형 제차 미분방정식"
          },
          { "latex": "y = Ce^{rx}", "description": "지수형 해의 형태" }
        ],
        "examples": [
          {
            "problem": "dy/dx = 2y를 푸세요.",
            "solution": "변수분리: dy/y = 2dx, ln|y| = 2x + C, y = Ae^(2x)"
          },
          {
            "problem": "y'' + y = 0을 푸세요.",
            "solution": "특성방정식: r² + 1 = 0, r = ±i. 일반해: y = c₁cos x + c₂sin x"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "뉴턴 역학, 전자기학" },
          { "field": "생물학", "description": "개체군 성장, 감염병 모델" },
          { "field": "경제학", "description": "성장 모델" }
        ]
      },
      "en": {
        "definition": "A differential equation relates an unknown function to its derivatives. It's a fundamental tool for modeling physical phenomena.",
        "formulas": [
          {
            "latex": "\\frac{dy}{dx} = f(x, y)",
            "description": "First-order differential equation"
          },
          {
            "latex": "\\frac{d^2y}{dx^2} + p\\frac{dy}{dx} + qy = 0",
            "description": "Second-order linear homogeneous"
          },
          { "latex": "y = Ce^{rx}", "description": "Exponential solution form" }
        ],
        "examples": [
          {
            "problem": "Solve dy/dx = 2y.",
            "solution": "Separation: dy/y = 2dx, ln|y| = 2x + C, y = Ae^(2x)"
          },
          {
            "problem": "Solve y'' + y = 0.",
            "solution": "Characteristic: r² + 1 = 0, r = ±i. General: y = c₁cos x + c₂sin x"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Newtonian mechanics, electromagnetism" },
          { "field": "Biology", "description": "Population growth, epidemiology" },
          { "field": "Economics", "description": "Growth models" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "integral"],
      "nextTopics": ["partial-de", "numerical-ode"],
      "related": ["dynamical-systems"]
    },
    "tags": ["미분방정식", "ODE", "differential equation"]
  },
  {
    "id": "complex-analysis-basics",
    "name": { "ko": "복소해석학 기초", "en": "Complex Analysis Basics" },
    "field": "applied",
    "subfield": "complex-analysis",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "복소해석학은 복소수 함수의 미적분을 다룹니다. 해석함수는 미분 가능하고 아름다운 성질을 가집니다.",
        "formulas": [
          { "latex": "e^{i\\theta} = \\cos\\theta + i\\sin\\theta", "description": "오일러 공식" },
          {
            "latex": "\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y}, \\quad \\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x}",
            "description": "코시-리만 방정식"
          },
          { "latex": "\\oint_C f(z) dz = 0", "description": "코시 적분 정리 (단순 연결)" }
        ],
        "examples": [
          {
            "problem": "오일러 공식으로 e^(iπ)를 계산하세요.",
            "solution": "e^(iπ) = cos π + i sin π = -1 + 0i = -1"
          }
        ],
        "history": {
          "discoveredBy": "레온하르트 오일러, 오귀스탱 루이 코시",
          "year": "18-19세기",
          "background": "오일러가 공식을 발견했고, 코시가 복소함수 이론을 체계화했습니다."
        },
        "applications": [
          { "field": "전자공학", "description": "교류 회로 분석" },
          { "field": "유체역학", "description": "2D 유동" },
          { "field": "양자역학", "description": "파동함수" }
        ]
      },
      "en": {
        "definition": "Complex analysis studies calculus of complex-valued functions. Analytic functions are differentiable and have beautiful properties.",
        "formulas": [
          {
            "latex": "e^{i\\theta} = \\cos\\theta + i\\sin\\theta",
            "description": "Euler's formula"
          },
          {
            "latex": "\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y}, \\quad \\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x}",
            "description": "Cauchy-Riemann equations"
          },
          {
            "latex": "\\oint_C f(z) dz = 0",
            "description": "Cauchy's integral theorem (simply connected)"
          }
        ],
        "examples": [
          {
            "problem": "Calculate e^(iπ) using Euler's formula.",
            "solution": "e^(iπ) = cos π + i sin π = -1 + 0i = -1"
          }
        ],
        "history": {
          "discoveredBy": "Leonhard Euler, Augustin-Louis Cauchy",
          "year": "18th-19th century",
          "background": "Euler discovered the formula; Cauchy systematized complex function theory."
        },
        "applications": [
          { "field": "Electrical Engineering", "description": "AC circuit analysis" },
          { "field": "Fluid Dynamics", "description": "2D flow" },
          { "field": "Quantum Mechanics", "description": "Wave functions" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["complex-numbers", "derivative", "integral"],
      "nextTopics": ["residue-calculus", "conformal-mapping"],
      "related": ["fourier-transform"]
    },
    "tags": ["복소해석", "오일러", "complex analysis", "Euler"]
  },
  {
    "id": "game-theory",
    "name": { "ko": "게임 이론", "en": "Game Theory" },
    "field": "applied",
    "subfield": "game-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "게임 이론은 전략적 상호작용을 수학적으로 분석합니다. 플레이어들이 합리적으로 행동할 때의 결과를 예측합니다.",
        "formulas": [
          {
            "latex": "u_i(s^*_i, s^*_{-i}) \\geq u_i(s_i, s^*_{-i})",
            "description": "내쉬 균형 조건"
          }
        ],
        "examples": [
          {
            "problem": "죄수의 딜레마에서 내쉬 균형을 찾으세요.",
            "solution": "두 죄수가 모두 배신하는 것이 내쉬 균형입니다. 어느 쪽도 일방적으로 전략을 바꿔 이득을 볼 수 없습니다."
          }
        ],
        "history": {
          "discoveredBy": "존 폰 노이만, 존 내쉬",
          "year": "1928년, 1950년",
          "background": "폰 노이만이 기초를 세웠고, 내쉬가 균형 개념을 일반화했습니다."
        },
        "applications": [
          { "field": "경제학", "description": "시장 경쟁, 경매" },
          { "field": "정치학", "description": "투표, 협상" },
          { "field": "생물학", "description": "진화적 안정 전략" }
        ]
      },
      "en": {
        "definition": "Game theory mathematically analyzes strategic interactions. It predicts outcomes when players act rationally.",
        "formulas": [
          {
            "latex": "u_i(s^*_i, s^*_{-i}) \\geq u_i(s_i, s^*_{-i})",
            "description": "Nash equilibrium condition"
          }
        ],
        "examples": [
          {
            "problem": "Find the Nash equilibrium in the Prisoner's Dilemma.",
            "solution": "Both prisoners defecting is the Nash equilibrium. Neither can improve by unilaterally changing strategy."
          }
        ],
        "history": {
          "discoveredBy": "John von Neumann, John Nash",
          "year": "1928, 1950",
          "background": "Von Neumann laid foundations; Nash generalized the equilibrium concept."
        },
        "applications": [
          { "field": "Economics", "description": "Market competition, auctions" },
          { "field": "Political Science", "description": "Voting, negotiation" },
          { "field": "Biology", "description": "Evolutionarily stable strategies" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["probability-basics", "optimization-basics"],
      "nextTopics": ["mechanism-design", "cooperative-games"],
      "related": ["decision-theory"]
    },
    "tags": ["게임이론", "내쉬균형", "game theory", "Nash equilibrium"]
  },
  {
    "id": "cryptography-math",
    "name": { "ko": "암호학의 수학", "en": "Mathematics of Cryptography" },
    "field": "applied",
    "subfield": "cryptography",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "암호학은 정보를 안전하게 통신하기 위한 수학적 기법입니다. 수론, 대수학, 복잡도 이론에 기반합니다.",
        "formulas": [
          {
            "latex": "c = m^e \\mod n, \\quad m = c^d \\mod n",
            "description": "RSA 암호화/복호화"
          },
          { "latex": "ed \\equiv 1 \\pmod{\\phi(n)}", "description": "RSA 키 관계" }
        ],
        "examples": [
          {
            "problem": "p=3, q=11, e=3일 때 RSA로 m=5를 암호화하세요.",
            "solution": "n = 33, c = 5³ mod 33 = 125 mod 33 = 26"
          }
        ],
        "applications": [
          { "field": "인터넷 보안", "description": "HTTPS, TLS" },
          { "field": "전자상거래", "description": "결제 보안" },
          { "field": "블록체인", "description": "디지털 서명" }
        ]
      },
      "en": {
        "definition": "Cryptography uses mathematical techniques for secure communication. It's based on number theory, algebra, and complexity theory.",
        "formulas": [
          {
            "latex": "c = m^e \\mod n, \\quad m = c^d \\mod n",
            "description": "RSA encryption/decryption"
          },
          { "latex": "ed \\equiv 1 \\pmod{\\phi(n)}", "description": "RSA key relationship" }
        ],
        "examples": [
          {
            "problem": "Encrypt m=5 using RSA with p=3, q=11, e=3.",
            "solution": "n = 33, c = 5³ mod 33 = 125 mod 33 = 26"
          }
        ],
        "applications": [
          { "field": "Internet Security", "description": "HTTPS, TLS" },
          { "field": "E-commerce", "description": "Payment security" },
          { "field": "Blockchain", "description": "Digital signatures" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["modular-arithmetic", "prime-numbers", "fermats-little-theorem"],
      "nextTopics": ["elliptic-curve-crypto", "quantum-crypto"],
      "related": ["number-theory"]
    },
    "tags": ["암호학", "RSA", "cryptography", "security"]
  },
  {
    "id": "laplace-transform",
    "name": { "ko": "라플라스 변환", "en": "Laplace Transform" },
    "field": "applied",
    "subfield": "transforms",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "시간 영역의 함수를 주파수 영역으로 변환하여 미분방정식을 대수방정식으로 바꿉니다.",
        "formulas": [
          {
            "latex": "\\mathcal{L}\\{f(t)\\} = F(s) = \\int_0^{\\infty} f(t) e^{-st} dt",
            "description": "라플라스 변환 정의"
          },
          {
            "latex": "\\mathcal{L}\\{f'(t)\\} = sF(s) - f(0)",
            "description": "미분의 라플라스 변환"
          },
          { "latex": "\\mathcal{L}\\{e^{at}\\} = \\frac{1}{s-a}", "description": "지수함수의 변환" }
        ],
        "examples": [
          {
            "problem": "y' + 2y = 0, y(0) = 3을 라플라스 변환으로 푸시오.",
            "solution": "sY - 3 + 2Y = 0\nY(s+2) = 3\nY = 3/(s+2)\ny(t) = 3e^(-2t)",
            "difficulty": 4
          }
        ],
        "applications": [
          { "field": "제어공학", "description": "전달함수 분석" },
          { "field": "전자공학", "description": "회로 분석" },
          { "field": "기계공학", "description": "진동 분석" }
        ]
      },
      "en": {
        "definition": "Transforms time-domain functions to frequency domain, converting differential equations to algebraic equations.",
        "formulas": [
          {
            "latex": "\\mathcal{L}\\{f(t)\\} = F(s) = \\int_0^{\\infty} f(t) e^{-st} dt",
            "description": "Laplace transform definition"
          },
          {
            "latex": "\\mathcal{L}\\{f'(t)\\} = sF(s) - f(0)",
            "description": "Transform of derivative"
          },
          {
            "latex": "\\mathcal{L}\\{e^{at}\\} = \\frac{1}{s-a}",
            "description": "Exponential transform"
          }
        ],
        "examples": [
          {
            "problem": "Solve y' + 2y = 0, y(0) = 3 using Laplace transform.",
            "solution": "sY - 3 + 2Y = 0\nY(s+2) = 3\nY = 3/(s+2)\ny(t) = 3e^(-2t)",
            "difficulty": 4
          }
        ],
        "applications": [
          { "field": "Control Engineering", "description": "Transfer function analysis" },
          { "field": "Electronics", "description": "Circuit analysis" },
          { "field": "Mechanical Engineering", "description": "Vibration analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["integral", "differential-equations"],
      "nextTopics": ["z-transform"],
      "related": ["fourier-transform"]
    },
    "tags": ["라플라스", "변환", "Laplace", "transform"]
  },
  {
    "id": "gradient-descent",
    "name": { "ko": "경사하강법", "en": "Gradient Descent" },
    "field": "applied",
    "subfield": "optimization",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "함수의 최솟값을 찾기 위해 기울기(그래디언트)의 반대 방향으로 반복적으로 이동하는 최적화 알고리즘입니다.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\alpha \\nabla f(x_n)",
            "description": "경사하강법 업데이트 규칙"
          },
          { "latex": "\\alpha", "description": "학습률 (step size)" }
        ],
        "examples": [
          {
            "problem": "f(x) = x²를 경사하강법으로 최소화하시오 (x₀=5, α=0.1).",
            "solution": "f'(x) = 2x\nx₁ = 5 - 0.1(10) = 4\nx₂ = 4 - 0.1(8) = 3.2\n... (0으로 수렴)",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "머신러닝", "description": "신경망 학습" },
          { "field": "통계학", "description": "최대우도추정" },
          { "field": "경제학", "description": "비용 최소화" }
        ]
      },
      "en": {
        "definition": "An optimization algorithm that iteratively moves in the opposite direction of the gradient to find the minimum.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\alpha \\nabla f(x_n)",
            "description": "Gradient descent update rule"
          },
          { "latex": "\\alpha", "description": "Learning rate (step size)" }
        ],
        "examples": [
          {
            "problem": "Minimize f(x) = x² using gradient descent (x₀=5, α=0.1).",
            "solution": "f'(x) = 2x\nx₁ = 5 - 0.1(10) = 4\nx₂ = 4 - 0.1(8) = 3.2\n... (converges to 0)",
            "difficulty": 3
          }
        ],
        "applications": [
          { "field": "Machine Learning", "description": "Neural network training" },
          { "field": "Statistics", "description": "Maximum likelihood estimation" },
          { "field": "Economics", "description": "Cost minimization" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["partial-derivative", "vectors-basics"],
      "nextTopics": ["stochastic-gradient-descent", "adam-optimizer"],
      "related": ["newton-method"]
    },
    "tags": ["경사하강법", "최적화", "gradient descent", "optimization"]
  },
  {
    "id": "newton-method",
    "name": { "ko": "뉴턴-랩슨 방법", "en": "Newton-Raphson Method" },
    "field": "applied",
    "subfield": "numerical",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "방정식의 근을 반복적으로 근사하는 수치적 방법입니다. 접선을 이용해 더 나은 근사값을 찾습니다.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}",
            "description": "뉴턴-랩슨 반복 공식"
          }
        ],
        "examples": [
          {
            "problem": "√2를 뉴턴법으로 구하시오 (x₀=1).",
            "solution": "f(x) = x² - 2, f'(x) = 2x\nx₁ = 1 - (-1/2) = 1.5\nx₂ = 1.5 - 0.25/3 = 1.4167\nx₃ ≈ 1.4142...",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "아이작 뉴턴, 조지프 랩슨",
          "year": "17세기",
          "background": "뉴턴이 다항식의 근을 구하기 위해 개발했습니다."
        },
        "applications": [
          { "field": "수치해석", "description": "방정식의 근 찾기" },
          { "field": "최적화", "description": "함수 최적화" },
          { "field": "컴퓨터 그래픽", "description": "광선 추적" }
        ]
      },
      "en": {
        "definition": "A numerical method to iteratively approximate roots of equations using tangent lines.",
        "formulas": [
          {
            "latex": "x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}",
            "description": "Newton-Raphson iteration formula"
          }
        ],
        "examples": [
          {
            "problem": "Find √2 using Newton's method (x₀=1).",
            "solution": "f(x) = x² - 2, f'(x) = 2x\nx₁ = 1 - (-1/2) = 1.5\nx₂ = 1.5 - 0.25/3 = 1.4167\nx₃ ≈ 1.4142...",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "Isaac Newton, Joseph Raphson",
          "year": "17th century",
          "background": "Newton developed it to find roots of polynomials."
        },
        "applications": [
          { "field": "Numerical Analysis", "description": "Root finding" },
          { "field": "Optimization", "description": "Function optimization" },
          { "field": "Computer Graphics", "description": "Ray tracing" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "limit"],
      "nextTopics": ["secant-method"],
      "related": ["bisection-method"]
    },
    "tags": ["뉴턴법", "수치해석", "Newton", "numerical"]
  },
  {
    "id": "linear-programming",
    "name": { "ko": "선형계획법", "en": "Linear Programming" },
    "field": "applied",
    "subfield": "optimization",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "선형 제약조건 하에서 선형 목적함수를 최적화하는 수학적 방법입니다.",
        "formulas": [
          { "latex": "\\max/\\min \\quad c^T x", "description": "목적함수" },
          { "latex": "Ax \\leq b, \\quad x \\geq 0", "description": "제약조건" }
        ],
        "examples": [
          {
            "problem": "max 3x + 2y, subject to x + y ≤ 4, x ≤ 2, x, y ≥ 0",
            "solution": "꼭짓점: (0,0), (2,0), (2,2), (0,4)\n목적함수값: 0, 6, 10, 8\n최적해: (2,2), 최댓값: 10",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "조지 단치그",
          "year": "1947년",
          "background": "단치그가 심플렉스 알고리즘을 개발했습니다."
        },
        "applications": [
          { "field": "물류", "description": "수송 문제, 배치 최적화" },
          { "field": "생산", "description": "자원 배분" },
          { "field": "금융", "description": "포트폴리오 최적화" }
        ]
      },
      "en": {
        "definition": "A mathematical method to optimize a linear objective function subject to linear constraints.",
        "formulas": [
          { "latex": "\\max/\\min \\quad c^T x", "description": "Objective function" },
          { "latex": "Ax \\leq b, \\quad x \\geq 0", "description": "Constraints" }
        ],
        "examples": [
          {
            "problem": "max 3x + 2y, subject to x + y ≤ 4, x ≤ 2, x, y ≥ 0",
            "solution": "Vertices: (0,0), (2,0), (2,2), (0,4)\nObjective values: 0, 6, 10, 8\nOptimal: (2,2), max = 10",
            "difficulty": 3
          }
        ],
        "history": {
          "discoveredBy": "George Dantzig",
          "year": "1947",
          "background": "Dantzig developed the simplex algorithm."
        },
        "applications": [
          { "field": "Logistics", "description": "Transportation, allocation" },
          { "field": "Manufacturing", "description": "Resource allocation" },
          { "field": "Finance", "description": "Portfolio optimization" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["linear-equation", "inequality"],
      "nextTopics": ["integer-programming"],
      "related": ["simplex-method"]
    },
    "tags": ["선형계획", "최적화", "linear programming", "optimization"]
  },
  {
    "id": "pi-constant",
    "name": { "ko": "원주율 π", "en": "Pi (π)" },
    "field": "constants",
    "subfield": "fundamental",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "π(파이)는 원의 지름에 대한 둘레의 비율입니다. 무리수이며 초월수입니다. 수학에서 가장 중요한 상수 중 하나입니다.",
        "formulas": [
          {
            "latex": "\\pi = \\frac{C}{d} \\approx 3.14159265358979...",
            "description": "원주율의 정의"
          },
          { "latex": "A = \\pi r^2", "description": "원의 넓이" },
          { "latex": "e^{i\\pi} + 1 = 0", "description": "오일러 등식" },
          {
            "latex": "\\frac{\\pi}{4} = 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + ...",
            "description": "라이프니츠 급수"
          }
        ],
        "examples": [
          {
            "problem": "반지름이 5인 원의 넓이와 둘레를 구하세요.",
            "solution": "넓이 = π × 5² = 25π ≈ 78.54, 둘레 = 2π × 5 = 10π ≈ 31.42"
          }
        ],
        "history": {
          "discoveredBy": "고대 문명 (이집트, 바빌로니아)",
          "year": "기원전 2000년경",
          "background": "고대부터 근사값이 알려졌으며, 아르키메데스가 체계적으로 계산했습니다."
        },
        "applications": [
          { "field": "기하학", "description": "원, 구, 원기둥 계산" },
          { "field": "물리학", "description": "파동, 진동, 회전" },
          { "field": "통계학", "description": "정규분포" }
        ]
      },
      "en": {
        "definition": "π (pi) is the ratio of a circle's circumference to its diameter. It's irrational and transcendental, one of mathematics' most important constants.",
        "formulas": [
          {
            "latex": "\\pi = \\frac{C}{d} \\approx 3.14159265358979...",
            "description": "Definition of pi"
          },
          { "latex": "A = \\pi r^2", "description": "Area of a circle" },
          { "latex": "e^{i\\pi} + 1 = 0", "description": "Euler's identity" },
          {
            "latex": "\\frac{\\pi}{4} = 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + ...",
            "description": "Leibniz series"
          }
        ],
        "examples": [
          {
            "problem": "Find the area and circumference of a circle with radius 5.",
            "solution": "Area = π × 5² = 25π ≈ 78.54, Circumference = 2π × 5 = 10π ≈ 31.42"
          }
        ],
        "history": {
          "discoveredBy": "Ancient civilizations (Egypt, Babylon)",
          "year": "c. 2000 BCE",
          "background": "Approximations known since antiquity; Archimedes systematically calculated it."
        },
        "applications": [
          { "field": "Geometry", "description": "Circles, spheres, cylinders" },
          { "field": "Physics", "description": "Waves, oscillations, rotation" },
          { "field": "Statistics", "description": "Normal distribution" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["radians", "circle-area"],
      "related": ["e-constant", "euler-identity"]
    },
    "tags": ["파이", "원주율", "pi", "constant"]
  },
  {
    "id": "e-constant",
    "name": { "ko": "자연상수 e", "en": "Euler's Number (e)" },
    "field": "constants",
    "subfield": "fundamental",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "e는 자연로그의 밑으로, 연속 복리에서 자연스럽게 나타나는 수입니다. 미적분학에서 핵심적인 역할을 합니다.",
        "formulas": [
          {
            "latex": "e = \\lim_{n \\to \\infty} \\left(1 + \\frac{1}{n}\\right)^n \\approx 2.71828...",
            "description": "e의 극한 정의"
          },
          {
            "latex": "e = \\sum_{n=0}^{\\infty} \\frac{1}{n!} = 1 + 1 + \\frac{1}{2} + \\frac{1}{6} + ...",
            "description": "e의 급수 정의"
          },
          { "latex": "\\frac{d}{dx} e^x = e^x", "description": "자기 자신이 도함수인 성질" }
        ],
        "examples": [
          {
            "problem": "100원을 연이율 100%로 연속 복리 1년 예치하면?",
            "solution": "100 × e¹ ≈ 100 × 2.718 = 271.8원"
          }
        ],
        "history": {
          "discoveredBy": "레온하르트 오일러",
          "year": "1727년",
          "background": "야코프 베르누이가 복리 문제에서 발견했고, 오일러가 체계화했습니다."
        },
        "applications": [
          { "field": "금융", "description": "연속 복리, 성장 모델" },
          { "field": "물리학", "description": "방사성 붕괴, 열역학" },
          { "field": "확률론", "description": "포아송 분포" }
        ]
      },
      "en": {
        "definition": "e is the base of natural logarithm, appearing naturally in continuous compound interest. It plays a central role in calculus.",
        "formulas": [
          {
            "latex": "e = \\lim_{n \\to \\infty} \\left(1 + \\frac{1}{n}\\right)^n \\approx 2.71828...",
            "description": "Limit definition of e"
          },
          {
            "latex": "e = \\sum_{n=0}^{\\infty} \\frac{1}{n!} = 1 + 1 + \\frac{1}{2} + \\frac{1}{6} + ...",
            "description": "Series definition of e"
          },
          { "latex": "\\frac{d}{dx} e^x = e^x", "description": "Self-derivative property" }
        ],
        "examples": [
          {
            "problem": "Deposit $100 at 100% annual rate compounded continuously for 1 year.",
            "solution": "100 × e¹ ≈ 100 × 2.718 = $271.80"
          }
        ],
        "history": {
          "discoveredBy": "Leonhard Euler",
          "year": "1727",
          "background": "Jacob Bernoulli found it in compound interest; Euler systematized it."
        },
        "applications": [
          { "field": "Finance", "description": "Continuous compounding, growth models" },
          { "field": "Physics", "description": "Radioactive decay, thermodynamics" },
          { "field": "Probability", "description": "Poisson distribution" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["limits"],
      "nextTopics": ["natural-log", "exponential-function"],
      "related": ["pi-constant", "euler-identity"]
    },
    "tags": ["자연상수", "오일러", "e", "Euler"]
  },
  {
    "id": "golden-ratio",
    "name": { "ko": "황금비 φ", "en": "Golden Ratio (φ)" },
    "field": "constants",
    "subfield": "fundamental",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "황금비 φ(파이)는 전체 대 큰 부분의 비가 큰 부분 대 작은 부분의 비와 같을 때의 비율입니다.",
        "formulas": [
          {
            "latex": "\\phi = \\frac{1 + \\sqrt{5}}{2} \\approx 1.6180339...",
            "description": "황금비의 값"
          },
          { "latex": "\\phi^2 = \\phi + 1", "description": "황금비의 성질" },
          { "latex": "\\frac{1}{\\phi} = \\phi - 1", "description": "황금비의 역수" },
          {
            "latex": "\\lim_{n \\to \\infty} \\frac{F_{n+1}}{F_n} = \\phi",
            "description": "피보나치 수열과의 관계"
          }
        ],
        "examples": [
          {
            "problem": "1:φ 비율의 직사각형에서 정사각형을 제거하면?",
            "solution": "남은 직사각형도 1:φ 비율입니다. 이것이 황금 나선을 만듭니다."
          }
        ],
        "history": {
          "discoveredBy": "고대 그리스 (피타고라스 학파)",
          "year": "기원전 6세기경",
          "background": "유클리드가 '외중비'로 정의했고, 르네상스 시대에 '황금'이라 불리기 시작했습니다."
        },
        "applications": [
          { "field": "예술", "description": "구도, 비율" },
          { "field": "건축", "description": "파르테논 신전" },
          { "field": "자연", "description": "해바라기, 조개껍질" }
        ]
      },
      "en": {
        "definition": "The golden ratio φ (phi) is when the ratio of whole to larger part equals the ratio of larger to smaller part.",
        "formulas": [
          {
            "latex": "\\phi = \\frac{1 + \\sqrt{5}}{2} \\approx 1.6180339...",
            "description": "Value of golden ratio"
          },
          { "latex": "\\phi^2 = \\phi + 1", "description": "Golden ratio property" },
          { "latex": "\\frac{1}{\\phi} = \\phi - 1", "description": "Reciprocal of golden ratio" },
          {
            "latex": "\\lim_{n \\to \\infty} \\frac{F_{n+1}}{F_n} = \\phi",
            "description": "Relation to Fibonacci"
          }
        ],
        "examples": [
          {
            "problem": "Remove a square from a 1:φ rectangle. What remains?",
            "solution": "The remaining rectangle is also 1:φ ratio. This creates the golden spiral."
          }
        ],
        "history": {
          "discoveredBy": "Ancient Greeks (Pythagoreans)",
          "year": "c. 6th century BCE",
          "background": "Euclid defined it as 'extreme and mean ratio'; called 'golden' since Renaissance."
        },
        "applications": [
          { "field": "Art", "description": "Composition, proportions" },
          { "field": "Architecture", "description": "Parthenon" },
          { "field": "Nature", "description": "Sunflowers, shells" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["quadratic-equation"],
      "nextTopics": ["fibonacci"],
      "related": ["silver-ratio"]
    },
    "tags": ["황금비", "피보나치", "golden ratio", "phi"]
  },
  {
    "id": "imaginary-unit",
    "name": { "ko": "허수 단위 i", "en": "Imaginary Unit (i)" },
    "field": "constants",
    "subfield": "fundamental",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "i는 i² = -1을 만족하는 허수 단위입니다. 복소수의 기본이 되며, 수학과 공학에서 필수적입니다.",
        "formulas": [
          { "latex": "i = \\sqrt{-1}, \\quad i^2 = -1", "description": "허수 단위의 정의" },
          {
            "latex": "i^0 = 1, i^1 = i, i^2 = -1, i^3 = -i, i^4 = 1",
            "description": "i의 거듭제곱 주기"
          },
          { "latex": "z = a + bi", "description": "복소수의 일반형" }
        ],
        "examples": [
          {
            "problem": "i^100을 계산하세요.",
            "solution": "100 = 4 × 25이므로 i^100 = (i^4)^25 = 1^25 = 1"
          },
          {
            "problem": "(2 + 3i)(1 - i)를 계산하세요.",
            "solution": "2 - 2i + 3i - 3i² = 2 + i + 3 = 5 + i"
          }
        ],
        "history": {
          "discoveredBy": "제롤라모 카르다노",
          "year": "1545년",
          "background": "3차 방정식을 풀면서 도입되었고, 오일러와 가우스가 체계화했습니다."
        },
        "applications": [
          { "field": "전기공학", "description": "교류 회로, 임피던스" },
          { "field": "양자역학", "description": "파동함수" },
          { "field": "신호 처리", "description": "푸리에 변환" }
        ]
      },
      "en": {
        "definition": "i is the imaginary unit satisfying i² = -1. It's fundamental to complex numbers and essential in math and engineering.",
        "formulas": [
          {
            "latex": "i = \\sqrt{-1}, \\quad i^2 = -1",
            "description": "Definition of imaginary unit"
          },
          {
            "latex": "i^0 = 1, i^1 = i, i^2 = -1, i^3 = -i, i^4 = 1",
            "description": "Powers of i cycle"
          },
          { "latex": "z = a + bi", "description": "General form of complex number" }
        ],
        "examples": [
          {
            "problem": "Calculate i^100.",
            "solution": "100 = 4 × 25, so i^100 = (i^4)^25 = 1^25 = 1"
          },
          {
            "problem": "Calculate (2 + 3i)(1 - i).",
            "solution": "2 - 2i + 3i - 3i² = 2 + i + 3 = 5 + i"
          }
        ],
        "history": {
          "discoveredBy": "Gerolamo Cardano",
          "year": "1545",
          "background": "Introduced while solving cubic equations; Euler and Gauss systematized it."
        },
        "applications": [
          { "field": "Electrical Engineering", "description": "AC circuits, impedance" },
          { "field": "Quantum Mechanics", "description": "Wave functions" },
          { "field": "Signal Processing", "description": "Fourier transform" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["negative-numbers"],
      "nextTopics": ["complex-numbers", "complex-plane"],
      "related": ["euler-identity"]
    },
    "tags": ["허수", "복소수", "imaginary", "complex"]
  },
  {
    "id": "euler-mascheroni",
    "name": { "ko": "오일러-마스케로니 상수 γ", "en": "Euler-Mascheroni Constant (γ)" },
    "field": "constants",
    "subfield": "advanced",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "오일러-마스케로니 상수 γ는 조화급수와 자연로그의 차이의 극한입니다. 무리수인지조차 아직 증명되지 않았습니다.",
        "formulas": [
          {
            "latex": "\\gamma = \\lim_{n \\to \\infty} \\left( \\sum_{k=1}^{n} \\frac{1}{k} - \\ln n \\right) \\approx 0.5772...",
            "description": "오일러-마스케로니 상수의 정의"
          },
          {
            "latex": "\\gamma = \\int_1^{\\infty} \\left( \\frac{1}{\\lfloor x \\rfloor} - \\frac{1}{x} \\right) dx",
            "description": "적분 표현"
          }
        ],
        "examples": [
          {
            "problem": "조화급수 H_100과 ln(100)의 차이를 추정하세요.",
            "solution": "H_100 ≈ 5.187, ln(100) ≈ 4.605. 차이 ≈ 0.582 ≈ γ"
          }
        ],
        "history": {
          "discoveredBy": "레온하르트 오일러",
          "year": "1735년",
          "background": "오일러가 조화급수를 연구하면서 발견했습니다."
        },
        "applications": [
          { "field": "수론", "description": "소수 분포" },
          { "field": "해석학", "description": "감마 함수" },
          { "field": "확률론", "description": "극값 분포" }
        ]
      },
      "en": {
        "definition": "The Euler-Mascheroni constant γ is the limit of the difference between harmonic series and natural log. Whether it's irrational is still unknown.",
        "formulas": [
          {
            "latex": "\\gamma = \\lim_{n \\to \\infty} \\left( \\sum_{k=1}^{n} \\frac{1}{k} - \\ln n \\right) \\approx 0.5772...",
            "description": "Definition of Euler-Mascheroni constant"
          },
          {
            "latex": "\\gamma = \\int_1^{\\infty} \\left( \\frac{1}{\\lfloor x \\rfloor} - \\frac{1}{x} \\right) dx",
            "description": "Integral representation"
          }
        ],
        "examples": [
          {
            "problem": "Estimate the difference between H_100 and ln(100).",
            "solution": "H_100 ≈ 5.187, ln(100) ≈ 4.605. Difference ≈ 0.582 ≈ γ"
          }
        ],
        "history": {
          "discoveredBy": "Leonhard Euler",
          "year": "1735",
          "background": "Euler discovered it while studying the harmonic series."
        },
        "applications": [
          { "field": "Number Theory", "description": "Prime distribution" },
          { "field": "Analysis", "description": "Gamma function" },
          { "field": "Probability", "description": "Extreme value distributions" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["limits", "harmonic-series"],
      "nextTopics": ["gamma-function", "zeta-function"],
      "related": ["e-constant"]
    },
    "tags": ["오일러", "감마", "Euler-Mascheroni", "constant"]
  },
  {
    "id": "apery-constant",
    "name": { "ko": "아페리 상수 ζ(3)", "en": "Apéry's Constant ζ(3)" },
    "field": "constants",
    "subfield": "advanced",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "아페리 상수는 리만 제타 함수에서 ζ(3)의 값으로, 1978년 로제 아페리가 무리수임을 증명했습니다.",
        "formulas": [
          {
            "latex": "\\zeta(3) = \\sum_{n=1}^{\\infty} \\frac{1}{n^3} = 1 + \\frac{1}{8} + \\frac{1}{27} + ... \\approx 1.2020569...",
            "description": "아페리 상수의 정의"
          },
          {
            "latex": "\\zeta(3) = \\frac{5}{2} \\sum_{n=1}^{\\infty} \\frac{(-1)^{n-1}}{n^3 \\binom{2n}{n}}",
            "description": "아페리의 급수"
          }
        ],
        "examples": [
          {
            "problem": "ζ(3)의 처음 4항의 합을 구하세요.",
            "solution": "1 + 1/8 + 1/27 + 1/64 = 1 + 0.125 + 0.037 + 0.0156 ≈ 1.178"
          }
        ],
        "history": {
          "discoveredBy": "로제 아페리",
          "year": "1978년",
          "background": "200년 이상 미해결이던 ζ(3)의 무리수성을 증명하여 수학계에 충격을 주었습니다."
        },
        "applications": [
          { "field": "수론", "description": "제타 함수 연구" },
          { "field": "물리학", "description": "양자 전기역학" },
          { "field": "통계역학", "description": "보스 기체" }
        ]
      },
      "en": {
        "definition": "Apéry's constant is ζ(3) from the Riemann zeta function. Roger Apéry proved its irrationality in 1978.",
        "formulas": [
          {
            "latex": "\\zeta(3) = \\sum_{n=1}^{\\infty} \\frac{1}{n^3} = 1 + \\frac{1}{8} + \\frac{1}{27} + ... \\approx 1.2020569...",
            "description": "Definition of Apéry's constant"
          },
          {
            "latex": "\\zeta(3) = \\frac{5}{2} \\sum_{n=1}^{\\infty} \\frac{(-1)^{n-1}}{n^3 \\binom{2n}{n}}",
            "description": "Apéry's series"
          }
        ],
        "examples": [
          {
            "problem": "Find the sum of first 4 terms of ζ(3).",
            "solution": "1 + 1/8 + 1/27 + 1/64 = 1 + 0.125 + 0.037 + 0.0156 ≈ 1.178"
          }
        ],
        "history": {
          "discoveredBy": "Roger Apéry",
          "year": "1978",
          "background": "Proved irrationality of ζ(3) after 200+ years, shocking the mathematical community."
        },
        "applications": [
          { "field": "Number Theory", "description": "Zeta function research" },
          { "field": "Physics", "description": "Quantum electrodynamics" },
          { "field": "Statistical Mechanics", "description": "Bose gas" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["zeta-function", "series"],
      "nextTopics": ["riemann-hypothesis"],
      "related": ["euler-mascheroni", "pi-constant"]
    },
    "tags": ["아페리", "제타함수", "Apéry", "zeta"]
  },
  {
    "id": "catalan-constant",
    "name": { "ko": "카탈랑 상수 G", "en": "Catalan's Constant (G)" },
    "field": "constants",
    "subfield": "advanced",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "카탈랑 상수는 교대 급수로 정의되는 상수입니다. 무리수인지 여부는 아직 증명되지 않았습니다.",
        "formulas": [
          {
            "latex": "G = \\sum_{n=0}^{\\infty} \\frac{(-1)^n}{(2n+1)^2} = 1 - \\frac{1}{9} + \\frac{1}{25} - \\frac{1}{49} + ... \\approx 0.9159655...",
            "description": "카탈랑 상수의 정의"
          },
          { "latex": "G = \\int_0^1 \\frac{\\arctan x}{x} dx", "description": "적분 표현" },
          { "latex": "G = \\beta(2)", "description": "디리클레 베타 함수 관계" }
        ],
        "examples": [
          {
            "problem": "카탈랑 상수의 처음 4항을 구하세요.",
            "solution": "1 - 1/9 + 1/25 - 1/49 = 1 - 0.111 + 0.04 - 0.0204 ≈ 0.909"
          }
        ],
        "history": {
          "discoveredBy": "외젠 샤를 카탈랑",
          "year": "1865년",
          "background": "조합론과 해석학의 다양한 문제에서 자연스럽게 등장합니다."
        },
        "applications": [
          { "field": "조합론", "description": "격자 경로 계산" },
          { "field": "물리학", "description": "이징 모델" },
          { "field": "확률론", "description": "랜덤 워크" }
        ]
      },
      "en": {
        "definition": "Catalan's constant is defined by an alternating series. Whether it's irrational remains unproven.",
        "formulas": [
          {
            "latex": "G = \\sum_{n=0}^{\\infty} \\frac{(-1)^n}{(2n+1)^2} = 1 - \\frac{1}{9} + \\frac{1}{25} - \\frac{1}{49} + ... \\approx 0.9159655...",
            "description": "Definition of Catalan's constant"
          },
          {
            "latex": "G = \\int_0^1 \\frac{\\arctan x}{x} dx",
            "description": "Integral representation"
          },
          { "latex": "G = \\beta(2)", "description": "Dirichlet beta function relation" }
        ],
        "examples": [
          {
            "problem": "Find the first 4 terms of Catalan's constant.",
            "solution": "1 - 1/9 + 1/25 - 1/49 = 1 - 0.111 + 0.04 - 0.0204 ≈ 0.909"
          }
        ],
        "history": {
          "discoveredBy": "Eugène Charles Catalan",
          "year": "1865",
          "background": "Appears naturally in various combinatorics and analysis problems."
        },
        "applications": [
          { "field": "Combinatorics", "description": "Lattice path counting" },
          { "field": "Physics", "description": "Ising model" },
          { "field": "Probability", "description": "Random walks" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["series", "integration"],
      "nextTopics": ["dirichlet-beta"],
      "related": ["apery-constant", "pi-constant"]
    },
    "tags": ["카탈랑", "교대급수", "Catalan", "constant"]
  },
  {
    "id": "sqrt2-constant",
    "name": { "ko": "√2 (피타고라스 상수)", "en": "√2 (Pythagoras' Constant)" },
    "field": "constants",
    "subfield": "fundamental",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "√2는 한 변이 1인 정사각형의 대각선 길이입니다. 최초로 발견된 무리수로, 피타고라스 학파에 큰 충격을 주었습니다.",
        "formulas": [
          { "latex": "\\sqrt{2} = 1.41421356237...", "description": "√2의 값" },
          {
            "latex": "\\sqrt{2} = 1 + \\cfrac{1}{2 + \\cfrac{1}{2 + \\cfrac{1}{2 + ...}}}",
            "description": "연분수 표현"
          },
          {
            "latex": "\\left(\\frac{p}{q}\\right)^2 \\neq 2 \\text{ (모든 정수 } p, q \\text{에 대해)}",
            "description": "무리수 증명"
          }
        ],
        "examples": [
          {
            "problem": "한 변이 5인 정사각형의 대각선 길이는?",
            "solution": "대각선 = 5√2 ≈ 5 × 1.414 = 7.07"
          },
          {
            "problem": "√2가 무리수임을 증명하세요.",
            "solution": "귀류법: p/q = √2 가정 → p² = 2q² → p는 짝수 → p=2k → 4k² = 2q² → q도 짝수. 모순."
          }
        ],
        "history": {
          "discoveredBy": "피타고라스 학파 (히파수스)",
          "year": "기원전 5세기경",
          "background": "최초의 무리수 발견으로, 피타고라스 학파의 '모든 수는 유리수' 신념을 깨뜨렸습니다."
        },
        "applications": [
          { "field": "기하학", "description": "대각선, 정사각형" },
          { "field": "공학", "description": "A4 용지 비율 (1:√2)" },
          { "field": "음악", "description": "반음 비율" }
        ]
      },
      "en": {
        "definition": "√2 is the diagonal length of a unit square. The first discovered irrational number, it shocked the Pythagorean school.",
        "formulas": [
          { "latex": "\\sqrt{2} = 1.41421356237...", "description": "Value of √2" },
          {
            "latex": "\\sqrt{2} = 1 + \\cfrac{1}{2 + \\cfrac{1}{2 + \\cfrac{1}{2 + ...}}}",
            "description": "Continued fraction"
          },
          {
            "latex": "\\left(\\frac{p}{q}\\right)^2 \\neq 2 \\text{ (for all integers } p, q \\text{)}",
            "description": "Irrationality proof"
          }
        ],
        "examples": [
          {
            "problem": "What is the diagonal of a square with side 5?",
            "solution": "Diagonal = 5√2 ≈ 5 × 1.414 = 7.07"
          },
          {
            "problem": "Prove √2 is irrational.",
            "solution": "By contradiction: Assume p/q = √2 → p² = 2q² → p is even → p=2k → 4k² = 2q² → q is even. Contradiction."
          }
        ],
        "history": {
          "discoveredBy": "Pythagorean school (Hippasus)",
          "year": "c. 5th century BCE",
          "background": "First irrational number discovered, shattering Pythagorean belief that all numbers are rational."
        },
        "applications": [
          { "field": "Geometry", "description": "Diagonals, squares" },
          { "field": "Engineering", "description": "A4 paper ratio (1:√2)" },
          { "field": "Music", "description": "Semitone ratio" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["pythagorean-theorem"],
      "nextTopics": ["irrational-numbers", "golden-ratio"],
      "related": ["pi-constant", "proof-by-contradiction"]
    },
    "tags": ["루트2", "무리수", "sqrt2", "Pythagoras"]
  },
  {
    "id": "feigenbaum-constant",
    "name": { "ko": "파이겐바움 상수 δ", "en": "Feigenbaum Constant (δ)" },
    "field": "constants",
    "subfield": "advanced",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "파이겐바움 상수 δ는 카오스 이론에서 발견된 보편 상수로, 분기점 사이의 비율이 수렴하는 값입니다.",
        "formulas": [
          {
            "latex": "\\delta = \\lim_{n \\to \\infty} \\frac{a_{n-1} - a_{n-2}}{a_n - a_{n-1}} \\approx 4.6692016...",
            "description": "분기점 비율의 극한"
          },
          {
            "latex": "\\alpha \\approx 2.5029...",
            "description": "두 번째 파이겐바움 상수 (스케일링)"
          }
        ],
        "examples": [
          {
            "problem": "로지스틱 맵 x_{n+1} = rx_n(1-x_n)에서 분기가 일어나는 r 값들의 비율은?",
            "solution": "r₁ ≈ 3, r₂ ≈ 3.449, r₃ ≈ 3.544... 비율이 δ ≈ 4.669로 수렴합니다."
          }
        ],
        "history": {
          "discoveredBy": "미첼 파이겐바움",
          "year": "1975년",
          "background": "카오스 이론의 핵심 발견으로, 비선형 시스템의 보편적 특성을 보여줍니다."
        },
        "applications": [
          { "field": "카오스 이론", "description": "분기 분석" },
          { "field": "물리학", "description": "난류, 비선형 진동" },
          { "field": "생태학", "description": "개체군 동역학" }
        ]
      },
      "en": {
        "definition": "The Feigenbaum constant δ is a universal constant in chaos theory, the limiting ratio between bifurcation points.",
        "formulas": [
          {
            "latex": "\\delta = \\lim_{n \\to \\infty} \\frac{a_{n-1} - a_{n-2}}{a_n - a_{n-1}} \\approx 4.6692016...",
            "description": "Limit of bifurcation ratios"
          },
          {
            "latex": "\\alpha \\approx 2.5029...",
            "description": "Second Feigenbaum constant (scaling)"
          }
        ],
        "examples": [
          {
            "problem": "In logistic map x_{n+1} = rx_n(1-x_n), what's the ratio of bifurcation r values?",
            "solution": "r₁ ≈ 3, r₂ ≈ 3.449, r₃ ≈ 3.544... The ratio converges to δ ≈ 4.669."
          }
        ],
        "history": {
          "discoveredBy": "Mitchell Feigenbaum",
          "year": "1975",
          "background": "Key discovery in chaos theory, showing universal properties of nonlinear systems."
        },
        "applications": [
          { "field": "Chaos Theory", "description": "Bifurcation analysis" },
          { "field": "Physics", "description": "Turbulence, nonlinear oscillations" },
          { "field": "Ecology", "description": "Population dynamics" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["dynamical-systems", "limits"],
      "nextTopics": ["chaos-theory", "fractals"],
      "related": ["logistic-map", "bifurcation"]
    },
    "tags": ["파이겐바움", "카오스", "Feigenbaum", "chaos"]
  },
  {
    "id": "summation-notation",
    "name": { "ko": "합의 기호 Σ", "en": "Summation Notation (Σ)" },
    "field": "symbols",
    "subfield": "operations",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "Σ(시그마)는 연속된 항들의 합을 간결하게 표현하는 기호입니다. 아래에 시작 인덱스, 위에 끝 인덱스를 씁니다.",
        "formulas": [
          {
            "latex": "\\sum_{i=1}^{n} a_i = a_1 + a_2 + ... + a_n",
            "description": "합의 기호 정의"
          },
          {
            "latex": "\\sum_{i=1}^{n} c \\cdot a_i = c \\sum_{i=1}^{n} a_i",
            "description": "상수 인수 분리"
          },
          {
            "latex": "\\sum_{i=1}^{n} (a_i + b_i) = \\sum_{i=1}^{n} a_i + \\sum_{i=1}^{n} b_i",
            "description": "합의 분배"
          }
        ],
        "examples": [
          {
            "problem": "Σᵢ₌₁⁵ i² 를 계산하세요.",
            "solution": "1² + 2² + 3² + 4² + 5² = 1 + 4 + 9 + 16 + 25 = 55"
          },
          { "problem": "Σᵢ₌₁ⁿ i = ?", "solution": "1 + 2 + ... + n = n(n+1)/2" }
        ],
        "applications": [
          { "field": "통계학", "description": "평균, 분산 계산" },
          { "field": "수열", "description": "급수의 합" },
          { "field": "프로그래밍", "description": "반복문 표현" }
        ]
      },
      "en": {
        "definition": "Σ (sigma) is a symbol for expressing sums of consecutive terms concisely. Lower index below, upper index above.",
        "formulas": [
          {
            "latex": "\\sum_{i=1}^{n} a_i = a_1 + a_2 + ... + a_n",
            "description": "Summation definition"
          },
          {
            "latex": "\\sum_{i=1}^{n} c \\cdot a_i = c \\sum_{i=1}^{n} a_i",
            "description": "Constant factor"
          },
          {
            "latex": "\\sum_{i=1}^{n} (a_i + b_i) = \\sum_{i=1}^{n} a_i + \\sum_{i=1}^{n} b_i",
            "description": "Sum distribution"
          }
        ],
        "examples": [
          {
            "problem": "Calculate Σᵢ₌₁⁵ i².",
            "solution": "1² + 2² + 3² + 4² + 5² = 1 + 4 + 9 + 16 + 25 = 55"
          },
          { "problem": "Σᵢ₌₁ⁿ i = ?", "solution": "1 + 2 + ... + n = n(n+1)/2" }
        ],
        "applications": [
          { "field": "Statistics", "description": "Mean, variance calculation" },
          { "field": "Sequences", "description": "Series sums" },
          { "field": "Programming", "description": "Loop representation" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["product-notation", "series"],
      "related": ["integral"]
    },
    "tags": ["시그마", "합", "summation", "sigma"]
  },
  {
    "id": "product-notation",
    "name": { "ko": "곱의 기호 Π", "en": "Product Notation (Π)" },
    "field": "symbols",
    "subfield": "operations",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "Π(파이)는 연속된 항들의 곱을 간결하게 표현하는 기호입니다. 팩토리얼과 조합에서 자주 사용됩니다.",
        "formulas": [
          {
            "latex": "\\prod_{i=1}^{n} a_i = a_1 \\times a_2 \\times ... \\times a_n",
            "description": "곱의 기호 정의"
          },
          { "latex": "n! = \\prod_{i=1}^{n} i", "description": "팩토리얼의 표현" }
        ],
        "examples": [
          { "problem": "Πᵢ₌₁⁵ i 를 계산하세요.", "solution": "1 × 2 × 3 × 4 × 5 = 120 = 5!" },
          { "problem": "Πᵢ₌₁³ 2i 를 계산하세요.", "solution": "2 × 4 × 6 = 48" }
        ],
        "applications": [
          { "field": "확률론", "description": "독립 사건의 확률" },
          { "field": "수론", "description": "소인수분해" },
          { "field": "조합론", "description": "팩토리얼, 순열" }
        ]
      },
      "en": {
        "definition": "Π (capital pi) is a symbol for expressing products of consecutive terms. Often used in factorials and combinations.",
        "formulas": [
          {
            "latex": "\\prod_{i=1}^{n} a_i = a_1 \\times a_2 \\times ... \\times a_n",
            "description": "Product definition"
          },
          { "latex": "n! = \\prod_{i=1}^{n} i", "description": "Factorial representation" }
        ],
        "examples": [
          { "problem": "Calculate Πᵢ₌₁⁵ i.", "solution": "1 × 2 × 3 × 4 × 5 = 120 = 5!" },
          { "problem": "Calculate Πᵢ₌₁³ 2i.", "solution": "2 × 4 × 6 = 48" }
        ],
        "applications": [
          { "field": "Probability", "description": "Independent event probabilities" },
          { "field": "Number Theory", "description": "Prime factorization" },
          { "field": "Combinatorics", "description": "Factorials, permutations" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["factorial", "combinations"],
      "related": ["summation-notation"]
    },
    "tags": ["파이", "곱", "product", "pi notation"]
  },
  {
    "id": "infinity-symbol",
    "name": { "ko": "무한대 ∞", "en": "Infinity (∞)" },
    "field": "symbols",
    "subfield": "special",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "∞(무한대)는 한없이 커지는 개념을 나타내는 기호입니다. 극한, 적분, 집합론에서 사용됩니다.",
        "formulas": [
          { "latex": "\\lim_{x \\to \\infty} f(x)", "description": "x가 무한대로 갈 때의 극한" },
          { "latex": "\\int_0^{\\infty} f(x) dx", "description": "무한 적분" },
          {
            "latex": "\\infty + 1 = \\infty, \\quad \\infty \\cdot 2 = \\infty",
            "description": "무한대의 연산 (주의 필요)"
          }
        ],
        "examples": [
          {
            "problem": "lim(x→∞) 1/x를 구하세요.",
            "solution": "x가 커질수록 1/x는 0에 가까워지므로, 극한값은 0입니다."
          }
        ],
        "history": {
          "discoveredBy": "존 월리스",
          "year": "1655년",
          "background": "월리스가 이 기호를 처음 사용했으며, 칸토어가 무한의 종류를 구분했습니다."
        },
        "applications": [
          { "field": "해석학", "description": "극한, 수렴" },
          { "field": "집합론", "description": "무한집합의 크기" },
          { "field": "물리학", "description": "점근적 행동" }
        ]
      },
      "en": {
        "definition": "∞ (infinity) represents the concept of unboundedness. Used in limits, integrals, and set theory.",
        "formulas": [
          {
            "latex": "\\lim_{x \\to \\infty} f(x)",
            "description": "Limit as x approaches infinity"
          },
          { "latex": "\\int_0^{\\infty} f(x) dx", "description": "Improper integral" },
          {
            "latex": "\\infty + 1 = \\infty, \\quad \\infty \\cdot 2 = \\infty",
            "description": "Infinity operations (caution needed)"
          }
        ],
        "examples": [
          {
            "problem": "Find lim(x→∞) 1/x.",
            "solution": "As x grows, 1/x approaches 0, so the limit is 0."
          }
        ],
        "history": {
          "discoveredBy": "John Wallis",
          "year": "1655",
          "background": "Wallis first used this symbol; Cantor distinguished types of infinity."
        },
        "applications": [
          { "field": "Analysis", "description": "Limits, convergence" },
          { "field": "Set Theory", "description": "Cardinality of infinite sets" },
          { "field": "Physics", "description": "Asymptotic behavior" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["limits", "improper-integrals"],
      "related": ["aleph-numbers"]
    },
    "tags": ["무한", "극한", "infinity", "unbounded"]
  },
  {
    "id": "partial-derivative-symbol",
    "name": { "ko": "편미분 기호 ∂", "en": "Partial Derivative (∂)" },
    "field": "symbols",
    "subfield": "calculus",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "∂는 다변수 함수에서 한 변수에 대해서만 미분할 때 사용하는 기호입니다. 다른 변수는 상수로 취급합니다.",
        "formulas": [
          { "latex": "\\frac{\\partial f}{\\partial x}", "description": "x에 대한 편미분" },
          {
            "latex": "\\frac{\\partial^2 f}{\\partial x \\partial y}",
            "description": "혼합 편미분"
          },
          {
            "latex": "\\nabla f = \\left( \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\right)",
            "description": "그래디언트"
          }
        ],
        "examples": [
          {
            "problem": "f(x,y) = x²y + y³에서 ∂f/∂x를 구하세요.",
            "solution": "y를 상수로 보고 x로 미분: ∂f/∂x = 2xy"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "열역학, 전자기학" },
          { "field": "경제학", "description": "한계 효용, 한계 비용" },
          { "field": "기계학습", "description": "역전파 알고리즘" }
        ]
      },
      "en": {
        "definition": "∂ is used for differentiating multivariable functions with respect to one variable, treating others as constants.",
        "formulas": [
          {
            "latex": "\\frac{\\partial f}{\\partial x}",
            "description": "Partial derivative with respect to x"
          },
          {
            "latex": "\\frac{\\partial^2 f}{\\partial x \\partial y}",
            "description": "Mixed partial derivative"
          },
          {
            "latex": "\\nabla f = \\left( \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\right)",
            "description": "Gradient"
          }
        ],
        "examples": [
          {
            "problem": "Find ∂f/∂x for f(x,y) = x²y + y³.",
            "solution": "Treating y as constant: ∂f/∂x = 2xy"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Thermodynamics, electromagnetism" },
          { "field": "Economics", "description": "Marginal utility, marginal cost" },
          { "field": "Machine Learning", "description": "Backpropagation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative"],
      "nextTopics": ["gradient", "jacobian"],
      "related": ["total-derivative"]
    },
    "tags": ["편미분", "다변수", "partial", "derivative"]
  },
  {
    "id": "set-notation",
    "name": { "ko": "집합 기호", "en": "Set Notation" },
    "field": "symbols",
    "subfield": "sets",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "집합 기호는 집합과 그 연산을 표현하는 기호들입니다. ∈, ⊆, ∪, ∩ 등이 있습니다.",
        "formulas": [
          { "latex": "x \\in A", "description": "x는 A의 원소" },
          { "latex": "A \\subseteq B", "description": "A는 B의 부분집합" },
          { "latex": "A \\cup B", "description": "합집합" },
          { "latex": "A \\cap B", "description": "교집합" },
          { "latex": "A^c \\text{ or } \\bar{A}", "description": "여집합" },
          { "latex": "\\emptyset \\text{ or } \\{\\}", "description": "공집합" }
        ],
        "examples": [
          {
            "problem": "A = {1, 2, 3}일 때 2 ∈ A인지 확인하세요.",
            "solution": "2는 A의 원소이므로 2 ∈ A는 참입니다."
          }
        ],
        "applications": [
          { "field": "논리학", "description": "명제의 진리집합" },
          { "field": "데이터베이스", "description": "쿼리 연산" },
          { "field": "프로그래밍", "description": "자료구조" }
        ]
      },
      "en": {
        "definition": "Set notation includes symbols for sets and their operations: ∈, ⊆, ∪, ∩, etc.",
        "formulas": [
          { "latex": "x \\in A", "description": "x is an element of A" },
          { "latex": "A \\subseteq B", "description": "A is a subset of B" },
          { "latex": "A \\cup B", "description": "Union" },
          { "latex": "A \\cap B", "description": "Intersection" },
          { "latex": "A^c \\text{ or } \\bar{A}", "description": "Complement" },
          { "latex": "\\emptyset \\text{ or } \\{\\}", "description": "Empty set" }
        ],
        "examples": [
          {
            "problem": "If A = {1, 2, 3}, check if 2 ∈ A.",
            "solution": "2 is an element of A, so 2 ∈ A is true."
          }
        ],
        "applications": [
          { "field": "Logic", "description": "Truth sets" },
          { "field": "Databases", "description": "Query operations" },
          { "field": "Programming", "description": "Data structures" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["sets", "venn-diagrams"],
      "related": ["logic-symbols"]
    },
    "tags": ["집합", "원소", "set", "element"]
  },
  {
    "id": "nabla-operator",
    "name": { "ko": "나블라 연산자 ∇", "en": "Nabla Operator (∇)" },
    "field": "symbols",
    "subfield": "calculus",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "∇(나블라, 델)는 벡터 미분 연산자입니다. 그래디언트, 발산, 회전을 표현하는 데 사용됩니다.",
        "formulas": [
          {
            "latex": "\\nabla = \\left( \\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y}, \\frac{\\partial}{\\partial z} \\right)",
            "description": "나블라의 정의"
          },
          { "latex": "\\nabla f", "description": "그래디언트 (스칼라장 → 벡터장)" },
          { "latex": "\\nabla \\cdot \\vec{F}", "description": "발산 (벡터장 → 스칼라장)" },
          { "latex": "\\nabla \\times \\vec{F}", "description": "회전 (벡터장 → 벡터장)" },
          { "latex": "\\nabla^2 = \\nabla \\cdot \\nabla", "description": "라플라시안" }
        ],
        "examples": [
          {
            "problem": "f(x,y,z) = x² + y² + z²의 그래디언트를 구하세요.",
            "solution": "∇f = (2x, 2y, 2z)"
          }
        ],
        "applications": [
          { "field": "전자기학", "description": "맥스웰 방정식" },
          { "field": "유체역학", "description": "유동 분석" },
          { "field": "최적화", "description": "경사 하강법" }
        ]
      },
      "en": {
        "definition": "∇ (nabla, del) is a vector differential operator. Used for gradient, divergence, and curl.",
        "formulas": [
          {
            "latex": "\\nabla = \\left( \\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y}, \\frac{\\partial}{\\partial z} \\right)",
            "description": "Definition of nabla"
          },
          { "latex": "\\nabla f", "description": "Gradient (scalar → vector field)" },
          {
            "latex": "\\nabla \\cdot \\vec{F}",
            "description": "Divergence (vector → scalar field)"
          },
          { "latex": "\\nabla \\times \\vec{F}", "description": "Curl (vector → vector field)" },
          { "latex": "\\nabla^2 = \\nabla \\cdot \\nabla", "description": "Laplacian" }
        ],
        "examples": [
          {
            "problem": "Find the gradient of f(x,y,z) = x² + y² + z².",
            "solution": "∇f = (2x, 2y, 2z)"
          }
        ],
        "applications": [
          { "field": "Electromagnetism", "description": "Maxwell's equations" },
          { "field": "Fluid Dynamics", "description": "Flow analysis" },
          { "field": "Optimization", "description": "Gradient descent" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["partial-derivative-symbol", "vector-basics"],
      "nextTopics": ["divergence", "curl", "laplacian"],
      "related": ["maxwell-equations"]
    },
    "tags": ["나블라", "벡터미분", "nabla", "del"]
  },
  {
    "id": "integral-symbol",
    "name": { "ko": "적분 기호 ∫", "en": "Integral Sign (∫)" },
    "field": "symbols",
    "subfield": "calculus",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "∫는 적분을 나타내는 기호로, 라이프니츠가 'Sum(합)'의 S를 길게 늘인 형태에서 유래했습니다.",
        "formulas": [
          { "latex": "\\int f(x) \\, dx", "description": "부정적분" },
          { "latex": "\\int_a^b f(x) \\, dx", "description": "정적분 (a에서 b까지)" },
          { "latex": "\\iint f(x,y) \\, dA", "description": "이중적분" },
          { "latex": "\\oint_C \\vec{F} \\cdot d\\vec{r}", "description": "선적분 (폐곡선)" }
        ],
        "examples": [
          { "problem": "∫ x² dx를 구하세요.", "solution": "∫ x² dx = x³/3 + C" },
          { "problem": "∫₀¹ 2x dx를 구하세요.", "solution": "[x²]₀¹ = 1² - 0² = 1" }
        ],
        "history": {
          "discoveredBy": "고트프리트 빌헬름 라이프니츠",
          "year": "1675년",
          "background": "라이프니츠가 미적분학을 체계화하면서 도입한 기호입니다."
        },
        "applications": [
          { "field": "물리학", "description": "일, 에너지 계산" },
          { "field": "확률론", "description": "연속확률분포" },
          { "field": "공학", "description": "신호 처리, 제어" }
        ]
      },
      "en": {
        "definition": "∫ is the integral sign, derived by Leibniz from an elongated S for 'Sum'.",
        "formulas": [
          { "latex": "\\int f(x) \\, dx", "description": "Indefinite integral" },
          { "latex": "\\int_a^b f(x) \\, dx", "description": "Definite integral (from a to b)" },
          { "latex": "\\iint f(x,y) \\, dA", "description": "Double integral" },
          {
            "latex": "\\oint_C \\vec{F} \\cdot d\\vec{r}",
            "description": "Line integral (closed curve)"
          }
        ],
        "examples": [
          { "problem": "Find ∫ x² dx.", "solution": "∫ x² dx = x³/3 + C" },
          { "problem": "Find ∫₀¹ 2x dx.", "solution": "[x²]₀¹ = 1² - 0² = 1" }
        ],
        "history": {
          "discoveredBy": "Gottfried Wilhelm Leibniz",
          "year": "1675",
          "background": "Leibniz introduced this symbol while systematizing calculus."
        },
        "applications": [
          { "field": "Physics", "description": "Work, energy calculations" },
          { "field": "Probability", "description": "Continuous distributions" },
          { "field": "Engineering", "description": "Signal processing, control" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative"],
      "nextTopics": ["fundamental-theorem-calculus", "integration-techniques"],
      "related": ["summation-notation"]
    },
    "tags": ["적분", "미적분", "integral", "calculus"]
  },
  {
    "id": "quantifier-symbols",
    "name": { "ko": "한정사 기호 ∀, ∃", "en": "Quantifier Symbols (∀, ∃)" },
    "field": "symbols",
    "subfield": "logic",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "∀(전칭 한정사)는 '모든'을, ∃(존재 한정사)는 '존재한다'를 의미합니다. 수학적 명제를 정확하게 표현합니다.",
        "formulas": [
          { "latex": "\\forall x \\in A, P(x)", "description": "A의 모든 x에 대해 P(x)가 참" },
          { "latex": "\\exists x \\in A, P(x)", "description": "P(x)를 만족하는 x가 A에 존재" },
          { "latex": "\\exists! x, P(x)", "description": "P(x)를 만족하는 유일한 x가 존재" },
          {
            "latex": "\\neg(\\forall x, P(x)) \\equiv \\exists x, \\neg P(x)",
            "description": "한정사의 부정"
          }
        ],
        "examples": [
          {
            "problem": "∀x ∈ ℝ, x² ≥ 0 의 의미는?",
            "solution": "모든 실수 x에 대해 x의 제곱은 0 이상이다. (참)"
          },
          {
            "problem": "∃x ∈ ℤ, x² = 2의 의미는?",
            "solution": "제곱이 2인 정수가 존재한다. (거짓, √2는 무리수)"
          }
        ],
        "history": {
          "discoveredBy": "게르하르트 겐첸",
          "year": "1935년",
          "background": "프레게와 피아노의 기호논리학을 바탕으로 현대적 형태가 확립되었습니다."
        },
        "applications": [
          { "field": "논리학", "description": "명제 논리, 술어 논리" },
          { "field": "수학", "description": "정리 진술, 증명" },
          { "field": "컴퓨터 과학", "description": "프로그램 검증" }
        ]
      },
      "en": {
        "definition": "∀ (universal quantifier) means 'for all', ∃ (existential quantifier) means 'there exists'. Used for precise mathematical statements.",
        "formulas": [
          { "latex": "\\forall x \\in A, P(x)", "description": "P(x) is true for all x in A" },
          {
            "latex": "\\exists x \\in A, P(x)",
            "description": "There exists x in A such that P(x)"
          },
          { "latex": "\\exists! x, P(x)", "description": "There exists unique x satisfying P(x)" },
          {
            "latex": "\\neg(\\forall x, P(x)) \\equiv \\exists x, \\neg P(x)",
            "description": "Negation of quantifiers"
          }
        ],
        "examples": [
          {
            "problem": "What does ∀x ∈ ℝ, x² ≥ 0 mean?",
            "solution": "For all real numbers x, x squared is non-negative. (True)"
          },
          {
            "problem": "What does ∃x ∈ ℤ, x² = 2 mean?",
            "solution": "There exists an integer whose square is 2. (False, √2 is irrational)"
          }
        ],
        "history": {
          "discoveredBy": "Gerhard Gentzen",
          "year": "1935",
          "background": "Modern form established based on symbolic logic of Frege and Peano."
        },
        "applications": [
          { "field": "Logic", "description": "Propositional and predicate logic" },
          { "field": "Mathematics", "description": "Theorem statements, proofs" },
          { "field": "Computer Science", "description": "Program verification" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["logic-basics"],
      "nextTopics": ["predicate-logic", "proof-methods"],
      "related": ["set-notation"]
    },
    "tags": ["한정사", "논리", "quantifier", "forall", "exists"]
  },
  {
    "id": "factorial-notation",
    "name": { "ko": "팩토리얼 기호 n!", "en": "Factorial Notation (n!)" },
    "field": "symbols",
    "subfield": "operations",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "n!은 n 팩토리얼로, 1부터 n까지 모든 양의 정수의 곱입니다. 순열과 조합에서 핵심적으로 사용됩니다.",
        "formulas": [
          {
            "latex": "n! = n \\times (n-1) \\times (n-2) \\times ... \\times 2 \\times 1",
            "description": "팩토리얼의 정의"
          },
          { "latex": "0! = 1", "description": "0의 팩토리얼 (정의)" },
          { "latex": "n! = n \\times (n-1)!", "description": "재귀적 정의" },
          {
            "latex": "n! \\approx \\sqrt{2\\pi n} \\left(\\frac{n}{e}\\right)^n",
            "description": "스털링 근사"
          }
        ],
        "examples": [
          { "problem": "5!를 계산하세요.", "solution": "5! = 5 × 4 × 3 × 2 × 1 = 120" },
          { "problem": "7!/5!를 계산하세요.", "solution": "7!/5! = 7 × 6 = 42" }
        ],
        "history": {
          "discoveredBy": "크리스티안 크람프",
          "year": "1808년",
          "background": "! 기호를 처음 사용했으며, 이후 표준이 되었습니다."
        },
        "applications": [
          { "field": "조합론", "description": "순열, 조합" },
          { "field": "확률론", "description": "이항분포, 포아송분포" },
          { "field": "컴퓨터 과학", "description": "알고리즘 복잡도" }
        ]
      },
      "en": {
        "definition": "n! (n factorial) is the product of all positive integers from 1 to n. Essential in permutations and combinations.",
        "formulas": [
          {
            "latex": "n! = n \\times (n-1) \\times (n-2) \\times ... \\times 2 \\times 1",
            "description": "Definition of factorial"
          },
          { "latex": "0! = 1", "description": "Zero factorial (by definition)" },
          { "latex": "n! = n \\times (n-1)!", "description": "Recursive definition" },
          {
            "latex": "n! \\approx \\sqrt{2\\pi n} \\left(\\frac{n}{e}\\right)^n",
            "description": "Stirling's approximation"
          }
        ],
        "examples": [
          { "problem": "Calculate 5!", "solution": "5! = 5 × 4 × 3 × 2 × 1 = 120" },
          { "problem": "Calculate 7!/5!", "solution": "7!/5! = 7 × 6 = 42" }
        ],
        "history": {
          "discoveredBy": "Christian Kramp",
          "year": "1808",
          "background": "First used the ! symbol, which became standard notation."
        },
        "applications": [
          { "field": "Combinatorics", "description": "Permutations, combinations" },
          { "field": "Probability", "description": "Binomial, Poisson distributions" },
          { "field": "Computer Science", "description": "Algorithm complexity" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["permutations", "combinations", "gamma-function"],
      "related": ["product-notation"]
    },
    "tags": ["팩토리얼", "계승", "factorial", "permutation"]
  },
  {
    "id": "binomial-coefficient",
    "name": { "ko": "이항계수 (ⁿCₖ)", "en": "Binomial Coefficient" },
    "field": "symbols",
    "subfield": "operations",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "이항계수 (n k) 또는 ⁿCₖ는 n개에서 k개를 선택하는 경우의 수입니다. 이항 전개의 계수이기도 합니다.",
        "formulas": [
          { "latex": "\\binom{n}{k} = \\frac{n!}{k!(n-k)!}", "description": "이항계수의 정의" },
          { "latex": "\\binom{n}{k} = \\binom{n}{n-k}", "description": "대칭성" },
          {
            "latex": "\\binom{n}{k} + \\binom{n}{k+1} = \\binom{n+1}{k+1}",
            "description": "파스칼의 항등식"
          },
          {
            "latex": "(x+y)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^{n-k} y^k",
            "description": "이항 정리"
          }
        ],
        "examples": [
          {
            "problem": "10명에서 3명을 선택하는 경우의 수는?",
            "solution": "C(10,3) = 10!/(3!×7!) = 120"
          },
          { "problem": "(x+y)³을 전개하세요.", "solution": "x³ + 3x²y + 3xy² + y³ (계수: 1,3,3,1)" }
        ],
        "history": {
          "discoveredBy": "블레즈 파스칼",
          "year": "1654년",
          "background": "파스칼의 삼각형으로 체계화했으나, 고대부터 알려진 개념입니다."
        },
        "applications": [
          { "field": "확률론", "description": "이항분포" },
          { "field": "조합론", "description": "경우의 수" },
          { "field": "통계학", "description": "표본 선택" }
        ]
      },
      "en": {
        "definition": "The binomial coefficient (n k) or ⁿCₖ is the number of ways to choose k items from n items. Also coefficients in binomial expansion.",
        "formulas": [
          {
            "latex": "\\binom{n}{k} = \\frac{n!}{k!(n-k)!}",
            "description": "Definition of binomial coefficient"
          },
          { "latex": "\\binom{n}{k} = \\binom{n}{n-k}", "description": "Symmetry" },
          {
            "latex": "\\binom{n}{k} + \\binom{n}{k+1} = \\binom{n+1}{k+1}",
            "description": "Pascal's identity"
          },
          {
            "latex": "(x+y)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^{n-k} y^k",
            "description": "Binomial theorem"
          }
        ],
        "examples": [
          {
            "problem": "How many ways to choose 3 from 10 people?",
            "solution": "C(10,3) = 10!/(3!×7!) = 120"
          },
          {
            "problem": "Expand (x+y)³.",
            "solution": "x³ + 3x²y + 3xy² + y³ (coefficients: 1,3,3,1)"
          }
        ],
        "history": {
          "discoveredBy": "Blaise Pascal",
          "year": "1654",
          "background": "Systematized with Pascal's triangle, but known since ancient times."
        },
        "applications": [
          { "field": "Probability", "description": "Binomial distribution" },
          { "field": "Combinatorics", "description": "Counting" },
          { "field": "Statistics", "description": "Sample selection" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["factorial-notation"],
      "nextTopics": ["binomial-theorem", "pascals-triangle"],
      "related": ["combinations"]
    },
    "tags": ["이항계수", "조합", "binomial", "choose"]
  },
  {
    "id": "fundamental-theorem-calculus",
    "name": { "ko": "미적분학의 기본정리", "en": "Fundamental Theorem of Calculus" },
    "field": "theorems",
    "subfield": "calculus",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "미적분학의 기본정리는 미분과 적분이 서로 역연산임을 보여줍니다. 연속함수의 정적분을 원시함수로 계산할 수 있게 합니다.",
        "formulas": [
          { "latex": "\\frac{d}{dx} \\int_a^x f(t) dt = f(x)", "description": "제1 기본정리" },
          { "latex": "\\int_a^b f(x) dx = F(b) - F(a)", "description": "제2 기본정리 (F' = f)" }
        ],
        "examples": [
          {
            "problem": "∫₀² 3x² dx를 기본정리로 계산하세요.",
            "solution": "F(x) = x³ (F' = 3x²). ∫₀² 3x² dx = 2³ - 0³ = 8"
          }
        ],
        "history": {
          "discoveredBy": "뉴턴, 라이프니츠",
          "year": "1660년대",
          "background": "뉴턴과 라이프니츠가 독립적으로 발견했으며, 미적분학의 핵심입니다."
        },
        "applications": [
          { "field": "물리학", "description": "운동 방정식" },
          { "field": "공학", "description": "면적, 부피 계산" },
          { "field": "경제학", "description": "총비용, 총수입" }
        ]
      },
      "en": {
        "definition": "The Fundamental Theorem of Calculus shows differentiation and integration are inverse operations. It allows computing definite integrals via antiderivatives.",
        "formulas": [
          {
            "latex": "\\frac{d}{dx} \\int_a^x f(t) dt = f(x)",
            "description": "First Fundamental Theorem"
          },
          {
            "latex": "\\int_a^b f(x) dx = F(b) - F(a)",
            "description": "Second Fundamental Theorem (F' = f)"
          }
        ],
        "examples": [
          {
            "problem": "Calculate ∫₀² 3x² dx using the theorem.",
            "solution": "F(x) = x³ (F' = 3x²). ∫₀² 3x² dx = 2³ - 0³ = 8"
          }
        ],
        "history": {
          "discoveredBy": "Newton, Leibniz",
          "year": "1660s",
          "background": "Discovered independently by Newton and Leibniz; core of calculus."
        },
        "applications": [
          { "field": "Physics", "description": "Equations of motion" },
          { "field": "Engineering", "description": "Area, volume calculation" },
          { "field": "Economics", "description": "Total cost, revenue" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "integral"],
      "nextTopics": ["integration-techniques"],
      "related": ["mean-value-theorem"]
    },
    "tags": ["미적분", "기본정리", "calculus", "fundamental theorem"]
  },
  {
    "id": "fundamental-theorem-algebra",
    "name": { "ko": "대수학의 기본정리", "en": "Fundamental Theorem of Algebra" },
    "field": "theorems",
    "subfield": "algebra",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "대수학의 기본정리는 모든 n차 다항식(n≥1)은 복소수 범위에서 정확히 n개의 근(중복 포함)을 가진다는 것입니다.",
        "formulas": [
          {
            "latex": "p(z) = a_n(z-r_1)(z-r_2)\\cdots(z-r_n)",
            "description": "n차 다항식의 인수분해"
          }
        ],
        "examples": [
          {
            "problem": "x² + 1 = 0의 근을 찾으세요.",
            "solution": "실수에서는 근이 없지만, 복소수에서 x = ±i (i² = -1)"
          },
          {
            "problem": "x³ - 1 = 0의 모든 근을 찾으세요.",
            "solution": "x = 1 (실근), x = (-1 ± i√3)/2 (허근 2개). 총 3개의 근."
          }
        ],
        "history": {
          "discoveredBy": "카를 프리드리히 가우스",
          "year": "1799년",
          "background": "가우스가 박사 논문에서 최초로 엄밀하게 증명했습니다."
        },
        "applications": [
          { "field": "제어 이론", "description": "전달함수의 극점 분석" },
          { "field": "신호 처리", "description": "필터 설계" },
          { "field": "수치해석", "description": "다항식 근 찾기" }
        ]
      },
      "en": {
        "definition": "The Fundamental Theorem of Algebra states every polynomial of degree n≥1 has exactly n roots (counting multiplicity) in complex numbers.",
        "formulas": [
          {
            "latex": "p(z) = a_n(z-r_1)(z-r_2)\\cdots(z-r_n)",
            "description": "Factorization of degree n polynomial"
          }
        ],
        "examples": [
          {
            "problem": "Find the roots of x² + 1 = 0.",
            "solution": "No real roots, but in complex numbers x = ±i (i² = -1)"
          },
          {
            "problem": "Find all roots of x³ - 1 = 0.",
            "solution": "x = 1 (real), x = (-1 ± i√3)/2 (complex). Total 3 roots."
          }
        ],
        "history": {
          "discoveredBy": "Carl Friedrich Gauss",
          "year": "1799",
          "background": "Gauss gave the first rigorous proof in his doctoral dissertation."
        },
        "applications": [
          { "field": "Control Theory", "description": "Transfer function poles" },
          { "field": "Signal Processing", "description": "Filter design" },
          { "field": "Numerical Analysis", "description": "Polynomial root finding" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["complex-numbers", "polynomial"],
      "nextTopics": ["galois-theory"],
      "related": ["quadratic-formula"]
    },
    "tags": ["대수학", "기본정리", "algebra", "fundamental theorem"]
  },
  {
    "id": "fermats-last-theorem",
    "name": { "ko": "페르마의 마지막 정리", "en": "Fermat's Last Theorem" },
    "field": "theorems",
    "subfield": "number-theory",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "n ≥ 3인 정수에 대해 xⁿ + yⁿ = zⁿ을 만족하는 양의 정수 x, y, z는 존재하지 않습니다.",
        "formulas": [
          {
            "latex": "x^n + y^n = z^n \\text{ has no positive integer solutions for } n \\geq 3",
            "description": "페르마의 마지막 정리"
          }
        ],
        "examples": [
          {
            "problem": "n = 2일 때는 해가 있나요?",
            "solution": "예, 피타고라스 삼중수: 3² + 4² = 5², 5² + 12² = 13² 등 무한히 많습니다."
          }
        ],
        "history": {
          "discoveredBy": "피에르 드 페르마 (추측), 앤드류 와일스 (증명)",
          "year": "1637년 (추측), 1995년 (증명)",
          "background": "페르마가 책 여백에 '증명을 발견했다'고 썼지만, 358년 후 와일스가 증명했습니다."
        },
        "applications": [
          { "field": "수론", "description": "타원곡선, 모듈러 형식" },
          { "field": "암호학", "description": "타원곡선 암호" }
        ]
      },
      "en": {
        "definition": "For integer n ≥ 3, there are no positive integer solutions x, y, z satisfying xⁿ + yⁿ = zⁿ.",
        "formulas": [
          {
            "latex": "x^n + y^n = z^n \\text{ has no positive integer solutions for } n \\geq 3",
            "description": "Fermat's Last Theorem"
          }
        ],
        "examples": [
          {
            "problem": "Are there solutions for n = 2?",
            "solution": "Yes, Pythagorean triples: 3² + 4² = 5², 5² + 12² = 13², infinitely many."
          }
        ],
        "history": {
          "discoveredBy": "Pierre de Fermat (conjecture), Andrew Wiles (proof)",
          "year": "1637 (conjecture), 1995 (proof)",
          "background": "Fermat wrote he had a proof in a book margin; Wiles proved it 358 years later."
        },
        "applications": [
          { "field": "Number Theory", "description": "Elliptic curves, modular forms" },
          { "field": "Cryptography", "description": "Elliptic curve cryptography" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["diophantine-equations", "modular-arithmetic"],
      "nextTopics": ["elliptic-curves", "modular-forms"],
      "related": ["pythagorean-theorem"]
    },
    "tags": ["페르마", "마지막정리", "Fermat", "last theorem"]
  },
  {
    "id": "prime-number-theorem",
    "name": { "ko": "소수 정리", "en": "Prime Number Theorem" },
    "field": "theorems",
    "subfield": "number-theory",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "소수 정리는 x 이하의 소수의 개수 π(x)가 x/ln(x)에 점근한다는 것입니다.",
        "formulas": [
          { "latex": "\\pi(x) \\sim \\frac{x}{\\ln x}", "description": "소수 정리" },
          {
            "latex": "\\lim_{x \\to \\infty} \\frac{\\pi(x)}{x / \\ln x} = 1",
            "description": "정확한 점근 형태"
          }
        ],
        "examples": [
          {
            "problem": "1000 이하의 소수 개수를 추정하세요.",
            "solution": "π(1000) ≈ 1000/ln(1000) ≈ 1000/6.9 ≈ 145. 실제: 168개"
          }
        ],
        "history": {
          "discoveredBy": "아다마르, 드 라 발레푸생",
          "year": "1896년",
          "background": "가우스가 추측하고, 아다마르와 드 라 발레푸생이 독립적으로 증명했습니다."
        },
        "applications": [
          { "field": "암호학", "description": "큰 소수 생성" },
          { "field": "수론", "description": "소수 분포 연구" }
        ]
      },
      "en": {
        "definition": "The Prime Number Theorem states that π(x), the count of primes ≤ x, is asymptotic to x/ln(x).",
        "formulas": [
          { "latex": "\\pi(x) \\sim \\frac{x}{\\ln x}", "description": "Prime Number Theorem" },
          {
            "latex": "\\lim_{x \\to \\infty} \\frac{\\pi(x)}{x / \\ln x} = 1",
            "description": "Precise asymptotic form"
          }
        ],
        "examples": [
          {
            "problem": "Estimate the number of primes up to 1000.",
            "solution": "π(1000) ≈ 1000/ln(1000) ≈ 1000/6.9 ≈ 145. Actual: 168"
          }
        ],
        "history": {
          "discoveredBy": "Hadamard, de la Vallée Poussin",
          "year": "1896",
          "background": "Conjectured by Gauss; proved independently by Hadamard and de la Vallée Poussin."
        },
        "applications": [
          { "field": "Cryptography", "description": "Large prime generation" },
          { "field": "Number Theory", "description": "Prime distribution" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["prime-numbers", "logarithm"],
      "nextTopics": ["riemann-hypothesis"],
      "related": ["zeta-function"]
    },
    "tags": ["소수", "정리", "prime", "theorem"]
  },
  {
    "id": "mean-value-theorem",
    "name": { "ko": "평균값 정리", "en": "Mean Value Theorem" },
    "field": "theorems",
    "subfield": "calculus",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "평균값 정리는 [a,b]에서 연속이고 (a,b)에서 미분 가능한 함수에 대해, 접선의 기울기가 할선의 기울기와 같은 점이 존재함을 말합니다.",
        "formulas": [
          {
            "latex": "f'(c) = \\frac{f(b) - f(a)}{b - a}",
            "description": "평균값 정리 (a < c < b인 c 존재)"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x² on [1, 3]에서 평균값 정리의 c를 찾으세요.",
            "solution": "f'(x) = 2x, (f(3)-f(1))/(3-1) = (9-1)/2 = 4. 2c = 4이므로 c = 2."
          }
        ],
        "history": {
          "discoveredBy": "오귀스탱 루이 코시",
          "year": "1823년",
          "background": "코시가 해석학의 엄밀화 과정에서 증명했습니다."
        },
        "applications": [
          { "field": "해석학", "description": "함수의 증감 판정" },
          { "field": "물리학", "description": "순간 속도와 평균 속도" },
          { "field": "오차 분석", "description": "테일러 전개의 나머지항" }
        ]
      },
      "en": {
        "definition": "The Mean Value Theorem states for a function continuous on [a,b] and differentiable on (a,b), there exists a point where tangent slope equals secant slope.",
        "formulas": [
          {
            "latex": "f'(c) = \\frac{f(b) - f(a)}{b - a}",
            "description": "Mean Value Theorem (c exists with a < c < b)"
          }
        ],
        "examples": [
          {
            "problem": "Find c for f(x) = x² on [1, 3].",
            "solution": "f'(x) = 2x, (f(3)-f(1))/(3-1) = (9-1)/2 = 4. 2c = 4, so c = 2."
          }
        ],
        "history": {
          "discoveredBy": "Augustin-Louis Cauchy",
          "year": "1823",
          "background": "Cauchy proved it during the rigorization of analysis."
        },
        "applications": [
          { "field": "Analysis", "description": "Determining function increase/decrease" },
          { "field": "Physics", "description": "Instantaneous vs average velocity" },
          { "field": "Error Analysis", "description": "Taylor expansion remainder" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "continuity"],
      "nextTopics": ["rolles-theorem", "lhopitals-rule"],
      "related": ["intermediate-value-theorem"]
    },
    "tags": ["평균값", "미적분", "mean value", "calculus"]
  },
  {
    "id": "bayes-theorem",
    "name": { "ko": "베이즈 정리", "en": "Bayes' Theorem" },
    "field": "theorems",
    "subfield": "probability",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "베이즈 정리는 조건부 확률을 뒤집는 공식입니다. 새로운 증거가 주어졌을 때 믿음을 업데이트하는 데 사용됩니다.",
        "formulas": [
          { "latex": "P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}", "description": "베이즈 정리" },
          { "latex": "P(B) = \\sum_i P(B|A_i)P(A_i)", "description": "전확률 공식" }
        ],
        "examples": [
          {
            "problem": "질병 발생률 1%, 검사 정확도 99%. 양성일 때 실제 질병 확률은?",
            "solution": "P(D|+) = P(+|D)P(D) / P(+) = (0.99)(0.01) / (0.99×0.01 + 0.01×0.99) = 0.5 (50%)"
          }
        ],
        "history": {
          "discoveredBy": "토머스 베이즈",
          "year": "1763년",
          "background": "베이즈 사후에 발표된 논문에서 처음 등장했습니다."
        },
        "applications": [
          { "field": "기계학습", "description": "나이브 베이즈 분류기" },
          { "field": "의학", "description": "진단 테스트 해석" },
          { "field": "스팸 필터", "description": "베이지안 스팸 필터" }
        ]
      },
      "en": {
        "definition": "Bayes' Theorem is a formula for reversing conditional probabilities. Used to update beliefs given new evidence.",
        "formulas": [
          { "latex": "P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}", "description": "Bayes' Theorem" },
          { "latex": "P(B) = \\sum_i P(B|A_i)P(A_i)", "description": "Law of total probability" }
        ],
        "examples": [
          {
            "problem": "Disease rate 1%, test accuracy 99%. If positive, what's actual disease probability?",
            "solution": "P(D|+) = P(+|D)P(D) / P(+) = (0.99)(0.01) / (0.99×0.01 + 0.01×0.99) = 0.5 (50%)"
          }
        ],
        "history": {
          "discoveredBy": "Thomas Bayes",
          "year": "1763",
          "background": "First appeared in a paper published posthumously."
        },
        "applications": [
          { "field": "Machine Learning", "description": "Naive Bayes classifier" },
          { "field": "Medicine", "description": "Diagnostic test interpretation" },
          { "field": "Spam Filtering", "description": "Bayesian spam filters" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["conditional-probability"],
      "nextTopics": ["bayesian-inference"],
      "related": ["total-probability"]
    },
    "tags": ["베이즈", "조건부확률", "Bayes", "conditional"]
  },
  {
    "id": "noethers-theorem",
    "name": { "ko": "뇌터의 정리", "en": "Noether's Theorem" },
    "field": "theorems",
    "subfield": "physics",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "뇌터의 정리는 물리계의 연속 대칭성에 대응하는 보존량이 존재함을 말합니다.",
        "formulas": [
          {
            "latex": "\\text{시간 평행이동 대칭} \\leftrightarrow \\text{에너지 보존}",
            "description": "시간 대칭과 에너지"
          },
          {
            "latex": "\\text{공간 평행이동 대칭} \\leftrightarrow \\text{운동량 보존}",
            "description": "공간 대칭과 운동량"
          },
          {
            "latex": "\\text{회전 대칭} \\leftrightarrow \\text{각운동량 보존}",
            "description": "회전 대칭과 각운동량"
          }
        ],
        "examples": [
          {
            "problem": "왜 에너지가 보존되는지 뇌터 정리로 설명하세요.",
            "solution": "물리 법칙이 시간에 따라 변하지 않으면(시간 평행이동 대칭), 에너지가 보존됩니다."
          }
        ],
        "history": {
          "discoveredBy": "에미 뇌터",
          "year": "1915년",
          "background": "뇌터가 일반상대론 연구 중에 발견한, 물리학에서 가장 중요한 정리 중 하나입니다."
        },
        "applications": [
          { "field": "물리학", "description": "보존 법칙의 기원" },
          { "field": "입자물리학", "description": "게이지 대칭, 표준모형" },
          { "field": "수학", "description": "불변 이론" }
        ]
      },
      "en": {
        "definition": "Noether's Theorem states that every continuous symmetry of a physical system corresponds to a conserved quantity.",
        "formulas": [
          {
            "latex": "\\text{Time translation symmetry} \\leftrightarrow \\text{Energy conservation}",
            "description": "Time symmetry and energy"
          },
          {
            "latex": "\\text{Space translation symmetry} \\leftrightarrow \\text{Momentum conservation}",
            "description": "Space symmetry and momentum"
          },
          {
            "latex": "\\text{Rotational symmetry} \\leftrightarrow \\text{Angular momentum conservation}",
            "description": "Rotation symmetry and angular momentum"
          }
        ],
        "examples": [
          {
            "problem": "Explain energy conservation via Noether's theorem.",
            "solution": "If physical laws don't change over time (time translation symmetry), energy is conserved."
          }
        ],
        "history": {
          "discoveredBy": "Emmy Noether",
          "year": "1915",
          "background": "Noether discovered this while working on general relativity; one of physics' most important theorems."
        },
        "applications": [
          { "field": "Physics", "description": "Origin of conservation laws" },
          { "field": "Particle Physics", "description": "Gauge symmetries, Standard Model" },
          { "field": "Mathematics", "description": "Invariant theory" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["symmetry", "lagrangian-mechanics"],
      "nextTopics": ["gauge-theory"],
      "related": ["conservation-laws"]
    },
    "tags": ["뇌터", "대칭", "Noether", "symmetry"]
  },
  {
    "id": "pythagorean-theorem",
    "name": { "ko": "피타고라스 정리", "en": "Pythagorean Theorem" },
    "field": "theorems",
    "subfield": "geometry",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "직각삼각형에서 빗변의 제곱은 다른 두 변의 제곱의 합과 같습니다. 수학에서 가장 유명하고 기본적인 정리입니다.",
        "formulas": [
          { "latex": "a^2 + b^2 = c^2", "description": "피타고라스 정리 (c는 빗변)" },
          { "latex": "c = \\sqrt{a^2 + b^2}", "description": "빗변의 길이" }
        ],
        "examples": [
          {
            "problem": "두 변이 3과 4인 직각삼각형의 빗변은?",
            "solution": "c = √(3² + 4²) = √(9 + 16) = √25 = 5"
          },
          {
            "problem": "빗변이 13이고 한 변이 5인 직각삼각형의 나머지 변은?",
            "solution": "b = √(13² - 5²) = √(169 - 25) = √144 = 12"
          }
        ],
        "history": {
          "discoveredBy": "피타고라스 (또는 그 이전)",
          "year": "기원전 6세기경",
          "background": "피타고라스 학파에서 증명했으나, 바빌로니아와 인도에서 더 일찍 알려져 있었습니다."
        },
        "applications": [
          { "field": "건축", "description": "직각 확인, 거리 계산" },
          { "field": "항법", "description": "GPS, 거리 측정" },
          { "field": "컴퓨터 그래픽스", "description": "벡터 거리 계산" }
        ]
      },
      "en": {
        "definition": "In a right triangle, the square of the hypotenuse equals the sum of squares of the other two sides. Mathematics' most famous theorem.",
        "formulas": [
          { "latex": "a^2 + b^2 = c^2", "description": "Pythagorean Theorem (c is hypotenuse)" },
          { "latex": "c = \\sqrt{a^2 + b^2}", "description": "Hypotenuse length" }
        ],
        "examples": [
          {
            "problem": "Find the hypotenuse of a right triangle with sides 3 and 4.",
            "solution": "c = √(3² + 4²) = √(9 + 16) = √25 = 5"
          },
          {
            "problem": "If hypotenuse is 13 and one side is 5, find the other side.",
            "solution": "b = √(13² - 5²) = √(169 - 25) = √144 = 12"
          }
        ],
        "history": {
          "discoveredBy": "Pythagoras (or earlier)",
          "year": "c. 6th century BCE",
          "background": "Proved by Pythagorean school, but known earlier in Babylon and India."
        },
        "applications": [
          { "field": "Architecture", "description": "Right angle verification, distance" },
          { "field": "Navigation", "description": "GPS, distance measurement" },
          { "field": "Computer Graphics", "description": "Vector distance calculation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["right-triangle", "square-root"],
      "nextTopics": ["distance-formula", "trigonometry"],
      "related": ["fermats-last-theorem"]
    },
    "tags": ["피타고라스", "직각삼각형", "Pythagorean", "geometry"]
  },
  {
    "id": "central-limit-theorem",
    "name": { "ko": "중심극한정리", "en": "Central Limit Theorem" },
    "field": "theorems",
    "subfield": "probability",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "충분히 많은 독립 확률변수의 합의 분포는 원래 분포에 관계없이 정규분포에 근사합니다.",
        "formulas": [
          { "latex": "\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^{n} X_i", "description": "표본평균" },
          {
            "latex": "\\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0,1)",
            "description": "표준화된 표본평균은 표준정규분포로 수렴"
          }
        ],
        "examples": [
          {
            "problem": "동전을 100번 던져 앞면 개수의 분포는?",
            "solution": "평균 50, 표준편차 5인 정규분포에 근사. P(45 ≤ X ≤ 55) ≈ 68%"
          }
        ],
        "history": {
          "discoveredBy": "피에르시몽 라플라스",
          "year": "1810년",
          "background": "드무아브르가 이항분포에 대해 처음 발견했고, 라플라스가 일반화했습니다."
        },
        "applications": [
          { "field": "통계학", "description": "신뢰구간, 가설검정" },
          { "field": "품질관리", "description": "공정 모니터링" },
          { "field": "금융", "description": "포트폴리오 분석" }
        ]
      },
      "en": {
        "definition": "The distribution of sum of many independent random variables approaches normal distribution regardless of original distribution.",
        "formulas": [
          { "latex": "\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^{n} X_i", "description": "Sample mean" },
          {
            "latex": "\\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0,1)",
            "description": "Standardized sample mean converges to standard normal"
          }
        ],
        "examples": [
          {
            "problem": "What's the distribution of heads in 100 coin flips?",
            "solution": "Approximately normal with mean 50, std 5. P(45 ≤ X ≤ 55) ≈ 68%"
          }
        ],
        "history": {
          "discoveredBy": "Pierre-Simon Laplace",
          "year": "1810",
          "background": "De Moivre first proved it for binomial; Laplace generalized it."
        },
        "applications": [
          { "field": "Statistics", "description": "Confidence intervals, hypothesis tests" },
          { "field": "Quality Control", "description": "Process monitoring" },
          { "field": "Finance", "description": "Portfolio analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["normal-distribution", "expected-value"],
      "nextTopics": ["confidence-intervals", "hypothesis-testing"],
      "related": ["law-of-large-numbers"]
    },
    "tags": ["중심극한", "정규분포", "CLT", "statistics"]
  },
  {
    "id": "intermediate-value-theorem",
    "name": { "ko": "중간값 정리", "en": "Intermediate Value Theorem" },
    "field": "theorems",
    "subfield": "calculus",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "연속함수 f가 [a,b]에서 정의되고 f(a)와 f(b) 사이의 값 k가 있으면, f(c) = k인 c가 (a,b)에 존재합니다.",
        "formulas": [
          {
            "latex": "\\text{f(a) < k < f(b)이면 f(c) = k인 c ∈ (a,b) 존재}",
            "description": "중간값 정리"
          }
        ],
        "examples": [
          {
            "problem": "f(x) = x³ - x - 1에서 [1,2] 사이에 근이 있음을 보이세요.",
            "solution": "f(1) = -1 < 0, f(2) = 5 > 0. 연속이므로 f(c) = 0인 c ∈ (1,2) 존재."
          }
        ],
        "history": {
          "discoveredBy": "베르나르트 볼차노",
          "year": "1817년",
          "background": "볼차노가 처음 엄밀하게 증명했습니다. 직관적으로 당연해 보이지만 증명은 실수의 완비성을 필요로 합니다."
        },
        "applications": [
          { "field": "수치해석", "description": "이분법 근 찾기" },
          { "field": "경제학", "description": "균형점 존재 증명" },
          { "field": "물리학", "description": "연속 변화 분석" }
        ]
      },
      "en": {
        "definition": "If continuous f on [a,b] and k is between f(a) and f(b), there exists c in (a,b) with f(c) = k.",
        "formulas": [
          {
            "latex": "\\text{If f(a) < k < f(b), then ∃c ∈ (a,b) with f(c) = k}",
            "description": "Intermediate Value Theorem"
          }
        ],
        "examples": [
          {
            "problem": "Show f(x) = x³ - x - 1 has a root in [1,2].",
            "solution": "f(1) = -1 < 0, f(2) = 5 > 0. By continuity, ∃c ∈ (1,2) with f(c) = 0."
          }
        ],
        "history": {
          "discoveredBy": "Bernard Bolzano",
          "year": "1817",
          "background": "Bolzano gave first rigorous proof. Seems obvious intuitively but requires completeness of reals."
        },
        "applications": [
          { "field": "Numerical Analysis", "description": "Bisection method" },
          { "field": "Economics", "description": "Equilibrium existence" },
          { "field": "Physics", "description": "Continuous change analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["continuity"],
      "nextTopics": ["bisection-method", "fixed-point-theorem"],
      "related": ["mean-value-theorem"]
    },
    "tags": ["중간값", "연속", "IVT", "continuity"]
  },
  {
    "id": "stokes-theorem",
    "name": { "ko": "스토크스 정리", "en": "Stokes' Theorem" },
    "field": "theorems",
    "subfield": "calculus",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "스토크스 정리는 벡터장의 회전의 면적분이 경계 곡선에서의 선적분과 같음을 말합니다. 미적분학의 기본정리를 일반화한 것입니다.",
        "formulas": [
          {
            "latex": "\\oint_C \\vec{F} \\cdot d\\vec{r} = \\iint_S (\\nabla \\times \\vec{F}) \\cdot d\\vec{S}",
            "description": "스토크스 정리"
          },
          {
            "latex": "\\int_a^b f'(x)dx = f(b) - f(a)",
            "description": "1차원 특수 경우 (미적분 기본정리)"
          }
        ],
        "examples": [
          {
            "problem": "∮ᴄ F·dr을 스토크스 정리로 계산하는 전략은?",
            "solution": "curl F를 구하고 C를 경계로 하는 곡면 S에서 면적분합니다. 곡면 선택으로 계산을 단순화할 수 있습니다."
          }
        ],
        "history": {
          "discoveredBy": "조지 스토크스",
          "year": "1854년",
          "background": "켈빈이 스토크스에게 보낸 편지에서 등장했고, 스토크스가 시험 문제로 출제했습니다."
        },
        "applications": [
          { "field": "전자기학", "description": "맥스웰 방정식, 패러데이 법칙" },
          { "field": "유체역학", "description": "순환, 소용돌이" },
          { "field": "미분기하학", "description": "드람 코호몰로지" }
        ]
      },
      "en": {
        "definition": "Stokes' Theorem states the surface integral of curl equals the line integral around the boundary. Generalizes the Fundamental Theorem of Calculus.",
        "formulas": [
          {
            "latex": "\\oint_C \\vec{F} \\cdot d\\vec{r} = \\iint_S (\\nabla \\times \\vec{F}) \\cdot d\\vec{S}",
            "description": "Stokes' Theorem"
          },
          { "latex": "\\int_a^b f'(x)dx = f(b) - f(a)", "description": "1D special case (FTC)" }
        ],
        "examples": [
          {
            "problem": "Strategy to compute ∮ᴄ F·dr using Stokes?",
            "solution": "Compute curl F, integrate over surface S bounded by C. Surface choice can simplify calculation."
          }
        ],
        "history": {
          "discoveredBy": "George Stokes",
          "year": "1854",
          "background": "Appeared in Kelvin's letter to Stokes; Stokes used it as exam problem."
        },
        "applications": [
          { "field": "Electromagnetism", "description": "Maxwell's equations, Faraday's law" },
          { "field": "Fluid Dynamics", "description": "Circulation, vorticity" },
          { "field": "Differential Geometry", "description": "de Rham cohomology" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["curl", "line-integral", "surface-integral"],
      "nextTopics": ["divergence-theorem", "differential-forms"],
      "related": ["greens-theorem", "fundamental-theorem-calculus"]
    },
    "tags": ["스토크스", "벡터미적분", "Stokes", "vector calculus"]
  },
  {
    "id": "godel-incompleteness",
    "name": { "ko": "괴델의 불완전성 정리", "en": "Gödel's Incompleteness Theorems" },
    "field": "theorems",
    "subfield": "logic",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "산술을 포함하는 일관된 형식 체계에서는 참이지만 증명 불가능한 명제가 존재합니다. 또한 그 체계는 자신의 일관성을 증명할 수 없습니다.",
        "formulas": [
          {
            "latex": "\\text{제1정리: 참이지만 증명 불가능한 문장 존재}",
            "description": "불완전성"
          },
          {
            "latex": "\\text{제2정리: 체계 내에서 자신의 일관성 증명 불가}",
            "description": "자기 참조의 한계"
          }
        ],
        "examples": [
          {
            "problem": "괴델 문장 G: '이 문장은 증명될 수 없다'가 왜 참인가?",
            "solution": "G가 거짓이면 증명 가능 → 모순. G가 참이면 증명 불가 → 일관성 유지. 따라서 G는 참이나 증명 불가."
          }
        ],
        "history": {
          "discoveredBy": "쿠르트 괴델",
          "year": "1931년",
          "background": "힐베르트의 프로그램에 대한 응답으로, 수학의 근본적 한계를 밝혔습니다."
        },
        "applications": [
          { "field": "논리학", "description": "증명 이론의 한계" },
          { "field": "컴퓨터 과학", "description": "결정 불가능성, 정지 문제" },
          { "field": "철학", "description": "수학의 본질에 대한 논쟁" }
        ]
      },
      "en": {
        "definition": "In any consistent formal system containing arithmetic, there exist true but unprovable statements. Also, the system cannot prove its own consistency.",
        "formulas": [
          {
            "latex": "\\text{1st: There exists a true but unprovable statement}",
            "description": "Incompleteness"
          },
          {
            "latex": "\\text{2nd: System cannot prove its own consistency}",
            "description": "Self-reference limitation"
          }
        ],
        "examples": [
          {
            "problem": "Why is Gödel sentence G: 'This statement is unprovable' true?",
            "solution": "If G false, it's provable → contradiction. If G true, it's unprovable → consistent. Thus G is true but unprovable."
          }
        ],
        "history": {
          "discoveredBy": "Kurt Gödel",
          "year": "1931",
          "background": "Response to Hilbert's program; revealed fundamental limits of mathematics."
        },
        "applications": [
          { "field": "Logic", "description": "Limits of proof theory" },
          { "field": "Computer Science", "description": "Undecidability, halting problem" },
          { "field": "Philosophy", "description": "Debates on nature of mathematics" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["formal-logic", "peano-arithmetic"],
      "nextTopics": ["halting-problem", "turing-machines"],
      "related": ["set-theory-axioms"]
    },
    "tags": ["괴델", "불완전성", "Gödel", "incompleteness"]
  },
  {
    "id": "group-theory",
    "name": { "ko": "군론", "en": "Group Theory" },
    "field": "abstract-algebra",
    "subfield": "groups",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "군(Group)은 이항연산이 정의된 집합으로, 결합법칙, 항등원의 존재, 역원의 존재를 만족합니다. 대칭성을 수학적으로 다루는 기본 구조입니다.",
        "formulas": [
          { "latex": "(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)", "description": "결합법칙" },
          { "latex": "\\exists e : a \\cdot e = e \\cdot a = a", "description": "항등원의 존재" },
          {
            "latex": "\\forall a, \\exists a^{-1} : a \\cdot a^{-1} = a^{-1} \\cdot a = e",
            "description": "역원의 존재"
          },
          { "latex": "a \\cdot b = b \\cdot a", "description": "교환법칙 (아벨군의 경우)" }
        ],
        "examples": [
          {
            "problem": "(ℤ, +)가 군임을 보이세요.",
            "solution": "결합법칙: (a+b)+c = a+(b+c) ✓. 항등원: 0 (a+0=a) ✓. 역원: -a (a+(-a)=0) ✓. 또한 교환법칙도 성립하므로 아벨군입니다."
          },
          {
            "problem": "S₃ (3개 원소의 순열군)의 위수는?",
            "solution": "3개 원소를 배열하는 방법의 수 = 3! = 6. S₃는 위수 6인 비아벨군입니다."
          }
        ],
        "history": {
          "discoveredBy": "에바리스트 갈루아",
          "year": "1830년대",
          "background": "갈루아가 방정식의 해를 연구하면서 군 개념을 도입했습니다. 아벨도 독립적으로 비슷한 아이디어를 발전시켰습니다."
        },
        "applications": [
          { "field": "물리학", "description": "대칭성과 보존법칙" },
          { "field": "암호학", "description": "타원곡선, Diffie-Hellman" },
          { "field": "화학", "description": "분자 대칭성, 결정학" }
        ]
      },
      "en": {
        "definition": "A group is a set with a binary operation satisfying associativity, existence of identity, and existence of inverses. It's the fundamental structure for studying symmetry mathematically.",
        "formulas": [
          {
            "latex": "(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)",
            "description": "Associativity"
          },
          {
            "latex": "\\exists e : a \\cdot e = e \\cdot a = a",
            "description": "Existence of identity"
          },
          {
            "latex": "\\forall a, \\exists a^{-1} : a \\cdot a^{-1} = a^{-1} \\cdot a = e",
            "description": "Existence of inverse"
          },
          {
            "latex": "a \\cdot b = b \\cdot a",
            "description": "Commutativity (for abelian groups)"
          }
        ],
        "examples": [
          {
            "problem": "Show (ℤ, +) is a group.",
            "solution": "Associativity: (a+b)+c = a+(b+c) ✓. Identity: 0 (a+0=a) ✓. Inverse: -a (a+(-a)=0) ✓. Also commutative, so it's abelian."
          },
          {
            "problem": "What is the order of S₃ (symmetric group on 3 elements)?",
            "solution": "Number of ways to arrange 3 elements = 3! = 6. S₃ is a non-abelian group of order 6."
          }
        ],
        "history": {
          "discoveredBy": "Évariste Galois",
          "year": "1830s",
          "background": "Galois introduced group concept while studying polynomial equations. Abel independently developed similar ideas."
        },
        "applications": [
          { "field": "Physics", "description": "Symmetry and conservation laws" },
          { "field": "Cryptography", "description": "Elliptic curves, Diffie-Hellman" },
          { "field": "Chemistry", "description": "Molecular symmetry, crystallography" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["sets", "binary-operations"],
      "nextTopics": ["rings", "homomorphism"],
      "related": ["symmetry"]
    },
    "tags": ["군", "대칭", "group", "symmetry"]
  },
  {
    "id": "rings",
    "name": { "ko": "환", "en": "Rings" },
    "field": "abstract-algebra",
    "subfield": "rings",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "환(Ring)은 두 개의 이항연산(덧셈, 곱셈)이 정의된 집합입니다. 덧셈에 대해 아벨군이고, 곱셈은 결합법칙을 만족하며, 분배법칙이 성립합니다.",
        "formulas": [
          { "latex": "(R, +) \\text{ is an abelian group}", "description": "덧셈에 대한 아벨군" },
          {
            "latex": "(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)",
            "description": "곱셈의 결합법칙"
          },
          { "latex": "a(b + c) = ab + ac, \\quad (a + b)c = ac + bc", "description": "분배법칙" }
        ],
        "examples": [
          {
            "problem": "(ℤ, +, ×)가 환임을 보이세요.",
            "solution": "(ℤ, +)는 아벨군. 곱셈은 결합적. 분배법칙 성립. 항등원 1 존재. 따라서 단위원을 가진 가환환입니다."
          },
          {
            "problem": "2×2 행렬의 환 M₂(ℝ)의 특성은?",
            "solution": "단위원 I 존재. 곱셈이 비가환 (AB ≠ BA 일반적). 영인자 존재 (AB = 0이지만 A,B ≠ 0인 경우)."
          }
        ],
        "applications": [
          { "field": "수론", "description": "정수환, 대수적 정수론" },
          { "field": "다항식", "description": "다항식환" },
          { "field": "암호학", "description": "유한환, 격자 기반 암호" }
        ]
      },
      "en": {
        "definition": "A ring is a set with two binary operations (addition, multiplication). It's an abelian group under addition, multiplication is associative, and distributive laws hold.",
        "formulas": [
          {
            "latex": "(R, +) \\text{ is an abelian group}",
            "description": "Abelian group under addition"
          },
          {
            "latex": "(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)",
            "description": "Associativity of multiplication"
          },
          {
            "latex": "a(b + c) = ab + ac, \\quad (a + b)c = ac + bc",
            "description": "Distributive laws"
          }
        ],
        "examples": [
          {
            "problem": "Show (ℤ, +, ×) is a ring.",
            "solution": "(ℤ, +) is abelian group. Multiplication is associative. Distributive laws hold. Has identity 1. It's a commutative ring with unity."
          },
          {
            "problem": "What are properties of matrix ring M₂(ℝ)?",
            "solution": "Has identity I. Multiplication non-commutative (AB ≠ BA generally). Has zero divisors (AB = 0 but A,B ≠ 0 possible)."
          }
        ],
        "applications": [
          { "field": "Number Theory", "description": "Ring of integers, algebraic number theory" },
          { "field": "Polynomials", "description": "Polynomial rings" },
          { "field": "Cryptography", "description": "Finite rings, lattice-based crypto" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["group-theory"],
      "nextTopics": ["fields", "ideals"],
      "related": ["integers"]
    },
    "tags": ["환", "대수구조", "ring", "algebraic structure"]
  },
  {
    "id": "fields",
    "name": { "ko": "체", "en": "Fields" },
    "field": "abstract-algebra",
    "subfield": "fields",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "체(Field)는 사칙연산이 자유롭게 가능한 대수구조입니다. 0이 아닌 모든 원소가 곱셈에 대한 역원을 가지는 가환환입니다.",
        "formulas": [
          {
            "latex": "(F, +, \\cdot) \\text{ is a commutative ring with unity}",
            "description": "단위원을 가진 가환환"
          },
          {
            "latex": "\\forall a \\neq 0, \\exists a^{-1} : a \\cdot a^{-1} = 1",
            "description": "0이 아닌 원소의 곱셈 역원 존재"
          },
          { "latex": "\\text{char}(F) = 0 \\text{ or prime } p", "description": "체의 표수" }
        ],
        "examples": [
          {
            "problem": "유한체 𝔽₅ = {0, 1, 2, 3, 4}의 연산을 설명하세요.",
            "solution": "mod 5로 덧셈과 곱셈. 예: 3 + 4 = 2, 3 × 4 = 2. 역원: 2⁻¹ = 3 (2×3 = 6 ≡ 1). 5개 원소, 표수 5."
          },
          {
            "problem": "ℚ(√2)가 체임을 보이세요.",
            "solution": "ℚ(√2) = {a + b√2 : a,b ∈ ℚ}. 사칙연산에 닫혀있고, (a+b√2)⁻¹ = (a-b√2)/(a²-2b²)로 역원 존재."
          }
        ],
        "history": {
          "discoveredBy": "레오폴드 크로네커, 리하르트 데데킨트",
          "year": "19세기",
          "background": "대수방정식 연구와 대수적 수론의 발전 과정에서 체 개념이 정립되었습니다."
        },
        "applications": [
          { "field": "암호학", "description": "유한체 기반 암호 (AES, ECC)" },
          { "field": "코딩 이론", "description": "오류 정정 코드" },
          { "field": "대수기하학", "description": "대수적 다양체" }
        ]
      },
      "en": {
        "definition": "A field is an algebraic structure where all four arithmetic operations are freely possible. It's a commutative ring where every non-zero element has a multiplicative inverse.",
        "formulas": [
          {
            "latex": "(F, +, \\cdot) \\text{ is a commutative ring with unity}",
            "description": "Commutative ring with unity"
          },
          {
            "latex": "\\forall a \\neq 0, \\exists a^{-1} : a \\cdot a^{-1} = 1",
            "description": "Multiplicative inverse for non-zero elements"
          },
          {
            "latex": "\\text{char}(F) = 0 \\text{ or prime } p",
            "description": "Characteristic of field"
          }
        ],
        "examples": [
          {
            "problem": "Describe operations in finite field 𝔽₅ = {0, 1, 2, 3, 4}.",
            "solution": "Addition and multiplication mod 5. E.g., 3 + 4 = 2, 3 × 4 = 2. Inverse: 2⁻¹ = 3 (2×3 = 6 ≡ 1). 5 elements, characteristic 5."
          },
          {
            "problem": "Show ℚ(√2) is a field.",
            "solution": "ℚ(√2) = {a + b√2 : a,b ∈ ℚ}. Closed under operations, inverse (a+b√2)⁻¹ = (a-b√2)/(a²-2b²) exists."
          }
        ],
        "history": {
          "discoveredBy": "Leopold Kronecker, Richard Dedekind",
          "year": "19th century",
          "background": "Field concept emerged from studying algebraic equations and developing algebraic number theory."
        },
        "applications": [
          { "field": "Cryptography", "description": "Finite field crypto (AES, ECC)" },
          { "field": "Coding Theory", "description": "Error-correcting codes" },
          { "field": "Algebraic Geometry", "description": "Algebraic varieties" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["rings"],
      "nextTopics": ["galois-theory", "field-extensions"],
      "related": ["vector-space"]
    },
    "tags": ["체", "유한체", "field", "finite field"]
  },
  {
    "id": "homomorphism",
    "name": { "ko": "준동형사상", "en": "Homomorphism" },
    "field": "abstract-algebra",
    "subfield": "morphisms",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "준동형사상은 대수구조 사이의 연산을 보존하는 함수입니다. 군, 환, 체 등의 구조를 비교하고 분류하는 핵심 도구입니다.",
        "formulas": [
          {
            "latex": "\\phi(a \\cdot b) = \\phi(a) \\cdot \\phi(b)",
            "description": "군 준동형의 정의"
          },
          {
            "latex": "\\phi(a + b) = \\phi(a) + \\phi(b), \\quad \\phi(ab) = \\phi(a)\\phi(b)",
            "description": "환 준동형의 정의"
          },
          { "latex": "\\ker(\\phi) = \\{a : \\phi(a) = e\\}", "description": "핵 (kernel)" },
          { "latex": "\\text{im}(\\phi) = \\{\\phi(a) : a \\in G\\}", "description": "상 (image)" }
        ],
        "examples": [
          {
            "problem": "exp: (ℝ, +) → (ℝ⁺, ×)가 준동형임을 보이세요.",
            "solution": "exp(a + b) = e^(a+b) = e^a × e^b = exp(a) × exp(b). 덧셈을 곱셈으로 보존합니다."
          },
          {
            "problem": "φ: ℤ → ℤₙ, φ(a) = a mod n의 핵은?",
            "solution": "ker(φ) = {a ∈ ℤ : a ≡ 0 (mod n)} = nℤ. n의 배수 전체입니다."
          }
        ],
        "applications": [
          { "field": "대수학", "description": "구조 분류, 동형정리" },
          { "field": "암호학", "description": "군 기반 프로토콜" },
          { "field": "물리학", "description": "대칭군 표현" }
        ]
      },
      "en": {
        "definition": "A homomorphism is a function between algebraic structures that preserves operations. It's the key tool for comparing and classifying groups, rings, fields, etc.",
        "formulas": [
          {
            "latex": "\\phi(a \\cdot b) = \\phi(a) \\cdot \\phi(b)",
            "description": "Group homomorphism definition"
          },
          {
            "latex": "\\phi(a + b) = \\phi(a) + \\phi(b), \\quad \\phi(ab) = \\phi(a)\\phi(b)",
            "description": "Ring homomorphism definition"
          },
          { "latex": "\\ker(\\phi) = \\{a : \\phi(a) = e\\}", "description": "Kernel" },
          { "latex": "\\text{im}(\\phi) = \\{\\phi(a) : a \\in G\\}", "description": "Image" }
        ],
        "examples": [
          {
            "problem": "Show exp: (ℝ, +) → (ℝ⁺, ×) is a homomorphism.",
            "solution": "exp(a + b) = e^(a+b) = e^a × e^b = exp(a) × exp(b). Preserves addition to multiplication."
          },
          {
            "problem": "What is the kernel of φ: ℤ → ℤₙ, φ(a) = a mod n?",
            "solution": "ker(φ) = {a ∈ ℤ : a ≡ 0 (mod n)} = nℤ. All multiples of n."
          }
        ],
        "applications": [
          { "field": "Algebra", "description": "Structure classification, isomorphism theorems" },
          { "field": "Cryptography", "description": "Group-based protocols" },
          { "field": "Physics", "description": "Symmetry group representations" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["group-theory", "functions"],
      "nextTopics": ["isomorphism", "kernel-image"],
      "related": ["category-theory"]
    },
    "tags": ["준동형", "핵", "homomorphism", "kernel"]
  },
  {
    "id": "isomorphism",
    "name": { "ko": "동형사상", "en": "Isomorphism" },
    "field": "abstract-algebra",
    "subfield": "morphisms",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "동형사상은 전단사 준동형입니다. 두 구조가 동형이면 대수적으로 동일한 것으로 봅니다. 구조의 본질적 동일성을 나타냅니다.",
        "formulas": [
          {
            "latex": "\\phi: G \\to H \\text{ isomorphism} \\Leftrightarrow \\phi \\text{ bijective homomorphism}",
            "description": "동형사상의 정의"
          },
          { "latex": "G \\cong H", "description": "G와 H가 동형" },
          { "latex": "G / \\ker(\\phi) \\cong \\text{im}(\\phi)", "description": "제1동형정리" }
        ],
        "examples": [
          {
            "problem": "(ℤ, +)와 (2ℤ, +)가 동형임을 보이세요.",
            "solution": "φ(n) = 2n. 전단사: φ(n) = φ(m) ⇒ n = m, 모든 2k에 대해 φ(k) = 2k. 준동형: φ(n+m) = 2(n+m) = 2n + 2m = φ(n) + φ(m)."
          },
          {
            "problem": "위수 2인 모든 군이 동형임을 보이세요.",
            "solution": "위수 2인 군은 {e, a}이고 a² = e. ℤ₂ = {0, 1}와 φ(e) = 0, φ(a) = 1로 동형. 구조가 유일합니다."
          }
        ],
        "history": {
          "discoveredBy": "에미 뇌터",
          "year": "1920년대",
          "background": "뇌터가 동형정리를 일반화하고 현대 대수학의 기초를 놓았습니다."
        },
        "applications": [
          { "field": "대수학", "description": "구조 분류" },
          { "field": "그래프 이론", "description": "그래프 동형" },
          { "field": "컴퓨터 과학", "description": "자료구조 동등성" }
        ]
      },
      "en": {
        "definition": "An isomorphism is a bijective homomorphism. If two structures are isomorphic, they are algebraically identical. It represents essential structural sameness.",
        "formulas": [
          {
            "latex": "\\phi: G \\to H \\text{ isomorphism} \\Leftrightarrow \\phi \\text{ bijective homomorphism}",
            "description": "Definition of isomorphism"
          },
          { "latex": "G \\cong H", "description": "G and H are isomorphic" },
          {
            "latex": "G / \\ker(\\phi) \\cong \\text{im}(\\phi)",
            "description": "First Isomorphism Theorem"
          }
        ],
        "examples": [
          {
            "problem": "Show (ℤ, +) and (2ℤ, +) are isomorphic.",
            "solution": "φ(n) = 2n. Bijective: φ(n) = φ(m) ⇒ n = m, every 2k has preimage k. Homomorphism: φ(n+m) = 2(n+m) = 2n + 2m = φ(n) + φ(m)."
          },
          {
            "problem": "Show all groups of order 2 are isomorphic.",
            "solution": "Order 2 group is {e, a} with a² = e. Map to ℤ₂ = {0, 1} by φ(e) = 0, φ(a) = 1. Structure is unique."
          }
        ],
        "history": {
          "discoveredBy": "Emmy Noether",
          "year": "1920s",
          "background": "Noether generalized isomorphism theorems and laid foundations of modern algebra."
        },
        "applications": [
          { "field": "Algebra", "description": "Structure classification" },
          { "field": "Graph Theory", "description": "Graph isomorphism" },
          { "field": "Computer Science", "description": "Data structure equivalence" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["homomorphism"],
      "nextTopics": ["quotient-groups", "galois-theory"],
      "related": ["bijection"]
    },
    "tags": ["동형", "전단사", "isomorphism", "bijection"]
  },
  {
    "id": "complex-functions",
    "name": { "ko": "복소함수", "en": "Complex Functions" },
    "field": "complex-analysis",
    "subfield": "functions",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "복소함수는 복소수에서 복소수로의 함수입니다. f(z) = u(x,y) + iv(x,y)로 실수부와 허수부로 분해됩니다.",
        "formulas": [
          { "latex": "f(z) = f(x + iy) = u(x,y) + iv(x,y)", "description": "복소함수의 분해" },
          { "latex": "e^z = e^x(\\cos y + i\\sin y)", "description": "복소 지수함수" },
          {
            "latex": "\\sin z = \\frac{e^{iz} - e^{-iz}}{2i}, \\quad \\cos z = \\frac{e^{iz} + e^{-iz}}{2}",
            "description": "복소 삼각함수"
          }
        ],
        "examples": [
          {
            "problem": "f(z) = z²의 실수부와 허수부를 구하세요.",
            "solution": "z = x + iy일 때, z² = (x+iy)² = x² - y² + 2ixy. u(x,y) = x² - y², v(x,y) = 2xy."
          },
          {
            "problem": "e^(iπ)의 값은?",
            "solution": "e^(iπ) = cos(π) + i·sin(π) = -1 + 0i = -1 (오일러 등식)"
          }
        ],
        "history": {
          "discoveredBy": "레온하르트 오일러",
          "year": "1748년",
          "background": "오일러가 e^(iθ) = cos θ + i sin θ를 발견하며 복소해석학의 기초를 놓았습니다."
        },
        "applications": [
          { "field": "전자공학", "description": "AC 회로 분석" },
          { "field": "신호처리", "description": "푸리에 변환" },
          { "field": "양자역학", "description": "파동함수" }
        ]
      },
      "en": {
        "definition": "A complex function maps complex numbers to complex numbers. f(z) = u(x,y) + iv(x,y) decomposes into real and imaginary parts.",
        "formulas": [
          {
            "latex": "f(z) = f(x + iy) = u(x,y) + iv(x,y)",
            "description": "Decomposition of complex function"
          },
          { "latex": "e^z = e^x(\\cos y + i\\sin y)", "description": "Complex exponential" },
          {
            "latex": "\\sin z = \\frac{e^{iz} - e^{-iz}}{2i}, \\quad \\cos z = \\frac{e^{iz} + e^{-iz}}{2}",
            "description": "Complex trigonometric functions"
          }
        ],
        "examples": [
          {
            "problem": "Find real and imaginary parts of f(z) = z².",
            "solution": "For z = x + iy, z² = (x+iy)² = x² - y² + 2ixy. u(x,y) = x² - y², v(x,y) = 2xy."
          },
          {
            "problem": "What is e^(iπ)?",
            "solution": "e^(iπ) = cos(π) + i·sin(π) = -1 + 0i = -1 (Euler's identity)"
          }
        ],
        "history": {
          "discoveredBy": "Leonhard Euler",
          "year": "1748",
          "background": "Euler discovered e^(iθ) = cos θ + i sin θ, laying foundations for complex analysis."
        },
        "applications": [
          { "field": "Electrical Engineering", "description": "AC circuit analysis" },
          { "field": "Signal Processing", "description": "Fourier transform" },
          { "field": "Quantum Mechanics", "description": "Wave functions" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["complex-numbers", "functions"],
      "nextTopics": ["cauchy-riemann", "analytic-functions"],
      "related": ["euler-formula"]
    },
    "tags": ["복소함수", "오일러", "complex function", "Euler"]
  },
  {
    "id": "cauchy-riemann",
    "name": { "ko": "코시-리만 방정식", "en": "Cauchy-Riemann Equations" },
    "field": "complex-analysis",
    "subfield": "analyticity",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "코시-리만 방정식은 복소함수가 미분가능(해석적)할 필요충분조건입니다. 실수부와 허수부의 편미분 관계를 나타냅니다.",
        "formulas": [
          {
            "latex": "\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y}",
            "description": "첫 번째 코시-리만 방정식"
          },
          {
            "latex": "\\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x}",
            "description": "두 번째 코시-리만 방정식"
          },
          {
            "latex": "f'(z) = \\frac{\\partial u}{\\partial x} + i\\frac{\\partial v}{\\partial x}",
            "description": "복소 미분"
          }
        ],
        "examples": [
          {
            "problem": "f(z) = z²이 해석적임을 코시-리만 방정식으로 확인하세요.",
            "solution": "u = x² - y², v = 2xy. ∂u/∂x = 2x = ∂v/∂y ✓. ∂u/∂y = -2y = -∂v/∂x ✓. 해석적입니다."
          },
          {
            "problem": "f(z) = |z|²가 해석적이지 않음을 보이세요.",
            "solution": "f(z) = x² + y². u = x² + y², v = 0. ∂u/∂x = 2x ≠ 0 = ∂v/∂y (원점 제외). 해석적이지 않습니다."
          }
        ],
        "history": {
          "discoveredBy": "오귀스탱 루이 코시, 베른하르트 리만",
          "year": "1851년",
          "background": "코시가 먼저 유도했고, 리만이 일반화하여 복소해석학의 기초가 되었습니다."
        },
        "applications": [
          { "field": "유체역학", "description": "비압축성 유동" },
          { "field": "전자기학", "description": "정전기 퍼텐셜" },
          { "field": "탄성학", "description": "2D 응력 해석" }
        ]
      },
      "en": {
        "definition": "Cauchy-Riemann equations are necessary and sufficient conditions for a complex function to be differentiable (analytic). They relate partial derivatives of real and imaginary parts.",
        "formulas": [
          {
            "latex": "\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y}",
            "description": "First Cauchy-Riemann equation"
          },
          {
            "latex": "\\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x}",
            "description": "Second Cauchy-Riemann equation"
          },
          {
            "latex": "f'(z) = \\frac{\\partial u}{\\partial x} + i\\frac{\\partial v}{\\partial x}",
            "description": "Complex derivative"
          }
        ],
        "examples": [
          {
            "problem": "Verify f(z) = z² is analytic using Cauchy-Riemann.",
            "solution": "u = x² - y², v = 2xy. ∂u/∂x = 2x = ∂v/∂y ✓. ∂u/∂y = -2y = -∂v/∂x ✓. It's analytic."
          },
          {
            "problem": "Show f(z) = |z|² is not analytic.",
            "solution": "f(z) = x² + y². u = x² + y², v = 0. ∂u/∂x = 2x ≠ 0 = ∂v/∂y (except origin). Not analytic."
          }
        ],
        "history": {
          "discoveredBy": "Augustin-Louis Cauchy, Bernhard Riemann",
          "year": "1851",
          "background": "Cauchy first derived them; Riemann generalized, forming basis of complex analysis."
        },
        "applications": [
          { "field": "Fluid Mechanics", "description": "Incompressible flow" },
          { "field": "Electromagnetism", "description": "Electrostatic potential" },
          { "field": "Elasticity", "description": "2D stress analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["complex-functions", "partial-derivative"],
      "nextTopics": ["analytic-functions", "harmonic-functions"],
      "related": ["laplace-equation"]
    },
    "tags": ["코시리만", "해석적", "Cauchy-Riemann", "analytic"]
  },
  {
    "id": "analytic-functions",
    "name": { "ko": "해석함수", "en": "Analytic Functions" },
    "field": "complex-analysis",
    "subfield": "analyticity",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "해석함수(정칙함수)는 정의역의 모든 점에서 복소미분가능한 함수입니다. 무한 번 미분가능하고 테일러 급수로 표현됩니다.",
        "formulas": [
          {
            "latex": "f(z) = \\sum_{n=0}^{\\infty} a_n (z - z_0)^n",
            "description": "테일러 급수 전개"
          },
          {
            "latex": "a_n = \\frac{f^{(n)}(z_0)}{n!} = \\frac{1}{2\\pi i}\\oint_C \\frac{f(z)}{(z-z_0)^{n+1}}dz",
            "description": "테일러 계수"
          }
        ],
        "examples": [
          {
            "problem": "e^z의 테일러 급수를 z₀ = 0에서 구하세요.",
            "solution": "e^z = Σ(z^n/n!) = 1 + z + z²/2! + z³/3! + ... 수렴반경은 무한대입니다."
          },
          {
            "problem": "sin z의 급수 전개는?",
            "solution": "sin z = z - z³/3! + z⁵/5! - z⁷/7! + ... = Σ((-1)^n z^(2n+1)/(2n+1)!)"
          }
        ],
        "applications": [
          { "field": "물리학", "description": "양자역학, 통계역학" },
          { "field": "공학", "description": "신호 처리, 제어 이론" },
          { "field": "수학", "description": "정수론, 조합론" }
        ]
      },
      "en": {
        "definition": "An analytic (holomorphic) function is complex differentiable at every point in its domain. It's infinitely differentiable and expressible as Taylor series.",
        "formulas": [
          {
            "latex": "f(z) = \\sum_{n=0}^{\\infty} a_n (z - z_0)^n",
            "description": "Taylor series expansion"
          },
          {
            "latex": "a_n = \\frac{f^{(n)}(z_0)}{n!} = \\frac{1}{2\\pi i}\\oint_C \\frac{f(z)}{(z-z_0)^{n+1}}dz",
            "description": "Taylor coefficients"
          }
        ],
        "examples": [
          {
            "problem": "Find Taylor series of e^z at z₀ = 0.",
            "solution": "e^z = Σ(z^n/n!) = 1 + z + z²/2! + z³/3! + ... Radius of convergence is infinite."
          },
          {
            "problem": "What is the series expansion of sin z?",
            "solution": "sin z = z - z³/3! + z⁵/5! - z⁷/7! + ... = Σ((-1)^n z^(2n+1)/(2n+1)!)"
          }
        ],
        "applications": [
          { "field": "Physics", "description": "Quantum mechanics, statistical mechanics" },
          { "field": "Engineering", "description": "Signal processing, control theory" },
          { "field": "Mathematics", "description": "Number theory, combinatorics" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["cauchy-riemann", "taylor-series"],
      "nextTopics": ["residue-theorem", "laurent-series"],
      "related": ["power-series"]
    },
    "tags": ["해석함수", "정칙함수", "analytic", "holomorphic"]
  },
  {
    "id": "residue-theorem",
    "name": { "ko": "유수 정리", "en": "Residue Theorem" },
    "field": "complex-analysis",
    "subfield": "integration",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "유수 정리는 닫힌 경로를 따른 복소적분이 내부 특이점들의 유수 합으로 계산됨을 말합니다. 실수 적분 계산에 강력한 도구입니다.",
        "formulas": [
          {
            "latex": "\\oint_C f(z) dz = 2\\pi i \\sum_{k} \\text{Res}(f, z_k)",
            "description": "유수 정리"
          },
          {
            "latex": "\\text{Res}(f, z_0) = \\lim_{z \\to z_0} (z - z_0)f(z)",
            "description": "단순극에서의 유수"
          },
          {
            "latex": "\\text{Res}(f, z_0) = \\frac{1}{(n-1)!}\\lim_{z \\to z_0}\\frac{d^{n-1}}{dz^{n-1}}[(z-z_0)^n f(z)]",
            "description": "n차 극에서의 유수"
          }
        ],
        "examples": [
          {
            "problem": "∮ 1/(z²+1) dz를 |z| = 2 위에서 계산하세요.",
            "solution": "특이점: z = ±i (모두 내부). Res(f, i) = 1/(2i), Res(f, -i) = -1/(2i). 적분 = 2πi(1/(2i) - 1/(2i)) = 0"
          },
          {
            "problem": "∫₀^∞ dx/(x²+1)을 유수로 계산하세요.",
            "solution": "상반면 반원 경로. z = i만 내부. Res(f, i) = 1/(2i). ∮ = 2πi·(1/(2i)) = π. 실수축 기여만 남아 ∫₀^∞ = π/2"
          }
        ],
        "history": {
          "discoveredBy": "오귀스탱 루이 코시",
          "year": "1825년",
          "background": "코시가 복소적분론을 개발하면서 유수 정리를 증명했습니다."
        },
        "applications": [
          { "field": "물리학", "description": "전파함수, 그린함수" },
          { "field": "공학", "description": "라플라스 역변환" },
          { "field": "정수론", "description": "소수 분포" }
        ]
      },
      "en": {
        "definition": "The residue theorem states that contour integrals equal 2πi times the sum of residues at interior singularities. It's a powerful tool for computing real integrals.",
        "formulas": [
          {
            "latex": "\\oint_C f(z) dz = 2\\pi i \\sum_{k} \\text{Res}(f, z_k)",
            "description": "Residue theorem"
          },
          {
            "latex": "\\text{Res}(f, z_0) = \\lim_{z \\to z_0} (z - z_0)f(z)",
            "description": "Residue at simple pole"
          },
          {
            "latex": "\\text{Res}(f, z_0) = \\frac{1}{(n-1)!}\\lim_{z \\to z_0}\\frac{d^{n-1}}{dz^{n-1}}[(z-z_0)^n f(z)]",
            "description": "Residue at pole of order n"
          }
        ],
        "examples": [
          {
            "problem": "Compute ∮ 1/(z²+1) dz over |z| = 2.",
            "solution": "Singularities: z = ±i (both inside). Res(f, i) = 1/(2i), Res(f, -i) = -1/(2i). Integral = 2πi(1/(2i) - 1/(2i)) = 0"
          },
          {
            "problem": "Compute ∫₀^∞ dx/(x²+1) using residues.",
            "solution": "Upper semicircle contour. Only z = i inside. Res(f, i) = 1/(2i). ∮ = 2πi·(1/(2i)) = π. Real axis contribution: ∫₀^∞ = π/2"
          }
        ],
        "history": {
          "discoveredBy": "Augustin-Louis Cauchy",
          "year": "1825",
          "background": "Cauchy proved the residue theorem while developing complex integration theory."
        },
        "applications": [
          { "field": "Physics", "description": "Propagators, Green's functions" },
          { "field": "Engineering", "description": "Inverse Laplace transform" },
          { "field": "Number Theory", "description": "Prime distribution" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["analytic-functions", "laurent-series"],
      "nextTopics": ["argument-principle"],
      "related": ["contour-integration"]
    },
    "tags": ["유수", "복소적분", "residue", "contour integral"]
  },
  {
    "id": "conformal-mapping",
    "name": { "ko": "등각사상", "en": "Conformal Mapping" },
    "field": "complex-analysis",
    "subfield": "geometric",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "등각사상은 각도를 보존하는 변환입니다. 해석함수는 f'(z) ≠ 0인 점에서 등각입니다. 복잡한 영역을 단순한 영역으로 변환합니다.",
        "formulas": [
          { "latex": "w = f(z), \\quad f'(z_0) \\neq 0", "description": "등각사상의 조건" },
          {
            "latex": "w = \\frac{az + b}{cz + d}, \\quad ad - bc \\neq 0",
            "description": "뫼비우스 변환 (선형분수변환)"
          },
          { "latex": "w = e^z", "description": "띠 영역을 쐐기 영역으로" },
          { "latex": "w = \\frac{z - i}{z + i}", "description": "카일리 변환 (상반면 → 단위원)" }
        ],
        "examples": [
          {
            "problem": "w = z²이 제1사분면을 어떤 영역으로 사상하는지 설명하세요.",
            "solution": "z = re^(iθ), 0 < θ < π/2일 때, w = r²e^(2iθ), 0 < 2θ < π. 제1사분면이 상반면으로 사상됩니다."
          },
          {
            "problem": "뫼비우스 변환이 원을 원으로 보냄을 설명하세요.",
            "solution": "뫼비우스 변환은 원과 직선을 원과 직선으로 사상합니다. 직선은 무한대를 지나는 원으로 볼 수 있습니다."
          }
        ],
        "history": {
          "discoveredBy": "베른하르트 리만",
          "year": "1851년",
          "background": "리만 사상 정리: 단순 연결 영역은 단위 원판과 등각동형입니다."
        },
        "applications": [
          { "field": "유체역학", "description": "날개 주위 유동 (주코프스키)" },
          { "field": "전자기학", "description": "정전기 문제" },
          { "field": "지도학", "description": "지도 투영법" }
        ]
      },
      "en": {
        "definition": "A conformal mapping preserves angles. Analytic functions are conformal where f'(z) ≠ 0. It transforms complex regions to simpler ones.",
        "formulas": [
          {
            "latex": "w = f(z), \\quad f'(z_0) \\neq 0",
            "description": "Condition for conformality"
          },
          {
            "latex": "w = \\frac{az + b}{cz + d}, \\quad ad - bc \\neq 0",
            "description": "Möbius transformation (LFT)"
          },
          { "latex": "w = e^z", "description": "Strip to wedge" },
          {
            "latex": "w = \\frac{z - i}{z + i}",
            "description": "Cayley transform (half-plane → unit disk)"
          }
        ],
        "examples": [
          {
            "problem": "Describe how w = z² maps first quadrant.",
            "solution": "For z = re^(iθ), 0 < θ < π/2, w = r²e^(2iθ), 0 < 2θ < π. First quadrant maps to upper half-plane."
          },
          {
            "problem": "Explain why Möbius maps circles to circles.",
            "solution": "Möbius transformations map circles and lines to circles and lines. Lines are circles passing through infinity."
          }
        ],
        "history": {
          "discoveredBy": "Bernhard Riemann",
          "year": "1851",
          "background": "Riemann Mapping Theorem: Simply connected regions are conformally equivalent to the unit disk."
        },
        "applications": [
          { "field": "Fluid Mechanics", "description": "Airfoil flow (Joukowski)" },
          { "field": "Electromagnetism", "description": "Electrostatic problems" },
          { "field": "Cartography", "description": "Map projections" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["analytic-functions", "cauchy-riemann"],
      "nextTopics": ["riemann-surfaces"],
      "related": ["geometry"]
    },
    "tags": ["등각사상", "뫼비우스", "conformal", "Möbius"]
  },
  {
    "id": "compound-interest",
    "name": { "ko": "복리", "en": "Compound Interest" },
    "field": "applied-finance",
    "subfield": "basic-finance",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "복리는 원금뿐만 아니라 이전에 발생한 이자에도 이자가 붙는 방식입니다. '이자에 이자가 붙는' 눈덩이 효과를 만듭니다.",
        "formulas": [
          { "latex": "A = P(1 + r)^n", "description": "복리 공식 (연 복리)" },
          {
            "latex": "A = P\\left(1 + \\frac{r}{m}\\right)^{mn}",
            "description": "m회 복리 (연 m회)"
          },
          { "latex": "A = Pe^{rt}", "description": "연속 복리" },
          {
            "latex": "t_{2x} = \\frac{72}{r\\%} \\approx \\frac{\\ln 2}{r}",
            "description": "72의 법칙 (원금 2배 시간)"
          }
        ],
        "examples": [
          {
            "problem": "100만원을 연 5% 복리로 10년 예치하면?",
            "solution": "A = 1,000,000 × (1.05)^10 = 1,628,895원"
          },
          {
            "problem": "연 6%일 때 원금이 2배가 되는 시간은?",
            "solution": "72의 법칙: 72 ÷ 6 = 12년"
          }
        ],
        "applications": [
          { "field": "예금/대출", "description": "이자 계산" },
          { "field": "투자", "description": "장기 수익 예측" },
          { "field": "인플레이션", "description": "화폐가치 변화" }
        ]
      },
      "en": {
        "definition": "Compound interest is when interest is added to principal, and future interest is earned on both. Creates a snowball effect.",
        "formulas": [
          { "latex": "A = P(1 + r)^n", "description": "Compound interest formula (annual)" },
          {
            "latex": "A = P\\left(1 + \\frac{r}{m}\\right)^{mn}",
            "description": "m times compounding per year"
          },
          { "latex": "A = Pe^{rt}", "description": "Continuous compounding" },
          {
            "latex": "t_{2x} = \\frac{72}{r\\%} \\approx \\frac{\\ln 2}{r}",
            "description": "Rule of 72 (doubling time)"
          }
        ],
        "examples": [
          {
            "problem": "Invest $10,000 at 5% for 10 years?",
            "solution": "A = 10,000 × (1.05)^10 = $16,288.95"
          },
          { "problem": "At 6%, how long to double?", "solution": "Rule of 72: 72 ÷ 6 = 12 years" }
        ],
        "applications": [
          { "field": "Banking", "description": "Interest calculation" },
          { "field": "Investment", "description": "Long-term return projection" },
          { "field": "Inflation", "description": "Purchasing power change" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["exponents", "logarithm"],
      "nextTopics": ["present-value", "annuity"],
      "related": ["e-constant", "exponential-growth"]
    },
    "tags": ["복리", "이자", "compound interest", "finance"]
  },
  {
    "id": "moving-average",
    "name": { "ko": "이동평균", "en": "Moving Average" },
    "field": "applied-finance",
    "subfield": "technical-analysis",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "이동평균은 일정 기간의 데이터 평균을 연속적으로 계산한 것입니다. 추세를 파악하고 노이즈를 제거하는 데 사용됩니다.",
        "formulas": [
          {
            "latex": "SMA_n = \\frac{1}{n}\\sum_{i=0}^{n-1} P_{t-i}",
            "description": "단순이동평균 (SMA)"
          },
          {
            "latex": "EMA_t = \\alpha P_t + (1-\\alpha)EMA_{t-1}",
            "description": "지수이동평균 (EMA), α = 2/(n+1)"
          }
        ],
        "examples": [
          {
            "problem": "주가가 10, 11, 12, 13, 14일 때 5일 SMA는?",
            "solution": "SMA = (10+11+12+13+14)/5 = 12"
          },
          { "problem": "20일 EMA의 가중치 α는?", "solution": "α = 2/(20+1) = 2/21 ≈ 0.095" }
        ],
        "applications": [
          { "field": "주식 분석", "description": "추세 확인, 지지/저항선" },
          { "field": "시계열 분석", "description": "추세 추출" },
          { "field": "신호 처리", "description": "노이즈 필터링" }
        ]
      },
      "en": {
        "definition": "Moving average continuously calculates average over a fixed period. Used to identify trends and reduce noise.",
        "formulas": [
          {
            "latex": "SMA_n = \\frac{1}{n}\\sum_{i=0}^{n-1} P_{t-i}",
            "description": "Simple Moving Average (SMA)"
          },
          {
            "latex": "EMA_t = \\alpha P_t + (1-\\alpha)EMA_{t-1}",
            "description": "Exponential Moving Average (EMA), α = 2/(n+1)"
          }
        ],
        "examples": [
          {
            "problem": "Prices: 10, 11, 12, 13, 14. What's 5-day SMA?",
            "solution": "SMA = (10+11+12+13+14)/5 = 12"
          },
          {
            "problem": "What's the weight α for 20-day EMA?",
            "solution": "α = 2/(20+1) = 2/21 ≈ 0.095"
          }
        ],
        "applications": [
          { "field": "Stock Analysis", "description": "Trend, support/resistance" },
          { "field": "Time Series", "description": "Trend extraction" },
          { "field": "Signal Processing", "description": "Noise filtering" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["mean", "summation-notation"],
      "nextTopics": ["bollinger-bands", "macd"],
      "related": ["weighted-average"]
    },
    "tags": ["이동평균", "SMA", "EMA", "moving average", "technical"]
  },
  {
    "id": "bollinger-bands",
    "name": { "ko": "볼린저 밴드", "en": "Bollinger Bands" },
    "field": "applied-finance",
    "subfield": "technical-analysis",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "볼린저 밴드는 이동평균 위아래에 표준편차 밴드를 그린 것입니다. 가격의 상대적 위치와 변동성을 동시에 보여줍니다.",
        "formulas": [
          { "latex": "\\text{Middle} = SMA_{20}", "description": "중심선 (20일 이동평균)" },
          { "latex": "\\text{Upper} = SMA_{20} + 2\\sigma", "description": "상단 밴드" },
          { "latex": "\\text{Lower} = SMA_{20} - 2\\sigma", "description": "하단 밴드" },
          {
            "latex": "\\%B = \\frac{P - Lower}{Upper - Lower}",
            "description": "%B 지표 (밴드 내 위치)"
          }
        ],
        "examples": [
          {
            "problem": "SMA=100, σ=5일 때 볼린저 밴드는?",
            "solution": "상단: 110, 중심: 100, 하단: 90"
          },
          {
            "problem": "가격이 상단 밴드에 닿으면?",
            "solution": "과매수 신호로 해석 가능, 변동성 확대 또는 추세 강화 신호"
          }
        ],
        "history": {
          "discoveredBy": "존 볼린저",
          "year": "1980년대",
          "background": "볼린저가 개발한 대표적인 기술적 분석 도구입니다."
        },
        "applications": [
          { "field": "주식 매매", "description": "과매수/과매도 판단" },
          { "field": "변동성 분석", "description": "밴드 폭으로 변동성 측정" },
          { "field": "추세 판단", "description": "밴드 방향으로 추세 확인" }
        ]
      },
      "en": {
        "definition": "Bollinger Bands plot standard deviation bands around a moving average. Shows relative price position and volatility together.",
        "formulas": [
          { "latex": "\\text{Middle} = SMA_{20}", "description": "Middle band (20-day SMA)" },
          { "latex": "\\text{Upper} = SMA_{20} + 2\\sigma", "description": "Upper band" },
          { "latex": "\\text{Lower} = SMA_{20} - 2\\sigma", "description": "Lower band" },
          {
            "latex": "\\%B = \\frac{P - Lower}{Upper - Lower}",
            "description": "%B indicator (position in band)"
          }
        ],
        "examples": [
          {
            "problem": "If SMA=100, σ=5, what are the bands?",
            "solution": "Upper: 110, Middle: 100, Lower: 90"
          },
          {
            "problem": "What if price touches upper band?",
            "solution": "Possible overbought signal, or volatility expansion/trend strength"
          }
        ],
        "history": {
          "discoveredBy": "John Bollinger",
          "year": "1980s",
          "background": "Developed by Bollinger as a technical analysis tool."
        },
        "applications": [
          { "field": "Trading", "description": "Overbought/oversold detection" },
          { "field": "Volatility", "description": "Measure via band width" },
          { "field": "Trend", "description": "Direction from band slope" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["moving-average", "standard-deviation"],
      "nextTopics": ["keltner-channel"],
      "related": ["rsi", "macd"]
    },
    "tags": ["볼린저", "밴드", "Bollinger", "technical analysis"]
  },
  {
    "id": "black-scholes",
    "name": { "ko": "블랙-숄즈 모형", "en": "Black-Scholes Model" },
    "field": "applied-finance",
    "subfield": "derivatives",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "블랙-숄즈 모형은 유럽형 옵션의 이론적 가격을 계산하는 수학적 모형입니다. 확률미적분학에 기반합니다.",
        "formulas": [
          { "latex": "C = S_0 N(d_1) - Ke^{-rT}N(d_2)", "description": "콜옵션 가격" },
          {
            "latex": "d_1 = \\frac{\\ln(S_0/K) + (r + \\sigma^2/2)T}{\\sigma\\sqrt{T}}",
            "description": "d₁ 계산"
          },
          { "latex": "d_2 = d_1 - \\sigma\\sqrt{T}", "description": "d₂ 계산" },
          {
            "latex": "\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + rS\\frac{\\partial V}{\\partial S} - rV = 0",
            "description": "블랙-숄즈 편미분방정식"
          }
        ],
        "examples": [
          {
            "problem": "S=100, K=100, r=5%, σ=20%, T=1일 때 콜옵션 가격은?",
            "solution": "d₁ ≈ 0.35, d₂ ≈ 0.15, C ≈ $10.45"
          }
        ],
        "history": {
          "discoveredBy": "피셔 블랙, 마이런 숄즈",
          "year": "1973년",
          "background": "숄즈와 머튼이 1997년 노벨 경제학상을 수상했습니다."
        },
        "applications": [
          { "field": "파생상품", "description": "옵션 가격 책정" },
          { "field": "리스크 관리", "description": "그릭스 계산" },
          { "field": "변동성 분석", "description": "내재변동성 추정" }
        ]
      },
      "en": {
        "definition": "Black-Scholes model calculates theoretical prices of European options. Based on stochastic calculus.",
        "formulas": [
          { "latex": "C = S_0 N(d_1) - Ke^{-rT}N(d_2)", "description": "Call option price" },
          {
            "latex": "d_1 = \\frac{\\ln(S_0/K) + (r + \\sigma^2/2)T}{\\sigma\\sqrt{T}}",
            "description": "d₁ calculation"
          },
          { "latex": "d_2 = d_1 - \\sigma\\sqrt{T}", "description": "d₂ calculation" },
          {
            "latex": "\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + rS\\frac{\\partial V}{\\partial S} - rV = 0",
            "description": "Black-Scholes PDE"
          }
        ],
        "examples": [
          {
            "problem": "S=100, K=100, r=5%, σ=20%, T=1. Call price?",
            "solution": "d₁ ≈ 0.35, d₂ ≈ 0.15, C ≈ $10.45"
          }
        ],
        "history": {
          "discoveredBy": "Fischer Black, Myron Scholes",
          "year": "1973",
          "background": "Scholes and Merton won 1997 Nobel Prize in Economics."
        },
        "applications": [
          { "field": "Derivatives", "description": "Option pricing" },
          { "field": "Risk Management", "description": "Greeks calculation" },
          { "field": "Volatility", "description": "Implied volatility estimation" }
        ]
      }
    },
    "relations": {
      "prerequisites": [
        "normal-distribution",
        "partial-differential-equation",
        "stochastic-calculus"
      ],
      "nextTopics": ["greeks", "monte-carlo-simulation"],
      "related": ["brownian-motion", "ito-calculus"]
    },
    "tags": ["블랙숄즈", "옵션", "Black-Scholes", "derivatives"]
  },
  {
    "id": "fibonacci-retracement",
    "name": { "ko": "피보나치 되돌림", "en": "Fibonacci Retracement" },
    "field": "applied-finance",
    "subfield": "technical-analysis",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "피보나치 되돌림은 추세 조정 시 지지/저항 수준을 예측하는 도구입니다. 피보나치 수열의 비율을 사용합니다.",
        "formulas": [
          {
            "latex": "\\text{되돌림 수준} = 23.6\\%, 38.2\\%, 50\\%, 61.8\\%, 78.6\\%",
            "description": "주요 피보나치 비율"
          },
          { "latex": "\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618", "description": "황금비" },
          {
            "latex": "\\frac{F_n}{F_{n+1}} \\to \\frac{1}{\\phi} \\approx 0.618",
            "description": "피보나치 비율의 유래"
          }
        ],
        "examples": [
          {
            "problem": "주가가 100에서 150으로 상승 후 38.2% 되돌림 수준은?",
            "solution": "150 - (50 × 0.382) = 150 - 19.1 = 130.9"
          },
          {
            "problem": "61.8% 되돌림이 중요한 이유는?",
            "solution": "황금비의 역수(1/φ)로, 자연과 시장에서 자주 나타나는 비율"
          }
        ],
        "applications": [
          { "field": "주식/외환", "description": "지지/저항선 예측" },
          { "field": "진입점 결정", "description": "매수/매도 타이밍" },
          { "field": "목표가 설정", "description": "확장 수준 활용" }
        ]
      },
      "en": {
        "definition": "Fibonacci retracement predicts support/resistance levels during trend corrections using Fibonacci ratios.",
        "formulas": [
          {
            "latex": "\\text{Retracement levels} = 23.6\\%, 38.2\\%, 50\\%, 61.8\\%, 78.6\\%",
            "description": "Key Fibonacci ratios"
          },
          {
            "latex": "\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618",
            "description": "Golden ratio"
          },
          {
            "latex": "\\frac{F_n}{F_{n+1}} \\to \\frac{1}{\\phi} \\approx 0.618",
            "description": "Origin of Fibonacci ratios"
          }
        ],
        "examples": [
          {
            "problem": "Price rose from 100 to 150. What's 38.2% retracement?",
            "solution": "150 - (50 × 0.382) = 150 - 19.1 = 130.9"
          },
          {
            "problem": "Why is 61.8% significant?",
            "solution": "Inverse of golden ratio (1/φ), appears frequently in nature and markets"
          }
        ],
        "applications": [
          { "field": "Stocks/Forex", "description": "Support/resistance prediction" },
          { "field": "Entry Points", "description": "Buy/sell timing" },
          { "field": "Price Targets", "description": "Using extension levels" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["fibonacci", "golden-ratio"],
      "nextTopics": ["fibonacci-extension", "elliott-wave"],
      "related": ["moving-average", "support-resistance"]
    },
    "tags": ["피보나치", "되돌림", "Fibonacci", "retracement"]
  },
  {
    "id": "ichimoku-cloud",
    "name": { "ko": "일목균형표", "en": "Ichimoku Cloud" },
    "field": "applied-finance",
    "subfield": "technical-analysis",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "일목균형표는 지지/저항, 추세, 모멘텀을 한눈에 보여주는 종합 지표입니다. 일본에서 개발되었습니다.",
        "formulas": [
          {
            "latex": "\\text{전환선} = \\frac{\\text{9일 고가} + \\text{9일 저가}}{2}",
            "description": "전환선 (Tenkan-sen)"
          },
          {
            "latex": "\\text{기준선} = \\frac{\\text{26일 고가} + \\text{26일 저가}}{2}",
            "description": "기준선 (Kijun-sen)"
          },
          {
            "latex": "\\text{선행스팬A} = \\frac{\\text{전환선} + \\text{기준선}}{2}",
            "description": "선행스팬A (26일 선행)"
          },
          {
            "latex": "\\text{선행스팬B} = \\frac{\\text{52일 고가} + \\text{52일 저가}}{2}",
            "description": "선행스팬B (26일 선행)"
          },
          {
            "latex": "\\text{후행스팬} = \\text{현재 종가 (26일 후행)}",
            "description": "후행스팬 (Chikou Span)"
          }
        ],
        "examples": [
          {
            "problem": "가격이 구름 위에 있으면?",
            "solution": "상승 추세, 구름이 지지선 역할. 구름이 두꺼울수록 지지가 강함"
          },
          {
            "problem": "전환선이 기준선을 상향 돌파하면?",
            "solution": "매수 신호 (골든크로스와 유사)"
          }
        ],
        "history": {
          "discoveredBy": "호소다 고이치 (一目山人)",
          "year": "1930년대 (발표 1969년)",
          "background": "30년간 연구 끝에 개발한 일본의 대표적 기술적 분석 도구"
        },
        "applications": [
          { "field": "추세 분석", "description": "구름 위/아래로 추세 판단" },
          { "field": "지지/저항", "description": "구름이 지지/저항 영역" },
          { "field": "매매 신호", "description": "선 교차로 진입/청산 시점" }
        ]
      },
      "en": {
        "definition": "Ichimoku Cloud is a comprehensive indicator showing support/resistance, trend, and momentum at a glance. Developed in Japan.",
        "formulas": [
          {
            "latex": "\\text{Tenkan-sen} = \\frac{\\text{9-day high} + \\text{9-day low}}{2}",
            "description": "Conversion Line"
          },
          {
            "latex": "\\text{Kijun-sen} = \\frac{\\text{26-day high} + \\text{26-day low}}{2}",
            "description": "Base Line"
          },
          {
            "latex": "\\text{Senkou A} = \\frac{\\text{Tenkan} + \\text{Kijun}}{2}",
            "description": "Leading Span A (26 periods ahead)"
          },
          {
            "latex": "\\text{Senkou B} = \\frac{\\text{52-day high} + \\text{52-day low}}{2}",
            "description": "Leading Span B (26 periods ahead)"
          },
          {
            "latex": "\\text{Chikou} = \\text{Current close (26 periods back)}",
            "description": "Lagging Span"
          }
        ],
        "examples": [
          {
            "problem": "What if price is above the cloud?",
            "solution": "Uptrend, cloud acts as support. Thicker cloud = stronger support"
          },
          {
            "problem": "Tenkan crosses above Kijun?",
            "solution": "Buy signal (similar to golden cross)"
          }
        ],
        "history": {
          "discoveredBy": "Goichi Hosoda (Ichimoku Sanjin)",
          "year": "1930s (published 1969)",
          "background": "Developed over 30 years of research, iconic Japanese technical tool"
        },
        "applications": [
          { "field": "Trend Analysis", "description": "Above/below cloud for trend" },
          { "field": "Support/Resistance", "description": "Cloud as S/R zone" },
          { "field": "Trading Signals", "description": "Line crosses for entry/exit" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["moving-average", "support-resistance"],
      "nextTopics": ["advanced-ichimoku"],
      "related": ["bollinger-bands", "macd"]
    },
    "tags": ["일목균형표", "구름", "Ichimoku", "Japanese"]
  },
  {
    "id": "present-value",
    "name": { "ko": "현재가치", "en": "Present Value" },
    "field": "applied-finance",
    "subfield": "basic-finance",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "현재가치(PV)는 미래 현금흐름의 현재 시점 가치입니다. 돈의 시간가치를 반영하여 할인합니다.",
        "formulas": [
          { "latex": "PV = \\frac{FV}{(1+r)^n}", "description": "현재가치 공식" },
          {
            "latex": "PV = \\sum_{t=1}^{n} \\frac{CF_t}{(1+r)^t}",
            "description": "현금흐름의 현재가치 합"
          },
          {
            "latex": "NPV = \\sum_{t=0}^{n} \\frac{CF_t}{(1+r)^t}",
            "description": "순현재가치 (NPV)"
          }
        ],
        "examples": [
          {
            "problem": "3년 후 100만원의 현재가치는? (할인율 5%)",
            "solution": "PV = 1,000,000 / (1.05)³ = 863,838원"
          },
          {
            "problem": "매년 10만원을 3년간 받는다면? (할인율 5%)",
            "solution": "PV = 100,000/1.05 + 100,000/1.05² + 100,000/1.05³ = 272,325원"
          }
        ],
        "applications": [
          { "field": "투자 분석", "description": "프로젝트 가치 평가" },
          { "field": "채권 가격", "description": "쿠폰 할인" },
          { "field": "연금", "description": "미래 지급액 현재가치" }
        ]
      },
      "en": {
        "definition": "Present Value (PV) is the current value of future cash flows. Discounts for time value of money.",
        "formulas": [
          { "latex": "PV = \\frac{FV}{(1+r)^n}", "description": "Present value formula" },
          {
            "latex": "PV = \\sum_{t=1}^{n} \\frac{CF_t}{(1+r)^t}",
            "description": "PV of cash flow series"
          },
          {
            "latex": "NPV = \\sum_{t=0}^{n} \\frac{CF_t}{(1+r)^t}",
            "description": "Net Present Value (NPV)"
          }
        ],
        "examples": [
          {
            "problem": "PV of $1M in 3 years at 5% discount?",
            "solution": "PV = 1,000,000 / (1.05)³ = $863,838"
          },
          {
            "problem": "PV of $100K/year for 3 years at 5%?",
            "solution": "PV = 100K/1.05 + 100K/1.05² + 100K/1.05³ = $272,325"
          }
        ],
        "applications": [
          { "field": "Investment Analysis", "description": "Project valuation" },
          { "field": "Bond Pricing", "description": "Coupon discounting" },
          { "field": "Annuities", "description": "Future payment valuation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["compound-interest"],
      "nextTopics": ["irr", "bond-pricing"],
      "related": ["future-value", "discount-rate"]
    },
    "tags": ["현재가치", "할인", "present value", "NPV"]
  },
  {
    "id": "sharpe-ratio",
    "name": { "ko": "샤프 비율", "en": "Sharpe Ratio" },
    "field": "applied-finance",
    "subfield": "portfolio",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "샤프 비율은 위험 대비 초과수익을 측정합니다. 높을수록 같은 위험에서 더 좋은 수익을 의미합니다.",
        "formulas": [
          { "latex": "SR = \\frac{R_p - R_f}{\\sigma_p}", "description": "샤프 비율" },
          { "latex": "R_p = \\text{포트폴리오 수익률}", "description": "포트폴리오 기대수익" },
          { "latex": "R_f = \\text{무위험 수익률}", "description": "국채 등 무위험 자산" },
          { "latex": "\\sigma_p = \\text{포트폴리오 표준편차}", "description": "변동성 (위험)" }
        ],
        "examples": [
          {
            "problem": "수익률 12%, 무위험 2%, 표준편차 15%일 때 샤프 비율은?",
            "solution": "SR = (12% - 2%) / 15% = 0.67"
          },
          { "problem": "샤프 비율이 1 이상이면?", "solution": "일반적으로 좋은 투자로 평가됨" }
        ],
        "history": {
          "discoveredBy": "윌리엄 샤프",
          "year": "1966년",
          "background": "CAPM 개발로 1990년 노벨 경제학상 수상"
        },
        "applications": [
          { "field": "펀드 평가", "description": "펀드 성과 비교" },
          { "field": "포트폴리오", "description": "자산 배분 최적화" },
          { "field": "리스크 관리", "description": "위험조정 수익 평가" }
        ]
      },
      "en": {
        "definition": "Sharpe ratio measures excess return per unit of risk. Higher means better returns for the same risk level.",
        "formulas": [
          { "latex": "SR = \\frac{R_p - R_f}{\\sigma_p}", "description": "Sharpe Ratio" },
          { "latex": "R_p = \\text{Portfolio return}", "description": "Expected portfolio return" },
          { "latex": "R_f = \\text{Risk-free rate}", "description": "Treasury bonds, etc." },
          {
            "latex": "\\sigma_p = \\text{Portfolio std deviation}",
            "description": "Volatility (risk)"
          }
        ],
        "examples": [
          {
            "problem": "Return 12%, risk-free 2%, std dev 15%. Sharpe ratio?",
            "solution": "SR = (12% - 2%) / 15% = 0.67"
          },
          {
            "problem": "Is Sharpe ratio > 1 good?",
            "solution": "Generally considered a good investment"
          }
        ],
        "history": {
          "discoveredBy": "William Sharpe",
          "year": "1966",
          "background": "Won 1990 Nobel Prize for CAPM development"
        },
        "applications": [
          { "field": "Fund Evaluation", "description": "Comparing fund performance" },
          { "field": "Portfolio", "description": "Asset allocation optimization" },
          { "field": "Risk Management", "description": "Risk-adjusted return" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["expected-value", "standard-deviation"],
      "nextTopics": ["sortino-ratio", "capm"],
      "related": ["treynor-ratio", "information-ratio"]
    },
    "tags": ["샤프", "위험조정수익", "Sharpe", "portfolio"]
  },
  {
    "id": "frequency-ratio",
    "name": { "ko": "주파수 비율", "en": "Frequency Ratio" },
    "field": "applied-music",
    "subfield": "acoustics",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "음정은 두 음의 주파수 비율로 정의됩니다. 같은 비율은 같은 음정을 나타내며, 이것이 화성학의 수학적 기초입니다.",
        "formulas": [
          { "latex": "\\text{옥타브} = 2:1", "description": "주파수가 2배면 한 옥타브 위" },
          { "latex": "\\text{완전5도} = 3:2", "description": "가장 협화적인 음정" },
          { "latex": "\\text{완전4도} = 4:3", "description": "옥타브의 보완" },
          { "latex": "\\text{장3도} = 5:4", "description": "순정률에서의 장3도" }
        ],
        "examples": [
          {
            "problem": "A4 = 440Hz일 때, A5의 주파수는?",
            "solution": "A5 = 440 × 2 = 880Hz (한 옥타브 위)"
          },
          { "problem": "A4에서 완전5도 위의 E5 주파수는?", "solution": "E5 = 440 × (3/2) = 660Hz" }
        ],
        "history": {
          "discoveredBy": "피타고라스",
          "year": "기원전 6세기",
          "background": "현의 길이와 음정의 관계를 발견하여 음악과 수학의 연결을 최초로 규명"
        },
        "applications": [
          { "field": "악기 제작", "description": "현 길이, 관 길이 설계" },
          { "field": "화성학", "description": "협화음/불협화음 이해" },
          { "field": "음향공학", "description": "사운드 디자인" }
        ]
      },
      "en": {
        "definition": "Musical intervals are defined by frequency ratios. Same ratio = same interval. This is the mathematical foundation of harmony.",
        "formulas": [
          { "latex": "\\text{Octave} = 2:1", "description": "Double frequency = one octave up" },
          { "latex": "\\text{Perfect 5th} = 3:2", "description": "Most consonant interval" },
          { "latex": "\\text{Perfect 4th} = 4:3", "description": "Complement of octave" },
          { "latex": "\\text{Major 3rd} = 5:4", "description": "Just intonation major third" }
        ],
        "examples": [
          {
            "problem": "If A4 = 440Hz, what is A5?",
            "solution": "A5 = 440 × 2 = 880Hz (one octave up)"
          },
          {
            "problem": "What is E5 (perfect 5th above A4)?",
            "solution": "E5 = 440 × (3/2) = 660Hz"
          }
        ],
        "history": {
          "discoveredBy": "Pythagoras",
          "year": "6th century BCE",
          "background": "Discovered relationship between string length and pitch, first linking music and math"
        },
        "applications": [
          { "field": "Instrument Making", "description": "String/tube length design" },
          { "field": "Harmony", "description": "Consonance/dissonance understanding" },
          { "field": "Sound Engineering", "description": "Sound design" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["ratio", "fraction"],
      "nextTopics": ["equal-temperament", "just-intonation"],
      "related": ["harmonic-series-music"]
    },
    "tags": ["주파수", "음정", "frequency", "interval"]
  },
  {
    "id": "equal-temperament",
    "name": { "ko": "12평균율", "en": "12-Tone Equal Temperament" },
    "field": "applied-music",
    "subfield": "tuning",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "12평균율은 옥타브를 12개의 동일한 반음으로 나누는 조율 체계입니다. 모든 조에서 같은 음정을 제공합니다.",
        "formulas": [
          {
            "latex": "r = \\sqrt[12]{2} = 2^{1/12} \\approx 1.05946",
            "description": "반음의 주파수 비율"
          },
          { "latex": "f_n = f_0 \\times 2^{n/12}", "description": "n 반음 위의 주파수" },
          {
            "latex": "\\text{온음} = 2^{2/12} = 2^{1/6} \\approx 1.1225",
            "description": "온음 = 2반음"
          }
        ],
        "examples": [
          {
            "problem": "A4 = 440Hz에서 C5 (3반음 위)의 주파수는?",
            "solution": "C5 = 440 × 2^(3/12) = 440 × 1.1892 ≈ 523.25Hz"
          },
          {
            "problem": "평균율 완전5도와 순정률 완전5도의 차이는?",
            "solution": "평균율: 2^(7/12) ≈ 1.4983, 순정률: 3/2 = 1.5. 차이 ≈ 2센트"
          }
        ],
        "history": {
          "discoveredBy": "주재육 (중국), 시몬 스테빈 (유럽)",
          "year": "1584년 (중국), 1605년 (유럽)",
          "background": "바흐의 평균율 클라비어곡집으로 널리 보급됨"
        },
        "applications": [
          { "field": "피아노 조율", "description": "표준 조율 체계" },
          { "field": "전자음악", "description": "MIDI 표준" },
          { "field": "조옮김", "description": "모든 조에서 동일한 연주 가능" }
        ]
      },
      "en": {
        "definition": "12-TET divides the octave into 12 equal semitones. Provides consistent intervals in all keys.",
        "formulas": [
          {
            "latex": "r = \\sqrt[12]{2} = 2^{1/12} \\approx 1.05946",
            "description": "Semitone frequency ratio"
          },
          { "latex": "f_n = f_0 \\times 2^{n/12}", "description": "Frequency n semitones up" },
          {
            "latex": "\\text{Whole tone} = 2^{2/12} = 2^{1/6} \\approx 1.1225",
            "description": "Whole tone = 2 semitones"
          }
        ],
        "examples": [
          {
            "problem": "A4 = 440Hz. What is C5 (3 semitones up)?",
            "solution": "C5 = 440 × 2^(3/12) = 440 × 1.1892 ≈ 523.25Hz"
          },
          {
            "problem": "Difference between equal and just perfect 5th?",
            "solution": "Equal: 2^(7/12) ≈ 1.4983, Just: 3/2 = 1.5. Diff ≈ 2 cents"
          }
        ],
        "history": {
          "discoveredBy": "Zhu Zaiyu (China), Simon Stevin (Europe)",
          "year": "1584 (China), 1605 (Europe)",
          "background": "Popularized by Bach's Well-Tempered Clavier"
        },
        "applications": [
          { "field": "Piano Tuning", "description": "Standard tuning system" },
          { "field": "Electronic Music", "description": "MIDI standard" },
          { "field": "Transposition", "description": "Play in any key equally" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["frequency-ratio", "exponents", "logarithm"],
      "nextTopics": ["microtonal", "pythagorean-tuning"],
      "related": ["sqrt2-constant"]
    },
    "tags": ["평균율", "조율", "temperament", "tuning"]
  },
  {
    "id": "time-signature",
    "name": { "ko": "박자", "en": "Time Signature" },
    "field": "applied-music",
    "subfield": "rhythm",
    "difficulty": 1,
    "content": {
      "ko": {
        "definition": "박자는 음악에서 시간을 분할하는 방식입니다. 분수 형태로 표기하며, 위는 박 수, 아래는 기준 음표를 나타냅니다.",
        "formulas": [
          { "latex": "\\frac{\\text{박 수}}{\\text{기준 음표}}", "description": "박자표 형식" },
          {
            "latex": "\\frac{4}{4} = \\text{4분음표가 한 마디에 4개}",
            "description": "4/4 박자 (보통박자)"
          },
          {
            "latex": "\\frac{3}{4} = \\text{4분음표가 한 마디에 3개}",
            "description": "3/4 박자 (왈츠)"
          },
          {
            "latex": "\\frac{6}{8} = \\text{8분음표가 한 마디에 6개}",
            "description": "6/8 박자 (겹박자)"
          }
        ],
        "examples": [
          {
            "problem": "4/4 박자에서 한 마디의 총 박 길이는?",
            "solution": "4분음표 4개 = 온음표 1개 길이"
          },
          {
            "problem": "6/8과 3/4의 차이는?",
            "solution": "6/8은 2박 계열 (점4분음표 2개), 3/4은 3박 계열"
          }
        ],
        "applications": [
          { "field": "작곡", "description": "리듬 구조 설계" },
          { "field": "연주", "description": "박자 맞춰 연주" },
          { "field": "댄스", "description": "춤 스텝과 음악 동기화" }
        ]
      },
      "en": {
        "definition": "Time signature divides time in music. Written as fraction: top = beats per measure, bottom = note value per beat.",
        "formulas": [
          {
            "latex": "\\frac{\\text{beats}}{\\text{note value}}",
            "description": "Time signature format"
          },
          {
            "latex": "\\frac{4}{4} = \\text{4 quarter notes per measure}",
            "description": "4/4 (common time)"
          },
          {
            "latex": "\\frac{3}{4} = \\text{3 quarter notes per measure}",
            "description": "3/4 (waltz)"
          },
          {
            "latex": "\\frac{6}{8} = \\text{6 eighth notes per measure}",
            "description": "6/8 (compound duple)"
          }
        ],
        "examples": [
          {
            "problem": "Total beat length of one measure in 4/4?",
            "solution": "4 quarter notes = 1 whole note"
          },
          {
            "problem": "Difference between 6/8 and 3/4?",
            "solution": "6/8 is duple (2 dotted quarters), 3/4 is triple"
          }
        ],
        "applications": [
          { "field": "Composition", "description": "Rhythmic structure design" },
          { "field": "Performance", "description": "Playing in time" },
          { "field": "Dance", "description": "Synchronizing steps to music" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["fraction"],
      "nextTopics": ["polyrhythm", "odd-meters"],
      "related": ["division"]
    },
    "tags": ["박자", "리듬", "time signature", "rhythm"]
  },
  {
    "id": "harmonic-series-music",
    "name": { "ko": "배음렬", "en": "Harmonic Series (Music)" },
    "field": "applied-music",
    "subfield": "acoustics",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "배음렬은 기본음 위에 자연스럽게 발생하는 배음들의 주파수 패턴입니다. 악기의 음색을 결정하고 화성의 기초가 됩니다.",
        "formulas": [
          { "latex": "f_n = n \\times f_1", "description": "n번째 배음 주파수" },
          { "latex": "\\text{배음}: f, 2f, 3f, 4f, 5f, 6f, ...", "description": "배음렬 패턴" },
          {
            "latex": "\\text{음정}: \\text{기본음}, \\text{옥타브}, \\text{5도}, \\text{옥타브}, \\text{장3도}, \\text{5도}, ...",
            "description": "배음에 해당하는 음정"
          }
        ],
        "examples": [
          {
            "problem": "C2(65.4Hz)의 처음 6개 배음은?",
            "solution": "65.4, 130.8(C3), 196.2(G3), 261.6(C4), 327(E4), 392.4(G4)"
          },
          {
            "problem": "왜 장3화음이 협화적인가?",
            "solution": "장3화음(1, 3, 5도)은 배음렬의 4:5:6 비율과 일치하여 자연스러움"
          }
        ],
        "history": {
          "discoveredBy": "피타고라스, 조제프 소보르",
          "year": "기원전 6세기 ~ 1701년",
          "background": "자연에서 발생하는 음향 현상의 수학적 분석"
        },
        "applications": [
          { "field": "악기 설계", "description": "음색 조절" },
          { "field": "보컬 기법", "description": "오버톤 싱잉" },
          { "field": "오케스트레이션", "description": "악기 조합" }
        ]
      },
      "en": {
        "definition": "Harmonic series is the pattern of overtones naturally occurring above a fundamental. Determines timbre and underlies harmony.",
        "formulas": [
          { "latex": "f_n = n \\times f_1", "description": "nth harmonic frequency" },
          {
            "latex": "\\text{Harmonics}: f, 2f, 3f, 4f, 5f, 6f, ...",
            "description": "Harmonic series pattern"
          },
          {
            "latex": "\\text{Intervals}: \\text{root}, \\text{octave}, \\text{5th}, \\text{octave}, \\text{M3}, \\text{5th}, ...",
            "description": "Intervals corresponding to harmonics"
          }
        ],
        "examples": [
          {
            "problem": "First 6 harmonics of C2 (65.4Hz)?",
            "solution": "65.4, 130.8(C3), 196.2(G3), 261.6(C4), 327(E4), 392.4(G4)"
          },
          {
            "problem": "Why is major triad consonant?",
            "solution": "Major triad (1, 3, 5) matches harmonic series ratio 4:5:6"
          }
        ],
        "history": {
          "discoveredBy": "Pythagoras, Joseph Sauveur",
          "year": "6th century BCE - 1701",
          "background": "Mathematical analysis of natural acoustic phenomena"
        },
        "applications": [
          { "field": "Instrument Design", "description": "Timbre control" },
          { "field": "Vocal Technique", "description": "Overtone singing" },
          { "field": "Orchestration", "description": "Instrument combination" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["frequency-ratio", "multiplication"],
      "nextTopics": ["spectral-analysis", "fourier-series"],
      "related": ["standing-waves"]
    },
    "tags": ["배음", "음색", "harmonics", "overtone"]
  },
  {
    "id": "chord-theory",
    "name": { "ko": "화음 이론", "en": "Chord Theory" },
    "field": "applied-music",
    "subfield": "harmony",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "화음은 동시에 울리는 3개 이상의 음입니다. 음정 관계의 수학적 구조가 화음의 성격을 결정합니다.",
        "formulas": [
          {
            "latex": "\\text{장3화음} = \\text{근음} + \\text{장3도} + \\text{완전5도}",
            "description": "장3화음 구조 (반음: 0-4-7)"
          },
          {
            "latex": "\\text{단3화음} = \\text{근음} + \\text{단3도} + \\text{완전5도}",
            "description": "단3화음 구조 (반음: 0-3-7)"
          },
          {
            "latex": "\\text{감3화음} = \\text{근음} + \\text{단3도} + \\text{감5도}",
            "description": "감3화음 구조 (반음: 0-3-6)"
          },
          {
            "latex": "\\text{증3화음} = \\text{근음} + \\text{장3도} + \\text{증5도}",
            "description": "증3화음 구조 (반음: 0-4-8)"
          }
        ],
        "examples": [
          { "problem": "C장3화음의 구성음은?", "solution": "C(0) + E(4반음) + G(7반음) = C-E-G" },
          { "problem": "A단3화음의 구성음은?", "solution": "A(0) + C(3반음) + E(7반음) = A-C-E" }
        ],
        "applications": [
          { "field": "작곡", "description": "화성 진행 설계" },
          { "field": "편곡", "description": "보이싱과 화음 확장" },
          { "field": "즉흥연주", "description": "코드 톤 활용" }
        ]
      },
      "en": {
        "definition": "A chord is 3+ notes sounding together. Mathematical structure of intervals determines chord character.",
        "formulas": [
          {
            "latex": "\\text{Major triad} = \\text{root} + \\text{M3} + \\text{P5}",
            "description": "Major triad structure (semitones: 0-4-7)"
          },
          {
            "latex": "\\text{Minor triad} = \\text{root} + \\text{m3} + \\text{P5}",
            "description": "Minor triad structure (semitones: 0-3-7)"
          },
          {
            "latex": "\\text{Diminished} = \\text{root} + \\text{m3} + \\text{d5}",
            "description": "Diminished triad (semitones: 0-3-6)"
          },
          {
            "latex": "\\text{Augmented} = \\text{root} + \\text{M3} + \\text{A5}",
            "description": "Augmented triad (semitones: 0-4-8)"
          }
        ],
        "examples": [
          {
            "problem": "Notes in C major triad?",
            "solution": "C(0) + E(4 semitones) + G(7 semitones) = C-E-G"
          },
          {
            "problem": "Notes in A minor triad?",
            "solution": "A(0) + C(3 semitones) + E(7 semitones) = A-C-E"
          }
        ],
        "applications": [
          { "field": "Composition", "description": "Harmonic progression design" },
          { "field": "Arrangement", "description": "Voicing and chord extensions" },
          { "field": "Improvisation", "description": "Using chord tones" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["frequency-ratio", "equal-temperament"],
      "nextTopics": ["seventh-chords", "chord-progressions"],
      "related": ["harmonic-series-music"]
    },
    "tags": ["화음", "화성", "chord", "harmony"]
  },
  {
    "id": "decibel-scale",
    "name": { "ko": "데시벨 스케일", "en": "Decibel Scale" },
    "field": "applied-music",
    "subfield": "acoustics",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "데시벨(dB)은 소리 크기의 로그 스케일입니다. 인간의 청각이 로그적으로 인식하기 때문에 사용됩니다.",
        "formulas": [
          {
            "latex": "L = 10 \\log_{10}\\left(\\frac{I}{I_0}\\right) \\text{ dB}",
            "description": "음압 레벨 (강도 기준)"
          },
          {
            "latex": "L = 20 \\log_{10}\\left(\\frac{P}{P_0}\\right) \\text{ dB}",
            "description": "음압 레벨 (압력 기준)"
          },
          { "latex": "I_0 = 10^{-12} \\text{ W/m}^2", "description": "기준 강도 (청력 역치)" },
          {
            "latex": "+3\\text{dB} \\approx \\times 2 \\text{ (강도)}",
            "description": "3dB 증가 = 강도 2배"
          }
        ],
        "examples": [
          {
            "problem": "속삭임(30dB)과 대화(60dB)의 강도 차이는?",
            "solution": "30dB 차이 = 10^(30/10) = 1000배 강도 차이"
          },
          { "problem": "2개의 같은 소리가 합쳐지면?", "solution": "강도 2배 → +3dB 증가" }
        ],
        "applications": [
          { "field": "음향 측정", "description": "소음 레벨 측정" },
          { "field": "오디오 엔지니어링", "description": "믹싱, 마스터링" },
          { "field": "청력 보호", "description": "안전 기준 설정" }
        ]
      },
      "en": {
        "definition": "Decibel (dB) is a logarithmic scale for sound intensity. Used because human hearing perceives logarithmically.",
        "formulas": [
          {
            "latex": "L = 10 \\log_{10}\\left(\\frac{I}{I_0}\\right) \\text{ dB}",
            "description": "Sound level (intensity basis)"
          },
          {
            "latex": "L = 20 \\log_{10}\\left(\\frac{P}{P_0}\\right) \\text{ dB}",
            "description": "Sound level (pressure basis)"
          },
          {
            "latex": "I_0 = 10^{-12} \\text{ W/m}^2",
            "description": "Reference intensity (hearing threshold)"
          },
          {
            "latex": "+3\\text{dB} \\approx \\times 2 \\text{ (intensity)}",
            "description": "+3dB = double intensity"
          }
        ],
        "examples": [
          {
            "problem": "Intensity difference: whisper (30dB) vs conversation (60dB)?",
            "solution": "30dB difference = 10^(30/10) = 1000× intensity difference"
          },
          {
            "problem": "Two identical sounds combined?",
            "solution": "2× intensity → +3dB increase"
          }
        ],
        "applications": [
          { "field": "Acoustics", "description": "Noise level measurement" },
          { "field": "Audio Engineering", "description": "Mixing, mastering" },
          { "field": "Hearing Protection", "description": "Safety standards" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["logarithm"],
      "nextTopics": ["sound-intensity", "audio-compression"],
      "related": ["weber-fechner-law"]
    },
    "tags": ["데시벨", "음량", "decibel", "acoustics"]
  },
  {
    "id": "kinematics",
    "name": { "ko": "운동학", "en": "Kinematics" },
    "field": "applied-physics",
    "subfield": "mechanics",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "운동학은 힘을 고려하지 않고 물체의 운동(위치, 속도, 가속도)을 기술하는 역학의 분야입니다.",
        "formulas": [
          { "latex": "v = v_0 + at", "description": "속도-시간 관계" },
          { "latex": "x = x_0 + v_0 t + \\frac{1}{2}at^2", "description": "위치-시간 관계" },
          { "latex": "v^2 = v_0^2 + 2a(x - x_0)", "description": "속도-위치 관계" },
          {
            "latex": "v = \\frac{dx}{dt}, \\quad a = \\frac{dv}{dt} = \\frac{d^2x}{dt^2}",
            "description": "미분 형태"
          }
        ],
        "examples": [
          {
            "problem": "10m/s로 던진 공이 중력(-10m/s²)으로 몇 초 후 최고점?",
            "solution": "v = v₀ + at → 0 = 10 - 10t → t = 1초"
          },
          {
            "problem": "정지 상태에서 5m/s²로 가속하여 3초 후 이동 거리는?",
            "solution": "x = ½at² = ½(5)(9) = 22.5m"
          }
        ],
        "applications": [
          { "field": "교통", "description": "차량 제동 거리 계산" },
          { "field": "스포츠", "description": "공의 궤적 예측" },
          { "field": "애니메이션", "description": "물리 기반 움직임" }
        ]
      },
      "en": {
        "definition": "Kinematics describes motion (position, velocity, acceleration) without considering forces.",
        "formulas": [
          { "latex": "v = v_0 + at", "description": "Velocity-time relation" },
          {
            "latex": "x = x_0 + v_0 t + \\frac{1}{2}at^2",
            "description": "Position-time relation"
          },
          { "latex": "v^2 = v_0^2 + 2a(x - x_0)", "description": "Velocity-position relation" },
          {
            "latex": "v = \\frac{dx}{dt}, \\quad a = \\frac{dv}{dt} = \\frac{d^2x}{dt^2}",
            "description": "Differential forms"
          }
        ],
        "examples": [
          {
            "problem": "Ball thrown up at 10m/s, gravity -10m/s². Time to peak?",
            "solution": "v = v₀ + at → 0 = 10 - 10t → t = 1s"
          },
          {
            "problem": "From rest, accelerate at 5m/s² for 3s. Distance?",
            "solution": "x = ½at² = ½(5)(9) = 22.5m"
          }
        ],
        "applications": [
          { "field": "Traffic", "description": "Braking distance calculation" },
          { "field": "Sports", "description": "Ball trajectory prediction" },
          { "field": "Animation", "description": "Physics-based movement" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["derivative", "integral"],
      "nextTopics": ["dynamics", "projectile-motion"],
      "related": ["differential-equations"]
    },
    "tags": ["운동학", "역학", "kinematics", "motion"]
  },
  {
    "id": "wave-equation",
    "name": { "ko": "파동 방정식", "en": "Wave Equation" },
    "field": "applied-physics",
    "subfield": "waves",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "파동 방정식은 파동의 전파를 기술하는 편미분방정식입니다. 소리, 빛, 물결 등 다양한 파동에 적용됩니다.",
        "formulas": [
          {
            "latex": "\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u",
            "description": "일반 파동 방정식"
          },
          {
            "latex": "\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}",
            "description": "1차원 파동 방정식"
          },
          { "latex": "u(x,t) = f(x - ct) + g(x + ct)", "description": "일반해 (달랑베르)" },
          { "latex": "u(x,t) = A\\sin(kx - \\omega t)", "description": "정현파 해" }
        ],
        "examples": [
          {
            "problem": "파속 340m/s인 소리의 파동 방정식은?",
            "solution": "∂²u/∂t² = 340² ∂²u/∂x² = 115,600 ∂²u/∂x²"
          },
          {
            "problem": "파장 λ=2m, 주기 T=0.5s인 파동의 속도는?",
            "solution": "c = λ/T = 2/0.5 = 4m/s"
          }
        ],
        "history": {
          "discoveredBy": "장 르 롱 달랑베르",
          "year": "1746년",
          "background": "현의 진동 문제를 연구하면서 유도됨"
        },
        "applications": [
          { "field": "음향학", "description": "소리 전파 모델링" },
          { "field": "지진학", "description": "지진파 분석" },
          { "field": "전자기학", "description": "전자기파" }
        ]
      },
      "en": {
        "definition": "Wave equation is a PDE describing wave propagation. Applies to sound, light, water waves, etc.",
        "formulas": [
          {
            "latex": "\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u",
            "description": "General wave equation"
          },
          {
            "latex": "\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}",
            "description": "1D wave equation"
          },
          {
            "latex": "u(x,t) = f(x - ct) + g(x + ct)",
            "description": "General solution (d'Alembert)"
          },
          { "latex": "u(x,t) = A\\sin(kx - \\omega t)", "description": "Sinusoidal solution" }
        ],
        "examples": [
          {
            "problem": "Wave equation for sound at 340m/s?",
            "solution": "∂²u/∂t² = 340² ∂²u/∂x² = 115,600 ∂²u/∂x²"
          },
          { "problem": "Wave with λ=2m, T=0.5s. Speed?", "solution": "c = λ/T = 2/0.5 = 4m/s" }
        ],
        "history": {
          "discoveredBy": "Jean le Rond d'Alembert",
          "year": "1746",
          "background": "Derived while studying vibrating strings"
        },
        "applications": [
          { "field": "Acoustics", "description": "Sound propagation modeling" },
          { "field": "Seismology", "description": "Seismic wave analysis" },
          { "field": "Electromagnetism", "description": "EM waves" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["partial-derivative", "differential-equations"],
      "nextTopics": ["schrodinger-equation", "maxwell-equations"],
      "related": ["fourier-series"]
    },
    "tags": ["파동", "편미분방정식", "wave equation", "PDE"]
  },
  {
    "id": "maxwell-equations",
    "name": { "ko": "맥스웰 방정식", "en": "Maxwell's Equations" },
    "field": "applied-physics",
    "subfield": "electromagnetism",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "맥스웰 방정식은 전기장과 자기장의 관계를 기술하는 4개의 방정식입니다. 전자기학의 근본 법칙입니다.",
        "formulas": [
          {
            "latex": "\\nabla \\cdot \\vec{E} = \\frac{\\rho}{\\varepsilon_0}",
            "description": "가우스 법칙 (전기)"
          },
          {
            "latex": "\\nabla \\cdot \\vec{B} = 0",
            "description": "가우스 법칙 (자기) - 자기 홀극 없음"
          },
          {
            "latex": "\\nabla \\times \\vec{E} = -\\frac{\\partial \\vec{B}}{\\partial t}",
            "description": "패러데이 법칙 - 전자기 유도"
          },
          {
            "latex": "\\nabla \\times \\vec{B} = \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0 \\frac{\\partial \\vec{E}}{\\partial t}",
            "description": "앙페르-맥스웰 법칙"
          }
        ],
        "examples": [
          {
            "problem": "맥스웰 방정식에서 전자기파의 속도를 유도하세요.",
            "solution": "c = 1/√(μ₀ε₀) ≈ 3×10⁸ m/s (빛의 속도!)"
          }
        ],
        "history": {
          "discoveredBy": "제임스 클러크 맥스웰",
          "year": "1865년",
          "background": "여러 실험 법칙을 통합하고 변위전류를 추가하여 빛이 전자기파임을 예측"
        },
        "applications": [
          { "field": "통신", "description": "전파, 안테나 설계" },
          { "field": "광학", "description": "빛의 전파" },
          { "field": "전기공학", "description": "회로, 모터 설계" }
        ]
      },
      "en": {
        "definition": "Maxwell's equations are 4 equations describing electric and magnetic fields. Fundamental laws of electromagnetism.",
        "formulas": [
          {
            "latex": "\\nabla \\cdot \\vec{E} = \\frac{\\rho}{\\varepsilon_0}",
            "description": "Gauss's law (electric)"
          },
          {
            "latex": "\\nabla \\cdot \\vec{B} = 0",
            "description": "Gauss's law (magnetic) - no monopoles"
          },
          {
            "latex": "\\nabla \\times \\vec{E} = -\\frac{\\partial \\vec{B}}{\\partial t}",
            "description": "Faraday's law - induction"
          },
          {
            "latex": "\\nabla \\times \\vec{B} = \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0 \\frac{\\partial \\vec{E}}{\\partial t}",
            "description": "Ampère-Maxwell law"
          }
        ],
        "examples": [
          {
            "problem": "Derive speed of EM waves from Maxwell's equations.",
            "solution": "c = 1/√(μ₀ε₀) ≈ 3×10⁸ m/s (speed of light!)"
          }
        ],
        "history": {
          "discoveredBy": "James Clerk Maxwell",
          "year": "1865",
          "background": "Unified experimental laws, added displacement current, predicted light is EM wave"
        },
        "applications": [
          { "field": "Communications", "description": "Radio waves, antenna design" },
          { "field": "Optics", "description": "Light propagation" },
          { "field": "Electrical Engineering", "description": "Circuits, motor design" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["nabla-operator", "vector-calculus", "partial-derivative"],
      "nextTopics": ["electromagnetic-waves", "special-relativity"],
      "related": ["wave-equation", "stokes-theorem"]
    },
    "tags": ["맥스웰", "전자기학", "Maxwell", "electromagnetism"]
  },
  {
    "id": "schrodinger-equation",
    "name": { "ko": "슈뢰딩거 방정식", "en": "Schrödinger Equation" },
    "field": "applied-physics",
    "subfield": "quantum",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "슈뢰딩거 방정식은 양자역학에서 파동함수의 시간 변화를 기술합니다. 입자의 양자 상태를 예측합니다.",
        "formulas": [
          {
            "latex": "i\\hbar \\frac{\\partial \\Psi}{\\partial t} = \\hat{H}\\Psi",
            "description": "시간 의존 슈뢰딩거 방정식"
          },
          { "latex": "\\hat{H}\\psi = E\\psi", "description": "시간 독립 슈뢰딩거 방정식" },
          {
            "latex": "\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2 + V",
            "description": "해밀토니안 연산자"
          },
          { "latex": "|\\Psi(x,t)|^2 = \\text{확률 밀도}", "description": "파동함수의 해석" }
        ],
        "examples": [
          {
            "problem": "무한 우물(길이 L)에서 에너지 준위는?",
            "solution": "Eₙ = n²π²ℏ²/(2mL²), n = 1, 2, 3, ..."
          }
        ],
        "history": {
          "discoveredBy": "에르빈 슈뢰딩거",
          "year": "1926년",
          "background": "드브로이의 물질파 개념을 수학적으로 정립하여 1933년 노벨물리학상 수상"
        },
        "applications": [
          { "field": "화학", "description": "분자 구조, 화학 결합" },
          { "field": "반도체", "description": "전자 밴드 구조" },
          { "field": "나노기술", "description": "양자 점, 터널링" }
        ]
      },
      "en": {
        "definition": "Schrödinger equation describes time evolution of wave function in quantum mechanics. Predicts quantum states.",
        "formulas": [
          {
            "latex": "i\\hbar \\frac{\\partial \\Psi}{\\partial t} = \\hat{H}\\Psi",
            "description": "Time-dependent Schrödinger equation"
          },
          {
            "latex": "\\hat{H}\\psi = E\\psi",
            "description": "Time-independent Schrödinger equation"
          },
          {
            "latex": "\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2 + V",
            "description": "Hamiltonian operator"
          },
          {
            "latex": "|\\Psi(x,t)|^2 = \\text{probability density}",
            "description": "Wave function interpretation"
          }
        ],
        "examples": [
          {
            "problem": "Energy levels in infinite well (length L)?",
            "solution": "Eₙ = n²π²ℏ²/(2mL²), n = 1, 2, 3, ..."
          }
        ],
        "history": {
          "discoveredBy": "Erwin Schrödinger",
          "year": "1926",
          "background": "Mathematically formulated de Broglie's matter wave concept; 1933 Nobel Prize"
        },
        "applications": [
          { "field": "Chemistry", "description": "Molecular structure, bonds" },
          { "field": "Semiconductors", "description": "Electron band structure" },
          { "field": "Nanotechnology", "description": "Quantum dots, tunneling" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["complex-numbers", "partial-differential-equation", "linear-algebra"],
      "nextTopics": ["quantum-harmonic-oscillator", "hydrogen-atom"],
      "related": ["wave-equation", "heisenberg-uncertainty"]
    },
    "tags": ["슈뢰딩거", "양자역학", "Schrödinger", "quantum"]
  },
  {
    "id": "special-relativity-math",
    "name": { "ko": "특수상대성이론 수학", "en": "Special Relativity Mathematics" },
    "field": "applied-physics",
    "subfield": "relativity",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "특수상대성이론은 빛의 속도가 일정하다는 원리에서 시간과 공간의 관계를 수학적으로 기술합니다.",
        "formulas": [
          { "latex": "\\gamma = \\frac{1}{\\sqrt{1 - v^2/c^2}}", "description": "로렌츠 인자" },
          {
            "latex": "t' = \\gamma\\left(t - \\frac{vx}{c^2}\\right)",
            "description": "로렌츠 변환 (시간)"
          },
          { "latex": "x' = \\gamma(x - vt)", "description": "로렌츠 변환 (공간)" },
          { "latex": "E = mc^2", "description": "질량-에너지 등가" },
          { "latex": "E^2 = (pc)^2 + (mc^2)^2", "description": "에너지-운동량 관계" }
        ],
        "examples": [
          {
            "problem": "v = 0.6c일 때 로렌츠 인자 γ는?",
            "solution": "γ = 1/√(1-0.36) = 1/√0.64 = 1/0.8 = 1.25"
          },
          {
            "problem": "1kg의 질량이 완전히 에너지로 변환되면?",
            "solution": "E = mc² = 1 × (3×10⁸)² = 9×10¹⁶ J"
          }
        ],
        "history": {
          "discoveredBy": "알베르트 아인슈타인",
          "year": "1905년",
          "background": "기적의 해에 발표된 4편의 논문 중 하나로 물리학을 혁명적으로 바꿈"
        },
        "applications": [
          { "field": "GPS", "description": "위성 시계 보정" },
          { "field": "입자 가속기", "description": "고에너지 입자 물리" },
          { "field": "핵 에너지", "description": "E=mc² 응용" }
        ]
      },
      "en": {
        "definition": "Special relativity mathematically describes space-time from the principle that light speed is constant.",
        "formulas": [
          { "latex": "\\gamma = \\frac{1}{\\sqrt{1 - v^2/c^2}}", "description": "Lorentz factor" },
          {
            "latex": "t' = \\gamma\\left(t - \\frac{vx}{c^2}\\right)",
            "description": "Lorentz transformation (time)"
          },
          { "latex": "x' = \\gamma(x - vt)", "description": "Lorentz transformation (space)" },
          { "latex": "E = mc^2", "description": "Mass-energy equivalence" },
          { "latex": "E^2 = (pc)^2 + (mc^2)^2", "description": "Energy-momentum relation" }
        ],
        "examples": [
          {
            "problem": "Lorentz factor γ at v = 0.6c?",
            "solution": "γ = 1/√(1-0.36) = 1/√0.64 = 1/0.8 = 1.25"
          },
          {
            "problem": "1kg mass fully converted to energy?",
            "solution": "E = mc² = 1 × (3×10⁸)² = 9×10¹⁶ J"
          }
        ],
        "history": {
          "discoveredBy": "Albert Einstein",
          "year": "1905",
          "background": "One of four papers in his miracle year that revolutionized physics"
        },
        "applications": [
          { "field": "GPS", "description": "Satellite clock correction" },
          { "field": "Particle Accelerators", "description": "High-energy physics" },
          { "field": "Nuclear Energy", "description": "E=mc² applications" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["kinematics", "lorentz-transformation"],
      "nextTopics": ["general-relativity", "four-vectors"],
      "related": ["maxwell-equations"]
    },
    "tags": ["상대성", "로렌츠", "relativity", "Einstein"]
  },
  {
    "id": "newtons-laws",
    "name": { "ko": "뉴턴의 운동 법칙", "en": "Newton's Laws of Motion" },
    "field": "applied-physics",
    "subfield": "mechanics",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "뉴턴의 세 가지 운동 법칙은 힘과 운동의 관계를 정의합니다. 고전역학의 근본 원리입니다.",
        "formulas": [
          {
            "latex": "\\vec{F} = 0 \\Rightarrow \\vec{v} = \\text{const}",
            "description": "제1법칙: 관성의 법칙"
          },
          {
            "latex": "\\vec{F} = m\\vec{a} = m\\frac{d\\vec{v}}{dt}",
            "description": "제2법칙: 가속도의 법칙"
          },
          { "latex": "\\vec{F}_{12} = -\\vec{F}_{21}", "description": "제3법칙: 작용-반작용" }
        ],
        "examples": [
          {
            "problem": "5kg 물체에 10N 힘을 가하면 가속도는?",
            "solution": "a = F/m = 10/5 = 2 m/s²"
          },
          {
            "problem": "지구가 사과를 당기는 힘과 사과가 지구를 당기는 힘은?",
            "solution": "제3법칙에 의해 크기가 같고 방향이 반대 (F = mg)"
          }
        ],
        "history": {
          "discoveredBy": "아이작 뉴턴",
          "year": "1687년",
          "background": "프린키피아에서 발표하여 과학 혁명을 완성"
        },
        "applications": [
          { "field": "기계공학", "description": "구조 분석, 동역학" },
          { "field": "항공우주", "description": "궤도 역학" },
          { "field": "로봇공학", "description": "로봇 움직임 제어" }
        ]
      },
      "en": {
        "definition": "Newton's three laws define the relationship between force and motion. Foundation of classical mechanics.",
        "formulas": [
          {
            "latex": "\\vec{F} = 0 \\Rightarrow \\vec{v} = \\text{const}",
            "description": "1st law: Law of inertia"
          },
          {
            "latex": "\\vec{F} = m\\vec{a} = m\\frac{d\\vec{v}}{dt}",
            "description": "2nd law: F = ma"
          },
          { "latex": "\\vec{F}_{12} = -\\vec{F}_{21}", "description": "3rd law: Action-reaction" }
        ],
        "examples": [
          {
            "problem": "10N force on 5kg mass. Acceleration?",
            "solution": "a = F/m = 10/5 = 2 m/s²"
          },
          {
            "problem": "Force of Earth on apple vs apple on Earth?",
            "solution": "By 3rd law, equal magnitude, opposite direction (F = mg)"
          }
        ],
        "history": {
          "discoveredBy": "Isaac Newton",
          "year": "1687",
          "background": "Published in Principia, completing the Scientific Revolution"
        },
        "applications": [
          { "field": "Mechanical Engineering", "description": "Structural analysis" },
          { "field": "Aerospace", "description": "Orbital mechanics" },
          { "field": "Robotics", "description": "Robot motion control" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["kinematics", "derivative"],
      "nextTopics": ["work-energy", "momentum"],
      "related": ["differential-equations"]
    },
    "tags": ["뉴턴", "역학", "Newton", "mechanics"]
  },
  {
    "id": "big-o-notation",
    "name": { "ko": "Big-O 표기법", "en": "Big-O Notation" },
    "field": "applied-cs",
    "subfield": "complexity",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "Big-O 표기법은 알고리즘의 시간/공간 복잡도를 입력 크기에 따른 증가율로 표현합니다. 최악의 경우를 나타냅니다.",
        "formulas": [
          {
            "latex": "O(1) < O(\\log n) < O(n) < O(n\\log n) < O(n^2) < O(2^n) < O(n!)",
            "description": "복잡도 순서"
          },
          {
            "latex": "f(n) = O(g(n)) \\Leftrightarrow \\exists c, n_0: f(n) \\leq c \\cdot g(n), \\forall n > n_0",
            "description": "Big-O 정의"
          }
        ],
        "examples": [
          {
            "problem": "배열에서 특정 값 찾기의 복잡도는?",
            "solution": "선형 탐색: O(n), 이진 탐색(정렬된 경우): O(log n)"
          },
          { "problem": "3n² + 5n + 1의 Big-O는?", "solution": "O(n²) - 최고차항만 남김" }
        ],
        "applications": [
          { "field": "알고리즘 설계", "description": "효율적인 알고리즘 선택" },
          { "field": "면접", "description": "코딩 인터뷰 필수 지식" },
          { "field": "시스템 설계", "description": "확장성 분석" }
        ]
      },
      "en": {
        "definition": "Big-O notation expresses algorithm complexity as growth rate relative to input size. Represents worst case.",
        "formulas": [
          {
            "latex": "O(1) < O(\\log n) < O(n) < O(n\\log n) < O(n^2) < O(2^n) < O(n!)",
            "description": "Complexity order"
          },
          {
            "latex": "f(n) = O(g(n)) \\Leftrightarrow \\exists c, n_0: f(n) \\leq c \\cdot g(n), \\forall n > n_0",
            "description": "Big-O definition"
          }
        ],
        "examples": [
          {
            "problem": "Complexity of finding value in array?",
            "solution": "Linear search: O(n), Binary search (sorted): O(log n)"
          },
          { "problem": "Big-O of 3n² + 5n + 1?", "solution": "O(n²) - keep highest order term" }
        ],
        "applications": [
          { "field": "Algorithm Design", "description": "Choosing efficient algorithms" },
          { "field": "Interviews", "description": "Essential coding interview knowledge" },
          { "field": "System Design", "description": "Scalability analysis" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["limits", "logarithm"],
      "nextTopics": ["sorting-algorithms", "data-structures"],
      "related": ["recurrence-relations"]
    },
    "tags": ["복잡도", "알고리즘", "Big-O", "complexity"]
  },
  {
    "id": "binary-representation",
    "name": { "ko": "이진 표현", "en": "Binary Representation" },
    "field": "applied-cs",
    "subfield": "fundamentals",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "이진법은 0과 1만으로 수를 표현하는 체계입니다. 컴퓨터의 모든 데이터는 내부적으로 이진수로 저장됩니다.",
        "formulas": [
          {
            "latex": "(a_n a_{n-1}...a_1 a_0)_2 = \\sum_{i=0}^{n} a_i \\cdot 2^i",
            "description": "이진수를 십진수로 변환"
          },
          {
            "latex": "1 \\text{ byte} = 8 \\text{ bits} = 2^8 = 256 \\text{ values}",
            "description": "바이트와 비트"
          },
          { "latex": "\\text{AND, OR, XOR, NOT}", "description": "비트 연산" }
        ],
        "examples": [
          {
            "problem": "이진수 1101을 십진수로 변환하세요.",
            "solution": "1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8+4+0+1 = 13"
          },
          {
            "problem": "십진수 25를 이진수로 변환하세요.",
            "solution": "25 = 16+8+1 = 2⁴+2³+2⁰ = 11001₂"
          }
        ],
        "applications": [
          { "field": "하드웨어", "description": "CPU, 메모리 동작" },
          { "field": "네트워크", "description": "IP 주소, 서브넷" },
          { "field": "그래픽", "description": "RGB 색상 표현" }
        ]
      },
      "en": {
        "definition": "Binary uses only 0 and 1 to represent numbers. All computer data is internally stored as binary.",
        "formulas": [
          {
            "latex": "(a_n a_{n-1}...a_1 a_0)_2 = \\sum_{i=0}^{n} a_i \\cdot 2^i",
            "description": "Binary to decimal conversion"
          },
          {
            "latex": "1 \\text{ byte} = 8 \\text{ bits} = 2^8 = 256 \\text{ values}",
            "description": "Bytes and bits"
          },
          { "latex": "\\text{AND, OR, XOR, NOT}", "description": "Bitwise operations" }
        ],
        "examples": [
          {
            "problem": "Convert binary 1101 to decimal.",
            "solution": "1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8+4+0+1 = 13"
          },
          {
            "problem": "Convert decimal 25 to binary.",
            "solution": "25 = 16+8+1 = 2⁴+2³+2⁰ = 11001₂"
          }
        ],
        "applications": [
          { "field": "Hardware", "description": "CPU, memory operation" },
          { "field": "Networking", "description": "IP addresses, subnets" },
          { "field": "Graphics", "description": "RGB color representation" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["exponents"],
      "nextTopics": ["floating-point", "bitwise-operations"],
      "related": ["hexadecimal", "octal"]
    },
    "tags": ["이진법", "비트", "binary", "computer"]
  },
  {
    "id": "computer-graphics-math",
    "name": { "ko": "컴퓨터 그래픽스 수학", "en": "Computer Graphics Mathematics" },
    "field": "applied-cs",
    "subfield": "graphics",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "컴퓨터 그래픽스는 선형대수(행렬 변환), 기하학, 미적분학을 활용하여 2D/3D 이미지를 생성합니다.",
        "formulas": [
          {
            "latex": "\\begin{pmatrix} x' \\\\ y' \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a & b & t_x \\\\ c & d & t_y \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\\\ 1 \\end{pmatrix}",
            "description": "2D 아핀 변환 (동차좌표)"
          },
          {
            "latex": "R_z(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}",
            "description": "Z축 회전 행렬"
          },
          {
            "latex": "\\vec{n} \\cdot \\vec{l} = |\\vec{n}||\\vec{l}|\\cos\\theta",
            "description": "램버트 조명 (내적 활용)"
          }
        ],
        "examples": [
          {
            "problem": "점 (3,2)를 원점 기준 90° 회전하면?",
            "solution": "(x',y') = (3cos90° - 2sin90°, 3sin90° + 2cos90°) = (-2, 3)"
          },
          {
            "problem": "2배 확대 후 (5,3) 이동하는 행렬은?",
            "solution": "Scale(2) × Translate(5,3) 순서로 행렬 곱"
          }
        ],
        "applications": [
          { "field": "게임", "description": "캐릭터/카메라 변환" },
          { "field": "영화", "description": "VFX, 3D 렌더링" },
          { "field": "CAD", "description": "설계 도구" }
        ]
      },
      "en": {
        "definition": "Computer graphics uses linear algebra (matrix transforms), geometry, and calculus to generate 2D/3D images.",
        "formulas": [
          {
            "latex": "\\begin{pmatrix} x' \\\\ y' \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a & b & t_x \\\\ c & d & t_y \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\\\ 1 \\end{pmatrix}",
            "description": "2D affine transform (homogeneous)"
          },
          {
            "latex": "R_z(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}",
            "description": "Z-axis rotation matrix"
          },
          {
            "latex": "\\vec{n} \\cdot \\vec{l} = |\\vec{n}||\\vec{l}|\\cos\\theta",
            "description": "Lambert lighting (dot product)"
          }
        ],
        "examples": [
          {
            "problem": "Rotate point (3,2) by 90° around origin?",
            "solution": "(x',y') = (3cos90° - 2sin90°, 3sin90° + 2cos90°) = (-2, 3)"
          },
          {
            "problem": "Matrix for 2× scale then translate (5,3)?",
            "solution": "Scale(2) × Translate(5,3) matrix multiplication"
          }
        ],
        "applications": [
          { "field": "Games", "description": "Character/camera transforms" },
          { "field": "Film", "description": "VFX, 3D rendering" },
          { "field": "CAD", "description": "Design tools" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["matrix", "trigonometry", "vectors"],
      "nextTopics": ["ray-tracing", "shaders"],
      "related": ["linear-transformations"]
    },
    "tags": ["그래픽스", "행렬", "graphics", "transformation"]
  },
  {
    "id": "information-theory-basics",
    "name": { "ko": "정보 이론 기초", "en": "Information Theory Basics" },
    "field": "applied-cs",
    "subfield": "information",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "정보 이론은 정보의 양과 전송을 수학적으로 다룹니다. 데이터 압축과 통신의 이론적 기반입니다.",
        "formulas": [
          { "latex": "H(X) = -\\sum_{i} p_i \\log_2 p_i", "description": "샤논 엔트로피" },
          { "latex": "I(x) = -\\log_2 p(x)", "description": "정보량 (비트)" },
          {
            "latex": "C = B \\log_2(1 + \\frac{S}{N})",
            "description": "샤논-하틀리 정리 (채널 용량)"
          }
        ],
        "examples": [
          {
            "problem": "공정한 동전의 엔트로피는?",
            "solution": "H = -½log₂(½) - ½log₂(½) = 1 비트"
          },
          {
            "problem": "8개 동일 확률 결과의 엔트로피는?",
            "solution": "H = -8 × (1/8)log₂(1/8) = log₂(8) = 3 비트"
          }
        ],
        "history": {
          "discoveredBy": "클로드 섀넌",
          "year": "1948년",
          "background": "벨 연구소에서 발표한 '통신의 수학적 이론'으로 정보 시대의 기초를 놓음"
        },
        "applications": [
          { "field": "압축", "description": "ZIP, MP3, JPEG 알고리즘" },
          { "field": "통신", "description": "채널 코딩" },
          { "field": "머신러닝", "description": "교차 엔트로피 손실" }
        ]
      },
      "en": {
        "definition": "Information theory mathematically studies information quantity and transmission. Foundation of compression and communication.",
        "formulas": [
          { "latex": "H(X) = -\\sum_{i} p_i \\log_2 p_i", "description": "Shannon entropy" },
          { "latex": "I(x) = -\\log_2 p(x)", "description": "Information content (bits)" },
          {
            "latex": "C = B \\log_2(1 + \\frac{S}{N})",
            "description": "Shannon-Hartley theorem (channel capacity)"
          }
        ],
        "examples": [
          { "problem": "Entropy of fair coin?", "solution": "H = -½log₂(½) - ½log₂(½) = 1 bit" },
          {
            "problem": "Entropy of 8 equally likely outcomes?",
            "solution": "H = -8 × (1/8)log₂(1/8) = log₂(8) = 3 bits"
          }
        ],
        "history": {
          "discoveredBy": "Claude Shannon",
          "year": "1948",
          "background": "Published 'Mathematical Theory of Communication' at Bell Labs, founding information age"
        },
        "applications": [
          { "field": "Compression", "description": "ZIP, MP3, JPEG algorithms" },
          { "field": "Communication", "description": "Channel coding" },
          { "field": "Machine Learning", "description": "Cross-entropy loss" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["logarithm", "probability-basics"],
      "nextTopics": ["huffman-coding", "error-correction"],
      "related": ["cryptography-math"]
    },
    "tags": ["정보이론", "엔트로피", "information theory", "Shannon"]
  },
  {
    "id": "machine-learning-math",
    "name": { "ko": "머신러닝 수학", "en": "Machine Learning Mathematics" },
    "field": "applied-cs",
    "subfield": "ml",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "머신러닝은 선형대수, 미적분, 확률/통계를 기반으로 데이터에서 패턴을 학습합니다.",
        "formulas": [
          {
            "latex": "\\hat{y} = \\sigma(\\vec{w} \\cdot \\vec{x} + b)",
            "description": "뉴런 출력 (활성화 함수 σ)"
          },
          { "latex": "L = -\\sum_i y_i \\log(\\hat{y}_i)", "description": "교차 엔트로피 손실" },
          {
            "latex": "\\vec{w} \\leftarrow \\vec{w} - \\alpha \\nabla_w L",
            "description": "경사하강법 업데이트"
          },
          { "latex": "P(y|x) = \\frac{P(x|y)P(y)}{P(x)}", "description": "베이즈 분류" }
        ],
        "examples": [
          { "problem": "시그모이드 σ(0)의 값은?", "solution": "σ(0) = 1/(1+e⁰) = 1/2 = 0.5" },
          { "problem": "선형회귀의 손실함수는?", "solution": "MSE = (1/n)Σ(yᵢ - ŷᵢ)²" }
        ],
        "applications": [
          { "field": "이미지 인식", "description": "CNN, 컴퓨터 비전" },
          { "field": "자연어 처리", "description": "번역, 챗봇" },
          { "field": "추천 시스템", "description": "넷플릭스, 유튜브" }
        ]
      },
      "en": {
        "definition": "ML uses linear algebra, calculus, probability/statistics to learn patterns from data.",
        "formulas": [
          {
            "latex": "\\hat{y} = \\sigma(\\vec{w} \\cdot \\vec{x} + b)",
            "description": "Neuron output (activation σ)"
          },
          { "latex": "L = -\\sum_i y_i \\log(\\hat{y}_i)", "description": "Cross-entropy loss" },
          {
            "latex": "\\vec{w} \\leftarrow \\vec{w} - \\alpha \\nabla_w L",
            "description": "Gradient descent update"
          },
          { "latex": "P(y|x) = \\frac{P(x|y)P(y)}{P(x)}", "description": "Bayes classification" }
        ],
        "examples": [
          { "problem": "Value of sigmoid σ(0)?", "solution": "σ(0) = 1/(1+e⁰) = 1/2 = 0.5" },
          {
            "problem": "Loss function for linear regression?",
            "solution": "MSE = (1/n)Σ(yᵢ - ŷᵢ)²"
          }
        ],
        "applications": [
          { "field": "Image Recognition", "description": "CNN, computer vision" },
          { "field": "NLP", "description": "Translation, chatbots" },
          { "field": "Recommendations", "description": "Netflix, YouTube" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["matrix", "partial-derivative", "probability-basics", "gradient-descent"],
      "nextTopics": ["deep-learning", "backpropagation"],
      "related": ["optimization", "statistics"]
    },
    "tags": ["머신러닝", "딥러닝", "machine learning", "AI"]
  },
  {
    "id": "hashing-math",
    "name": { "ko": "해싱의 수학", "en": "Mathematics of Hashing" },
    "field": "applied-cs",
    "subfield": "data-structures",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "해시 함수는 임의 크기 데이터를 고정 크기로 매핑합니다. 빠른 검색과 데이터 무결성 확인에 사용됩니다.",
        "formulas": [
          { "latex": "h(k) = k \\mod m", "description": "나눗셈 해시 (테이블 크기 m)" },
          {
            "latex": "h(k) = \\lfloor m(kA \\mod 1) \\rfloor",
            "description": "곱셈 해시 (A는 상수)"
          },
          {
            "latex": "P(\\text{충돌}) \\approx \\frac{n^2}{2m}",
            "description": "생일 역설 (n개 항목, m개 슬롯)"
          }
        ],
        "examples": [
          { "problem": "테이블 크기 10에서 h(27)은?", "solution": "h(27) = 27 mod 10 = 7" },
          { "problem": "365일 중 23명이면 생일 충돌 확률은?", "solution": "약 50% (생일 역설)" }
        ],
        "applications": [
          { "field": "데이터베이스", "description": "해시 테이블, 인덱싱" },
          { "field": "보안", "description": "비밀번호 저장, SHA" },
          { "field": "블록체인", "description": "작업 증명" }
        ]
      },
      "en": {
        "definition": "Hash functions map arbitrary data to fixed size. Used for fast lookup and data integrity.",
        "formulas": [
          { "latex": "h(k) = k \\mod m", "description": "Division hash (table size m)" },
          {
            "latex": "h(k) = \\lfloor m(kA \\mod 1) \\rfloor",
            "description": "Multiplication hash (constant A)"
          },
          {
            "latex": "P(\\text{collision}) \\approx \\frac{n^2}{2m}",
            "description": "Birthday paradox (n items, m slots)"
          }
        ],
        "examples": [
          { "problem": "h(27) with table size 10?", "solution": "h(27) = 27 mod 10 = 7" },
          {
            "problem": "Probability of shared birthday among 23 people?",
            "solution": "About 50% (birthday paradox)"
          }
        ],
        "applications": [
          { "field": "Databases", "description": "Hash tables, indexing" },
          { "field": "Security", "description": "Password storage, SHA" },
          { "field": "Blockchain", "description": "Proof of work" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["modular-arithmetic", "probability-basics"],
      "nextTopics": ["cryptographic-hash", "bloom-filters"],
      "related": ["birthday-paradox"]
    },
    "tags": ["해시", "자료구조", "hashing", "data structures"]
  },
  {
    "id": "signal-processing",
    "name": { "ko": "신호 처리", "en": "Signal Processing" },
    "field": "applied-engineering",
    "subfield": "signal-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "신호를 분석, 수정, 합성하는 수학적 기법",
        "formulas": ["푸리에 변환: F(ω) = ∫f(t)e^{-iωt}dt", "컨볼루션: (f*g)(t) = ∫f(τ)g(t-τ)dτ"],
        "examples": ["오디오 필터링", "이미지 압축"],
        "applications": ["통신 시스템", "MP3 인코딩"]
      },
      "en": {
        "definition": "Mathematical techniques to analyze, modify, and synthesize signals",
        "formulas": [
          "Fourier Transform: F(ω) = ∫f(t)e^{-iωt}dt",
          "Convolution: (f*g)(t) = ∫f(τ)g(t-τ)dτ"
        ],
        "examples": ["Audio filtering", "Image compression"],
        "applications": ["Communication systems", "MP3 encoding"]
      }
    },
    "latex": "F(\\omega) = \\int_{-\\infty}^{\\infty} f(t)e^{-i\\omega t}dt",
    "relations": {
      "prerequisites": ["fourier-series", "complex-numbers"],
      "nextTopics": ["control-theory"],
      "related": ["wave-equation"],
      "applications": ["audio-engineering", "image-processing"]
    },
    "tags": ["engineering", "signals", "fourier"]
  },
  {
    "id": "control-theory",
    "name": { "ko": "제어 이론", "en": "Control Theory" },
    "field": "applied-engineering",
    "subfield": "signal-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "동적 시스템의 행동을 조절하기 위한 수학적 프레임워크",
        "formulas": ["전달 함수: H(s) = Y(s)/X(s)", "PID 제어: u(t) = Kp·e + Ki·∫e dt + Kd·de/dt"],
        "examples": ["온도 조절기", "자동차 크루즈 컨트롤"],
        "applications": ["로봇 공학", "항공기 조종"]
      },
      "en": {
        "definition": "Mathematical framework for regulating the behavior of dynamic systems",
        "formulas": [
          "Transfer Function: H(s) = Y(s)/X(s)",
          "PID Control: u(t) = Kp·e + Ki·∫e dt + Kd·de/dt"
        ],
        "examples": ["Thermostat", "Car cruise control"],
        "applications": ["Robotics", "Aircraft autopilot"]
      }
    },
    "latex": "H(s) = \\frac{Y(s)}{X(s)}",
    "relations": {
      "prerequisites": ["differential-equations", "laplace-transform"],
      "nextTopics": ["state-space-model"],
      "related": ["signal-processing"],
      "applications": ["robotics", "automation"]
    },
    "tags": ["engineering", "control", "systems"]
  },
  {
    "id": "laplace-transform",
    "name": { "ko": "라플라스 변환", "en": "Laplace Transform" },
    "field": "applied-engineering",
    "subfield": "signal-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "시간 영역 함수를 복소 주파수 영역으로 변환하는 적분 변환",
        "formulas": ["L{f(t)} = F(s) = ∫₀^∞ f(t)e^{-st}dt", "L{f'(t)} = sF(s) - f(0)"],
        "examples": ["L{e^{at}} = 1/(s-a)", "L{sin(ωt)} = ω/(s²+ω²)"],
        "applications": ["회로 해석", "제어 시스템"]
      },
      "en": {
        "definition": "Integral transform converting time-domain functions to complex frequency domain",
        "formulas": ["L{f(t)} = F(s) = ∫₀^∞ f(t)e^{-st}dt", "L{f'(t)} = sF(s) - f(0)"],
        "examples": ["L{e^{at}} = 1/(s-a)", "L{sin(ωt)} = ω/(s²+ω²)"],
        "applications": ["Circuit analysis", "Control systems"]
      }
    },
    "latex": "\\mathcal{L}\\{f(t)\\} = F(s) = \\int_0^{\\infty} f(t)e^{-st}dt",
    "relations": {
      "prerequisites": ["improper-integrals", "complex-numbers"],
      "nextTopics": ["control-theory", "z-transform"],
      "related": ["fourier-transform"],
      "applications": ["differential-equations", "circuit-analysis"]
    },
    "tags": ["engineering", "transform", "analysis"]
  },
  {
    "id": "z-transform",
    "name": { "ko": "Z 변환", "en": "Z-Transform" },
    "field": "applied-engineering",
    "subfield": "signal-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "이산 신호를 복소 평면으로 변환하는 기법",
        "formulas": ["Z{x[n]} = X(z) = Σx[n]z^{-n}", "역변환: x[n] = (1/2πi)∮X(z)z^{n-1}dz"],
        "examples": ["Z{δ[n]} = 1", "Z{u[n]} = z/(z-1)"],
        "applications": ["디지털 필터 설계", "이산 제어 시스템"]
      },
      "en": {
        "definition": "Technique to transform discrete signals to the complex plane",
        "formulas": ["Z{x[n]} = X(z) = Σx[n]z^{-n}", "Inverse: x[n] = (1/2πi)∮X(z)z^{n-1}dz"],
        "examples": ["Z{δ[n]} = 1", "Z{u[n]} = z/(z-1)"],
        "applications": ["Digital filter design", "Discrete control systems"]
      }
    },
    "latex": "X(z) = \\sum_{n=-\\infty}^{\\infty} x[n]z^{-n}",
    "relations": {
      "prerequisites": ["laplace-transform", "sequences-and-series"],
      "nextTopics": ["digital-signal-processing"],
      "related": ["fourier-transform"],
      "applications": ["digital-filters", "control-systems"]
    },
    "tags": ["engineering", "discrete", "transform"]
  },
  {
    "id": "structural-mechanics",
    "name": { "ko": "구조 역학", "en": "Structural Mechanics" },
    "field": "applied-engineering",
    "subfield": "mechanics",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "하중을 받는 구조물의 응력, 변형, 안정성을 분석하는 학문",
        "formulas": ["응력: σ = F/A", "변형률: ε = ΔL/L", "훅의 법칙: σ = Eε"],
        "examples": ["보의 처짐 계산", "트러스 해석"],
        "applications": ["건물 설계", "교량 공학"]
      },
      "en": {
        "definition": "Study of stress, strain, and stability in structures under load",
        "formulas": ["Stress: σ = F/A", "Strain: ε = ΔL/L", "Hooke's Law: σ = Eε"],
        "examples": ["Beam deflection calculation", "Truss analysis"],
        "applications": ["Building design", "Bridge engineering"]
      }
    },
    "latex": "\\sigma = E\\epsilon",
    "relations": {
      "prerequisites": ["vectors", "differential-equations"],
      "nextTopics": ["finite-element-method"],
      "related": ["kinematics"],
      "applications": ["civil-engineering", "mechanical-engineering"]
    },
    "tags": ["engineering", "mechanics", "structures"]
  },
  {
    "id": "finite-element-method",
    "name": { "ko": "유한 요소법", "en": "Finite Element Method" },
    "field": "applied-engineering",
    "subfield": "numerical-methods",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "복잡한 편미분방정식을 이산화하여 수치적으로 해결하는 방법",
        "formulas": ["[K]{u} = {F}", "요소 강성 행렬: Ke = ∫BᵀDBdV"],
        "examples": ["열전달 해석", "응력 분포 계산"],
        "applications": ["CAE 소프트웨어", "구조 최적화"]
      },
      "en": {
        "definition": "Method to numerically solve complex PDEs by discretization",
        "formulas": ["[K]{u} = {F}", "Element stiffness matrix: Ke = ∫BᵀDBdV"],
        "examples": ["Heat transfer analysis", "Stress distribution calculation"],
        "applications": ["CAE software", "Structural optimization"]
      }
    },
    "latex": "[K]\\{u\\} = \\{F\\}",
    "relations": {
      "prerequisites": ["partial-differential-equations", "linear-algebra"],
      "nextTopics": ["computational-fluid-dynamics"],
      "related": ["structural-mechanics"],
      "applications": ["engineering-simulation", "physics-modeling"]
    },
    "tags": ["engineering", "numerical", "simulation"]
  },
  {
    "id": "fluid-dynamics",
    "name": { "ko": "유체 역학", "en": "Fluid Dynamics" },
    "field": "applied-engineering",
    "subfield": "mechanics",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "유체(액체, 기체)의 운동과 힘을 연구하는 역학 분야",
        "formulas": [
          "연속 방정식: ∂ρ/∂t + ∇·(ρv) = 0",
          "나비에-스토크스: ρ(∂v/∂t + v·∇v) = -∇p + μ∇²v"
        ],
        "examples": ["파이프 흐름", "항공기 양력"],
        "applications": ["항공공학", "기상 예측"]
      },
      "en": {
        "definition": "Branch of mechanics studying motion and forces in fluids",
        "formulas": [
          "Continuity: ∂ρ/∂t + ∇·(ρv) = 0",
          "Navier-Stokes: ρ(∂v/∂t + v·∇v) = -∇p + μ∇²v"
        ],
        "examples": ["Pipe flow", "Aircraft lift"],
        "applications": ["Aerospace engineering", "Weather prediction"]
      }
    },
    "latex": "\\rho\\left(\\frac{\\partial \\mathbf{v}}{\\partial t} + \\mathbf{v} \\cdot \\nabla\\mathbf{v}\\right) = -\\nabla p + \\mu\\nabla^2\\mathbf{v}",
    "relations": {
      "prerequisites": ["partial-differential-equations", "vectors"],
      "nextTopics": ["computational-fluid-dynamics"],
      "related": ["kinematics"],
      "applications": ["aerospace", "hydraulics"]
    },
    "tags": ["engineering", "fluids", "mechanics"]
  },
  {
    "id": "thermodynamics-math",
    "name": { "ko": "열역학 수학", "en": "Thermodynamics Mathematics" },
    "field": "applied-engineering",
    "subfield": "thermal-systems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "열과 에너지 변환을 기술하는 수학적 프레임워크",
        "formulas": ["제1법칙: dU = δQ - δW", "제2법칙: dS ≥ δQ/T", "상태 방정식: PV = nRT"],
        "examples": ["카르노 사이클 효율", "엔트로피 계산"],
        "applications": ["엔진 설계", "냉동 시스템"]
      },
      "en": {
        "definition": "Mathematical framework describing heat and energy conversion",
        "formulas": ["1st Law: dU = δQ - δW", "2nd Law: dS ≥ δQ/T", "Equation of State: PV = nRT"],
        "examples": ["Carnot cycle efficiency", "Entropy calculation"],
        "applications": ["Engine design", "Refrigeration systems"]
      }
    },
    "latex": "dS \\geq \\frac{\\delta Q}{T}",
    "relations": {
      "prerequisites": ["partial-differential-equations", "multivariable-calculus"],
      "nextTopics": ["statistical-mechanics"],
      "related": ["entropy"],
      "applications": ["power-generation", "hvac"]
    },
    "tags": ["engineering", "thermodynamics", "energy"]
  },
  {
    "id": "rsa-algorithm",
    "name": { "ko": "RSA 알고리즘", "en": "RSA Algorithm" },
    "field": "cryptography",
    "subfield": "public-key",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "큰 소수의 곱을 인수분해하기 어렵다는 점에 기반한 공개키 암호 알고리즘",
        "formulas": [
          "키 생성: n = p·q, φ(n) = (p-1)(q-1)",
          "암호화: c ≡ m^e (mod n)",
          "복호화: m ≡ c^d (mod n)",
          "ed ≡ 1 (mod φ(n))"
        ],
        "examples": ["p=61, q=53 → n=3233, φ(n)=3120", "e=17 → d=2753"],
        "applications": ["HTTPS/SSL", "전자서명", "인증서"]
      },
      "en": {
        "definition": "Public-key cryptosystem based on difficulty of factoring large prime products",
        "formulas": [
          "Key generation: n = p·q, φ(n) = (p-1)(q-1)",
          "Encryption: c ≡ m^e (mod n)",
          "Decryption: m ≡ c^d (mod n)",
          "ed ≡ 1 (mod φ(n))"
        ],
        "examples": ["p=61, q=53 → n=3233, φ(n)=3120", "e=17 → d=2753"],
        "applications": ["HTTPS/SSL", "Digital signatures", "Certificates"]
      }
    },
    "latex": "c \\equiv m^e \\pmod{n}",
    "relations": {
      "prerequisites": ["modular-arithmetic", "prime-numbers", "eulers-totient"],
      "nextTopics": ["elliptic-curve-crypto"],
      "related": ["diffie-hellman"],
      "applications": ["secure-communication", "authentication"]
    },
    "tags": ["RSA", "공개키", "public-key", "encryption"]
  },
  {
    "id": "elliptic-curve-crypto",
    "name": { "ko": "타원곡선 암호", "en": "Elliptic Curve Cryptography" },
    "field": "cryptography",
    "subfield": "public-key",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "타원곡선 위의 점들의 이산 로그 문제에 기반한 암호 시스템",
        "formulas": [
          "타원곡선: y² = x³ + ax + b",
          "점 덧셈: P + Q = R",
          "스칼라 곱: kP = P + P + ... + P (k번)"
        ],
        "examples": ["secp256k1 (비트코인)", "Curve25519"],
        "applications": ["비트코인", "TLS", "Signal 프로토콜"]
      },
      "en": {
        "definition": "Cryptosystem based on discrete logarithm problem on elliptic curves",
        "formulas": [
          "Elliptic curve: y² = x³ + ax + b",
          "Point addition: P + Q = R",
          "Scalar multiplication: kP = P + P + ... + P (k times)"
        ],
        "examples": ["secp256k1 (Bitcoin)", "Curve25519"],
        "applications": ["Bitcoin", "TLS", "Signal protocol"]
      }
    },
    "latex": "y^2 = x^3 + ax + b",
    "relations": {
      "prerequisites": ["group-theory", "modular-arithmetic"],
      "nextTopics": ["ecdsa", "ecdh"],
      "related": ["rsa-algorithm"],
      "applications": ["cryptocurrency", "secure-messaging"]
    },
    "tags": ["ECC", "타원곡선", "elliptic", "crypto"]
  },
  {
    "id": "diffie-hellman",
    "name": { "ko": "디피-헬만 키 교환", "en": "Diffie-Hellman Key Exchange" },
    "field": "cryptography",
    "subfield": "key-exchange",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "안전하지 않은 채널에서 두 당사자가 비밀 키를 공유할 수 있게 하는 프로토콜",
        "formulas": [
          "공개: g, p (소수)",
          "A가 a 선택: A = g^a mod p",
          "B가 b 선택: B = g^b mod p",
          "공유 비밀: K = g^{ab} mod p"
        ],
        "examples": ["g=5, p=23, a=6, b=15", "A=8, B=19, K=2"],
        "applications": ["TLS/SSL", "VPN", "SSH"]
      },
      "en": {
        "definition": "Protocol allowing two parties to establish a shared secret over insecure channel",
        "formulas": [
          "Public: g, p (prime)",
          "A chooses a: A = g^a mod p",
          "B chooses b: B = g^b mod p",
          "Shared secret: K = g^{ab} mod p"
        ],
        "examples": ["g=5, p=23, a=6, b=15", "A=8, B=19, K=2"],
        "applications": ["TLS/SSL", "VPN", "SSH"]
      }
    },
    "latex": "K = g^{ab} \\mod p",
    "relations": {
      "prerequisites": ["modular-arithmetic", "discrete-log"],
      "nextTopics": ["elliptic-curve-crypto"],
      "related": ["rsa-algorithm"],
      "applications": ["secure-communication"]
    },
    "tags": ["DH", "키교환", "key-exchange", "protocol"]
  },
  {
    "id": "aes-encryption",
    "name": { "ko": "AES 암호화", "en": "AES Encryption" },
    "field": "cryptography",
    "subfield": "symmetric-key",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "가장 널리 사용되는 대칭키 블록 암호 알고리즘 (Advanced Encryption Standard)",
        "formulas": ["블록 크기: 128비트", "키 길이: 128/192/256비트", "라운드 수: 10/12/14"],
        "examples": ["SubBytes (S-box 치환)", "ShiftRows, MixColumns", "AddRoundKey"],
        "applications": ["파일 암호화", "디스크 암호화", "HTTPS"]
      },
      "en": {
        "definition": "Most widely used symmetric-key block cipher (Advanced Encryption Standard)",
        "formulas": ["Block size: 128 bits", "Key length: 128/192/256 bits", "Rounds: 10/12/14"],
        "examples": ["SubBytes (S-box substitution)", "ShiftRows, MixColumns", "AddRoundKey"],
        "applications": ["File encryption", "Disk encryption", "HTTPS"]
      }
    },
    "latex": "C = E_K(P)",
    "relations": {
      "prerequisites": ["binary-representation", "galois-field"],
      "nextTopics": ["block-cipher-modes"],
      "related": ["des-encryption"],
      "applications": ["data-security"]
    },
    "tags": ["AES", "대칭키", "symmetric", "block-cipher"]
  },
  {
    "id": "hash-function-crypto",
    "name": { "ko": "암호학적 해시 함수", "en": "Cryptographic Hash Function" },
    "field": "cryptography",
    "subfield": "hash",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "임의 길이 데이터를 고정 길이 해시값으로 변환하는 단방향 함수",
        "formulas": [
          "H: {0,1}* → {0,1}^n",
          "충돌 저항성: H(x) = H(y)인 x≠y 찾기 어려움",
          "역상 저항성: H(x) = h인 x 찾기 어려움"
        ],
        "examples": ["SHA-256: 256비트 출력", "SHA-3 (Keccak)", "BLAKE2"],
        "applications": ["비밀번호 저장", "무결성 검증", "디지털 서명"]
      },
      "en": {
        "definition": "One-way function converting arbitrary data to fixed-length hash value",
        "formulas": [
          "H: {0,1}* → {0,1}^n",
          "Collision resistance: Hard to find x≠y with H(x) = H(y)",
          "Preimage resistance: Hard to find x given H(x) = h"
        ],
        "examples": ["SHA-256: 256-bit output", "SHA-3 (Keccak)", "BLAKE2"],
        "applications": ["Password storage", "Integrity verification", "Digital signatures"]
      }
    },
    "latex": "H: \\{0,1\\}^* \\rightarrow \\{0,1\\}^n",
    "relations": {
      "prerequisites": ["binary-representation"],
      "nextTopics": ["digital-signature", "merkle-tree"],
      "related": ["hashing-math"],
      "applications": ["blockchain", "authentication"]
    },
    "tags": ["해시", "SHA", "hash", "one-way"]
  },
  {
    "id": "digital-signature",
    "name": { "ko": "디지털 서명", "en": "Digital Signature" },
    "field": "cryptography",
    "subfield": "authentication",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "메시지의 진위성과 무결성을 보장하는 암호학적 기법",
        "formulas": [
          "서명: σ = Sign(SK, m)",
          "검증: Verify(PK, m, σ) → {true, false}",
          "RSA 서명: σ = H(m)^d mod n"
        ],
        "examples": ["ECDSA (비트코인)", "RSA-PSS", "Ed25519"],
        "applications": ["전자계약", "SSL 인증서", "소프트웨어 배포"]
      },
      "en": {
        "definition": "Cryptographic technique ensuring message authenticity and integrity",
        "formulas": [
          "Sign: σ = Sign(SK, m)",
          "Verify: Verify(PK, m, σ) → {true, false}",
          "RSA signature: σ = H(m)^d mod n"
        ],
        "examples": ["ECDSA (Bitcoin)", "RSA-PSS", "Ed25519"],
        "applications": ["E-contracts", "SSL certificates", "Software distribution"]
      }
    },
    "latex": "\\sigma = \\text{Sign}(SK, m)",
    "relations": {
      "prerequisites": ["rsa-algorithm", "hash-function-crypto"],
      "nextTopics": ["zero-knowledge-proof"],
      "related": ["elliptic-curve-crypto"],
      "applications": ["authentication", "non-repudiation"]
    },
    "tags": ["서명", "signature", "authentication", "PKI"]
  },
  {
    "id": "zero-knowledge-proof",
    "name": { "ko": "영지식 증명", "en": "Zero-Knowledge Proof" },
    "field": "cryptography",
    "subfield": "protocols",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "어떤 사실을 알고 있음을 증명하되, 그 사실 자체는 공개하지 않는 증명 방식",
        "formulas": [
          "완전성: 참이면 검증자가 납득",
          "건전성: 거짓이면 속일 수 없음",
          "영지식성: 비밀 정보 누출 없음"
        ],
        "examples": ["색칠 그래프 문제", "zk-SNARKs", "zk-STARKs"],
        "applications": ["프라이버시 코인", "신원 증명", "투표 시스템"]
      },
      "en": {
        "definition": "Proof method demonstrating knowledge without revealing the knowledge itself",
        "formulas": [
          "Completeness: If true, verifier is convinced",
          "Soundness: If false, cannot be deceived",
          "Zero-knowledge: No secret information leaked"
        ],
        "examples": ["Graph coloring problem", "zk-SNARKs", "zk-STARKs"],
        "applications": ["Privacy coins", "Identity proof", "Voting systems"]
      }
    },
    "latex": "\\text{ZKP}: (P, V) \\rightarrow \\{\\text{accept}, \\text{reject}\\}",
    "relations": {
      "prerequisites": ["probability", "computational-complexity"],
      "nextTopics": ["zksnark", "zkstark"],
      "related": ["digital-signature"],
      "applications": ["blockchain", "privacy"]
    },
    "tags": ["ZKP", "영지식", "zero-knowledge", "privacy"]
  },
  {
    "id": "modular-arithmetic",
    "name": { "ko": "모듈러 연산", "en": "Modular Arithmetic" },
    "field": "cryptography",
    "subfield": "foundations",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "나머지 연산을 기반으로 한 정수 연산 체계 (시계 연산)",
        "formulas": [
          "a ≡ b (mod n) ⟺ n | (a-b)",
          "(a + b) mod n = ((a mod n) + (b mod n)) mod n",
          "(a · b) mod n = ((a mod n) · (b mod n)) mod n"
        ],
        "examples": ["17 ≡ 5 (mod 12)", "7⁻¹ ≡ 3 (mod 10)"],
        "applications": ["암호학", "해시 함수", "오류 검출"]
      },
      "en": {
        "definition": "Integer arithmetic system based on remainder operations (clock arithmetic)",
        "formulas": [
          "a ≡ b (mod n) ⟺ n | (a-b)",
          "(a + b) mod n = ((a mod n) + (b mod n)) mod n",
          "(a · b) mod n = ((a mod n) · (b mod n)) mod n"
        ],
        "examples": ["17 ≡ 5 (mod 12)", "7⁻¹ ≡ 3 (mod 10)"],
        "applications": ["Cryptography", "Hash functions", "Error detection"]
      }
    },
    "latex": "a \\equiv b \\pmod{n}",
    "relations": {
      "prerequisites": ["division-algorithm"],
      "nextTopics": ["rsa-algorithm", "chinese-remainder-theorem"],
      "related": ["eulers-totient"],
      "applications": ["cryptography", "computer-science"]
    },
    "tags": ["모듈러", "mod", "modular", "remainder"]
  },
  {
    "id": "nash-equilibrium",
    "name": { "ko": "내쉬 균형", "en": "Nash Equilibrium" },
    "field": "game-theory",
    "subfield": "strategic-games",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "모든 참여자가 자신의 전략을 바꿀 유인이 없는 전략 조합",
        "formulas": [
          "∀i: u_i(s*_i, s*_{-i}) ≥ u_i(s_i, s*_{-i})",
          "최적 반응: BR_i(s_{-i}) = argmax u_i(s_i, s_{-i})"
        ],
        "examples": ["죄수의 딜레마: (배신, 배신)", "사슴 사냥 게임"],
        "applications": ["경제학", "정치학", "진화생물학"]
      },
      "en": {
        "definition": "Strategy profile where no player has incentive to change their strategy",
        "formulas": [
          "∀i: u_i(s*_i, s*_{-i}) ≥ u_i(s_i, s*_{-i})",
          "Best response: BR_i(s_{-i}) = argmax u_i(s_i, s_{-i})"
        ],
        "examples": ["Prisoner's Dilemma: (Defect, Defect)", "Stag Hunt Game"],
        "applications": ["Economics", "Political Science", "Evolutionary Biology"]
      }
    },
    "latex": "u_i(s^*_i, s^*_{-i}) \\geq u_i(s_i, s^*_{-i})",
    "relations": {
      "prerequisites": ["game-theory-basics"],
      "nextTopics": ["mixed-strategy", "subgame-perfect"],
      "related": ["pareto-efficiency"],
      "applications": ["economics", "strategy"]
    },
    "tags": ["내쉬", "Nash", "균형", "equilibrium"]
  },
  {
    "id": "prisoners-dilemma",
    "name": { "ko": "죄수의 딜레마", "en": "Prisoner's Dilemma" },
    "field": "game-theory",
    "subfield": "strategic-games",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "개인의 합리적 선택이 집단 전체의 이익에 반하는 결과를 낳는 게임",
        "formulas": [
          "보수 행렬: T > R > P > S",
          "배신 유혹(T) > 협력 보상(R) > 상호 배신(P) > 호구(S)"
        ],
        "examples": ["군비 경쟁", "환경 오염", "가격 담합"],
        "applications": ["국제관계", "기업 전략", "사회적 딜레마"]
      },
      "en": {
        "definition": "Game where individual rational choices lead to collectively suboptimal outcomes",
        "formulas": [
          "Payoff matrix: T > R > P > S",
          "Temptation(T) > Reward(R) > Punishment(P) > Sucker(S)"
        ],
        "examples": ["Arms race", "Pollution", "Price fixing"],
        "applications": ["International relations", "Business strategy", "Social dilemmas"]
      }
    },
    "latex": "\\begin{pmatrix} R,R & S,T \\\\ T,S & P,P \\end{pmatrix}",
    "relations": {
      "prerequisites": [],
      "nextTopics": ["nash-equilibrium", "repeated-games"],
      "related": ["chicken-game", "stag-hunt"],
      "applications": ["social-science", "economics"]
    },
    "tags": ["죄수", "prisoner", "딜레마", "dilemma"]
  },
  {
    "id": "minimax-theorem",
    "name": { "ko": "미니맥스 정리", "en": "Minimax Theorem" },
    "field": "game-theory",
    "subfield": "zero-sum",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "영합 게임에서 최선의 전략은 최대 손실을 최소화하는 것",
        "formulas": [
          "max_x min_y u(x,y) = min_y max_x u(x,y)",
          "안장점: u(x*, y) ≤ u(x*, y*) ≤ u(x, y*)"
        ],
        "examples": ["가위바위보", "체스", "틱택토"],
        "applications": ["인공지능", "의사결정", "최적화"]
      },
      "en": {
        "definition": "In zero-sum games, optimal strategy minimizes maximum loss",
        "formulas": [
          "max_x min_y u(x,y) = min_y max_x u(x,y)",
          "Saddle point: u(x*, y) ≤ u(x*, y*) ≤ u(x, y*)"
        ],
        "examples": ["Rock-Paper-Scissors", "Chess", "Tic-Tac-Toe"],
        "applications": ["AI", "Decision making", "Optimization"]
      }
    },
    "latex": "\\max_x \\min_y u(x,y) = \\min_y \\max_x u(x,y)",
    "relations": {
      "prerequisites": ["matrix-operations"],
      "nextTopics": ["alpha-beta-pruning"],
      "related": ["nash-equilibrium"],
      "applications": ["game-ai", "decision-theory"]
    },
    "tags": ["미니맥스", "minimax", "영합", "zero-sum"]
  },
  {
    "id": "pareto-efficiency",
    "name": { "ko": "파레토 효율성", "en": "Pareto Efficiency" },
    "field": "game-theory",
    "subfield": "welfare",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "다른 누군가의 상황을 악화시키지 않고는 누구의 상황도 개선할 수 없는 상태",
        "formulas": ["파레토 개선: ∃ 배분 y: u_i(y) ≥ u_i(x) ∀i, 일부 j에서 >"],
        "examples": ["자원 배분", "무역 이익", "계약 협상"],
        "applications": ["경제학", "공공정책", "협상이론"]
      },
      "en": {
        "definition": "State where no one can be made better off without making someone worse off",
        "formulas": ["Pareto improvement: ∃ allocation y: u_i(y) ≥ u_i(x) ∀i, strict for some j"],
        "examples": ["Resource allocation", "Gains from trade", "Contract negotiation"],
        "applications": ["Economics", "Public policy", "Negotiation theory"]
      }
    },
    "latex": "\\nexists y: u_i(y) \\geq u_i(x) \\; \\forall i, \\; u_j(y) > u_j(x) \\; \\exists j",
    "relations": {
      "prerequisites": ["utility-function"],
      "nextTopics": ["welfare-theorems"],
      "related": ["nash-equilibrium"],
      "applications": ["welfare-economics"]
    },
    "tags": ["파레토", "Pareto", "효율", "efficiency"]
  },
  {
    "id": "mixed-strategy",
    "name": { "ko": "혼합 전략", "en": "Mixed Strategy" },
    "field": "game-theory",
    "subfield": "strategic-games",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "순수 전략들에 확률을 부여하여 무작위로 선택하는 전략",
        "formulas": ["σ_i: S_i → [0,1], Σσ_i(s) = 1", "기대 보수: E[u_i] = Σ σ(s)·u_i(s)"],
        "examples": ["가위바위보: (1/3, 1/3, 1/3)", "페널티킥 방향"],
        "applications": ["스포츠 전략", "경매", "보안"]
      },
      "en": {
        "definition": "Strategy assigning probabilities to pure strategies for random selection",
        "formulas": ["σ_i: S_i → [0,1], Σσ_i(s) = 1", "Expected payoff: E[u_i] = Σ σ(s)·u_i(s)"],
        "examples": ["Rock-Paper-Scissors: (1/3, 1/3, 1/3)", "Penalty kick direction"],
        "applications": ["Sports strategy", "Auctions", "Security"]
      }
    },
    "latex": "\\sigma_i: S_i \\rightarrow [0,1], \\; \\sum_{s \\in S_i} \\sigma_i(s) = 1",
    "relations": {
      "prerequisites": ["probability", "expected-value"],
      "nextTopics": ["nash-equilibrium"],
      "related": ["pure-strategy"],
      "applications": ["randomized-algorithms"]
    },
    "tags": ["혼합", "mixed", "전략", "strategy"]
  },
  {
    "id": "auction-theory",
    "name": { "ko": "경매 이론", "en": "Auction Theory" },
    "field": "game-theory",
    "subfield": "mechanism-design",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "경매의 전략적 행동과 최적 설계를 연구하는 분야",
        "formulas": [
          "영국식: 공개 오름차순",
          "네덜란드식: 공개 내림차순",
          "밀봉 1가격: 최고가 지불",
          "밀봉 2가격 (비크리): 차점가 지불"
        ],
        "examples": ["Google 광고 경매", "무선 주파수 경매", "예술품 경매"],
        "applications": ["온라인 광고", "정부 입찰", "자원 배분"]
      },
      "en": {
        "definition": "Study of strategic behavior and optimal design in auctions",
        "formulas": [
          "English: Open ascending",
          "Dutch: Open descending",
          "First-price sealed",
          "Second-price sealed (Vickrey): Pay second highest"
        ],
        "examples": ["Google Ad auction", "Spectrum auction", "Art auction"],
        "applications": ["Online advertising", "Government procurement", "Resource allocation"]
      }
    },
    "latex": "b^*(v) = v - \\frac{\\int_0^v F(t)^{n-1} dt}{F(v)^{n-1}}",
    "relations": {
      "prerequisites": ["expected-value", "game-theory-basics"],
      "nextTopics": ["mechanism-design"],
      "related": ["nash-equilibrium"],
      "applications": ["market-design"]
    },
    "tags": ["경매", "auction", "입찰", "bidding"]
  },
  {
    "id": "evolutionary-game",
    "name": { "ko": "진화 게임 이론", "en": "Evolutionary Game Theory" },
    "field": "game-theory",
    "subfield": "evolutionary",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "자연선택과 적응을 게임 이론으로 모델링하는 분야",
        "formulas": [
          "복제자 동역학: ẋ_i = x_i(f_i - φ)",
          "진화적 안정 전략(ESS): u(σ*, σ*) > u(σ, σ*) 또는 같으면 u(σ*, σ) > u(σ, σ)"
        ],
        "examples": ["매-비둘기 게임", "틱-포-탯 전략", "성비 진화"],
        "applications": ["진화생물학", "사회 규범", "문화 진화"]
      },
      "en": {
        "definition": "Modeling natural selection and adaptation using game theory",
        "formulas": [
          "Replicator dynamics: ẋ_i = x_i(f_i - φ)",
          "ESS: u(σ*, σ*) > u(σ, σ*) or if equal, u(σ*, σ) > u(σ, σ)"
        ],
        "examples": ["Hawk-Dove game", "Tit-for-Tat strategy", "Sex ratio evolution"],
        "applications": ["Evolutionary biology", "Social norms", "Cultural evolution"]
      }
    },
    "latex": "\\dot{x}_i = x_i(f_i - \\bar{f})",
    "relations": {
      "prerequisites": ["nash-equilibrium", "differential-equations"],
      "nextTopics": ["population-dynamics"],
      "related": ["prisoners-dilemma"],
      "applications": ["biology", "sociology"]
    },
    "tags": ["진화", "evolutionary", "ESS", "replicator"]
  },
  {
    "id": "cooperative-game",
    "name": { "ko": "협력 게임", "en": "Cooperative Game" },
    "field": "game-theory",
    "subfield": "cooperative",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "참가자들이 연합을 형성하여 공동 이익을 추구하는 게임",
        "formulas": [
          "특성함수: v: 2^N → ℝ",
          "섀플리 값: φ_i(v) = Σ |S|!(n-|S|-1)!/n! · [v(S∪{i}) - v(S)]",
          "핵: C(v) = {x: Σx_i = v(N), Σ_{i∈S} x_i ≥ v(S)}"
        ],
        "examples": ["비용 분담", "투표 권력", "이익 배분"],
        "applications": ["정치학", "기업 합병", "국제 협력"]
      },
      "en": {
        "definition": "Games where players form coalitions to pursue joint benefits",
        "formulas": [
          "Characteristic function: v: 2^N → ℝ",
          "Shapley value: φ_i(v) = Σ |S|!(n-|S|-1)!/n! · [v(S∪{i}) - v(S)]",
          "Core: C(v) = {x: Σx_i = v(N), Σ_{i∈S} x_i ≥ v(S)}"
        ],
        "examples": ["Cost sharing", "Voting power", "Profit division"],
        "applications": ["Political science", "Corporate mergers", "International cooperation"]
      }
    },
    "latex": "\\phi_i(v) = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(n-|S|-1)!}{n!} [v(S \\cup \\{i\\}) - v(S)]",
    "relations": {
      "prerequisites": ["set-theory", "combinatorics"],
      "nextTopics": ["shapley-value", "core"],
      "related": ["nash-equilibrium"],
      "applications": ["fair-division"]
    },
    "tags": ["협력", "cooperative", "연합", "coalition"]
  },
  {
    "id": "sigma-algebra",
    "name": { "ko": "시그마 대수", "en": "Sigma-Algebra (σ-algebra)" },
    "field": "measure-theory",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "집합의 여집합, 가산 합집합에 닫힌 집합족. 측도를 정의할 수 있는 구조",
        "formulas": ["1. Ω ∈ Σ", "2. A ∈ Σ ⇒ A^c ∈ Σ", "3. A₁, A₂, ... ∈ Σ ⇒ ∪A_n ∈ Σ"],
        "examples": ["보렐 시그마 대수 B(ℝ)", "{∅, Ω}", "멱집합 P(Ω)"],
        "applications": ["확률론", "적분론", "함수해석학"]
      },
      "en": {
        "definition": "Collection of sets closed under complement and countable union. Structure for defining measures",
        "formulas": ["1. Ω ∈ Σ", "2. A ∈ Σ ⇒ A^c ∈ Σ", "3. A₁, A₂, ... ∈ Σ ⇒ ∪A_n ∈ Σ"],
        "examples": ["Borel σ-algebra B(ℝ)", "{∅, Ω}", "Power set P(Ω)"],
        "applications": ["Probability", "Integration", "Functional analysis"]
      }
    },
    "latex": "A \\in \\Sigma \\Rightarrow A^c \\in \\Sigma",
    "relations": {
      "prerequisites": ["set-theory"],
      "nextTopics": ["measure", "borel-sets"],
      "related": ["topology"],
      "applications": ["probability-theory"]
    },
    "tags": ["시그마", "sigma", "대수", "algebra"]
  },
  {
    "id": "lebesgue-measure",
    "name": { "ko": "르베그 측도", "en": "Lebesgue Measure" },
    "field": "measure-theory",
    "subfield": "measures",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "ℝⁿ에서 집합의 \"크기\"를 일반화한 측도. 리만 적분의 한계를 극복",
        "formulas": [
          "구간의 측도: λ([a,b]) = b - a",
          "가산 가법성: λ(∪A_n) = Σλ(A_n) (서로소)",
          "외측도: λ*(A) = inf{Σℓ(I_n): A ⊆ ∪I_n}"
        ],
        "examples": ["λ(ℚ ∩ [0,1]) = 0", "λ(칸토어 집합) = 0"],
        "applications": ["적분론", "확률론", "푸리에 해석"]
      },
      "en": {
        "definition": "Generalized notion of \"size\" for sets in ℝⁿ. Overcomes limitations of Riemann integral",
        "formulas": [
          "Interval measure: λ([a,b]) = b - a",
          "Countable additivity: λ(∪A_n) = Σλ(A_n) (disjoint)",
          "Outer measure: λ*(A) = inf{Σℓ(I_n): A ⊆ ∪I_n}"
        ],
        "examples": ["λ(ℚ ∩ [0,1]) = 0", "λ(Cantor set) = 0"],
        "applications": ["Integration", "Probability", "Fourier analysis"]
      }
    },
    "latex": "\\lambda([a,b]) = b - a",
    "relations": {
      "prerequisites": ["sigma-algebra", "real-analysis"],
      "nextTopics": ["lebesgue-integral", "measure-zero"],
      "related": ["riemann-integral"],
      "applications": ["integration", "probability"]
    },
    "tags": ["르베그", "Lebesgue", "측도", "measure"]
  },
  {
    "id": "lebesgue-integral",
    "name": { "ko": "르베그 적분", "en": "Lebesgue Integral" },
    "field": "measure-theory",
    "subfield": "integration",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "함수값의 범위를 분할하여 정의하는 적분. 리만 적분을 일반화",
        "formulas": [
          "단순함수: ∫φ dμ = Σa_i μ(A_i)",
          "일반함수: ∫f dμ = sup{∫φ dμ: φ ≤ f, φ 단순}",
          "MCT, DCT"
        ],
        "examples": ["디리클레 함수의 적분", "∫_ℝ e^{-x²} dx = √π"],
        "applications": ["확률론", "푸리에 해석", "함수공간"]
      },
      "en": {
        "definition": "Integration defined by partitioning range of function. Generalizes Riemann integral",
        "formulas": [
          "Simple function: ∫φ dμ = Σa_i μ(A_i)",
          "General: ∫f dμ = sup{∫φ dμ: φ ≤ f, φ simple}",
          "MCT, DCT"
        ],
        "examples": ["Integral of Dirichlet function", "∫_ℝ e^{-x²} dx = √π"],
        "applications": ["Probability", "Fourier analysis", "Function spaces"]
      }
    },
    "latex": "\\int f \\, d\\mu = \\sup\\left\\{\\int \\phi \\, d\\mu : \\phi \\leq f, \\phi \\text{ simple}\\right\\}",
    "relations": {
      "prerequisites": ["lebesgue-measure", "limits"],
      "nextTopics": ["lp-spaces", "fubini-theorem"],
      "related": ["riemann-integral"],
      "applications": ["probability-expectation"]
    },
    "tags": ["르베그", "Lebesgue", "적분", "integral"]
  },
  {
    "id": "probability-measure",
    "name": { "ko": "확률 측도", "en": "Probability Measure" },
    "field": "measure-theory",
    "subfield": "probability",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "전체 측도가 1인 측도. 확률론의 수학적 기초",
        "formulas": ["P(Ω) = 1", "P(A) ≥ 0", "P(∪A_n) = ΣP(A_n) (서로소)"],
        "examples": ["동전 던지기", "정규분포", "균등분포"],
        "applications": ["통계학", "금융", "물리학"]
      },
      "en": {
        "definition": "Measure with total measure 1. Mathematical foundation of probability",
        "formulas": ["P(Ω) = 1", "P(A) ≥ 0", "P(∪A_n) = ΣP(A_n) (disjoint)"],
        "examples": ["Coin flip", "Normal distribution", "Uniform distribution"],
        "applications": ["Statistics", "Finance", "Physics"]
      }
    },
    "latex": "P(\\Omega) = 1, \\quad P(A) \\geq 0",
    "relations": {
      "prerequisites": ["sigma-algebra", "lebesgue-measure"],
      "nextTopics": ["random-variable", "expectation"],
      "related": ["kolmogorov-axioms"],
      "applications": ["statistics", "stochastic-processes"]
    },
    "tags": ["확률", "probability", "측도", "measure"]
  },
  {
    "id": "fubini-theorem",
    "name": { "ko": "푸비니 정리", "en": "Fubini's Theorem" },
    "field": "measure-theory",
    "subfield": "integration",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "다중 적분에서 적분 순서를 교환할 수 있는 조건을 제시",
        "formulas": [
          "∬f d(μ×ν) = ∫(∫f(x,y) dν(y)) dμ(x) = ∫(∫f(x,y) dμ(x)) dν(y)",
          "조건: f가 적분 가능 또는 비음"
        ],
        "examples": ["이중적분 계산", "기댓값의 독립 분해"],
        "applications": ["다변량 적분", "확률론", "푸리에 변환"]
      },
      "en": {
        "definition": "Conditions under which order of integration can be exchanged in multiple integrals",
        "formulas": [
          "∬f d(μ×ν) = ∫(∫f(x,y) dν(y)) dμ(x) = ∫(∫f(x,y) dμ(x)) dν(y)",
          "Condition: f integrable or non-negative"
        ],
        "examples": ["Double integral computation", "Independent expectation decomposition"],
        "applications": ["Multivariable integration", "Probability", "Fourier transform"]
      }
    },
    "latex": "\\iint f \\, d(\\mu \\times \\nu) = \\int\\left(\\int f(x,y) \\, d\\nu(y)\\right) d\\mu(x)",
    "relations": {
      "prerequisites": ["lebesgue-integral", "product-measure"],
      "nextTopics": ["tonelli-theorem"],
      "related": ["double-integral"],
      "applications": ["multivariable-calculus"]
    },
    "tags": ["푸비니", "Fubini", "이중적분", "iterated"]
  },
  {
    "id": "dominated-convergence",
    "name": { "ko": "지배 수렴 정리", "en": "Dominated Convergence Theorem" },
    "field": "measure-theory",
    "subfield": "convergence",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "적분 가능한 함수에 의해 지배되는 함수열의 극한과 적분을 교환",
        "formulas": ["조건: |f_n| ≤ g, ∫g < ∞", "결론: lim∫f_n = ∫lim f_n", "즉: ∫f = lim∫f_n"],
        "examples": ["점별 수렴 함수열", "파라미터 적분의 미분"],
        "applications": ["극한-적분 교환", "확률론"]
      },
      "en": {
        "definition": "Exchange limit and integral for functions dominated by an integrable function",
        "formulas": [
          "Condition: |f_n| ≤ g, ∫g < ∞",
          "Conclusion: lim∫f_n = ∫lim f_n",
          "i.e.: ∫f = lim∫f_n"
        ],
        "examples": ["Pointwise convergent sequences", "Differentiation under integral"],
        "applications": ["Limit-integral exchange", "Probability"]
      }
    },
    "latex": "\\lim_{n \\to \\infty} \\int f_n \\, d\\mu = \\int \\lim_{n \\to \\infty} f_n \\, d\\mu",
    "relations": {
      "prerequisites": ["lebesgue-integral"],
      "nextTopics": ["bounded-convergence"],
      "related": ["monotone-convergence"],
      "applications": ["analysis", "probability"]
    },
    "tags": ["DCT", "지배수렴", "dominated", "convergence"]
  },
  {
    "id": "radon-nikodym",
    "name": { "ko": "라돈-니코딤 정리", "en": "Radon-Nikodym Theorem" },
    "field": "measure-theory",
    "subfield": "measures",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "절대연속인 측도는 다른 측도에 대한 적분으로 표현 가능",
        "formulas": ["ν ≪ μ ⟺ ∃f: ν(A) = ∫_A f dμ", "f = dν/dμ (라돈-니코딤 도함수)"],
        "examples": ["확률밀도함수", "조건부 기댓값"],
        "applications": ["확률론", "통계역학", "함수해석"]
      },
      "en": {
        "definition": "Absolutely continuous measure can be expressed as integral w.r.t. another measure",
        "formulas": ["ν ≪ μ ⟺ ∃f: ν(A) = ∫_A f dμ", "f = dν/dμ (Radon-Nikodym derivative)"],
        "examples": ["Probability density function", "Conditional expectation"],
        "applications": ["Probability", "Statistical mechanics", "Functional analysis"]
      }
    },
    "latex": "\\nu(A) = \\int_A \\frac{d\\nu}{d\\mu} \\, d\\mu",
    "relations": {
      "prerequisites": ["lebesgue-integral", "absolute-continuity"],
      "nextTopics": ["conditional-expectation"],
      "related": ["probability-density"],
      "applications": ["bayesian-inference"]
    },
    "tags": ["라돈니코딤", "Radon-Nikodym", "도함수", "derivative"]
  },
  {
    "id": "lp-spaces",
    "name": { "ko": "Lᵖ 공간", "en": "Lᵖ Spaces" },
    "field": "measure-theory",
    "subfield": "function-spaces",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "p승 적분 가능한 함수들의 바나흐 공간",
        "formulas": [
          "||f||_p = (∫|f|^p dμ)^{1/p}",
          "L^∞: ||f||_∞ = ess sup |f|",
          "횔더: ||fg||_1 ≤ ||f||_p||g||_q (1/p+1/q=1)"
        ],
        "examples": ["L²(ℝ): 제곱적분 가능", "L^∞: 본질적 유계"],
        "applications": ["푸리에 해석", "양자역학", "PDE"]
      },
      "en": {
        "definition": "Banach space of p-power integrable functions",
        "formulas": [
          "||f||_p = (∫|f|^p dμ)^{1/p}",
          "L^∞: ||f||_∞ = ess sup |f|",
          "Hölder: ||fg||_1 ≤ ||f||_p||g||_q (1/p+1/q=1)"
        ],
        "examples": ["L²(ℝ): square integrable", "L^∞: essentially bounded"],
        "applications": ["Fourier analysis", "Quantum mechanics", "PDEs"]
      }
    },
    "latex": "\\|f\\|_p = \\left(\\int |f|^p \\, d\\mu\\right)^{1/p}",
    "relations": {
      "prerequisites": ["lebesgue-integral", "normed-space"],
      "nextTopics": ["hilbert-space", "dual-space"],
      "related": ["banach-space"],
      "applications": ["functional-analysis"]
    },
    "tags": ["Lp", "함수공간", "Banach", "norm"]
  },
  {
    "id": "category-definition",
    "name": { "ko": "범주의 정의", "en": "Category Definition" },
    "field": "category-theory",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "대상(objects)과 사상(morphisms)으로 구성된 수학적 구조",
        "formulas": [
          "대상: Ob(C)",
          "사상: Hom(A,B)",
          "합성: g∘f: A→C (f:A→B, g:B→C)",
          "항등: id_A: A→A"
        ],
        "examples": ["Set (집합과 함수)", "Grp (군과 준동형)", "Top (위상공간과 연속함수)"],
        "applications": ["대수학 통합", "컴퓨터 과학", "물리학"]
      },
      "en": {
        "definition": "Mathematical structure consisting of objects and morphisms",
        "formulas": [
          "Objects: Ob(C)",
          "Morphisms: Hom(A,B)",
          "Composition: g∘f: A→C (f:A→B, g:B→C)",
          "Identity: id_A: A→A"
        ],
        "examples": [
          "Set (sets and functions)",
          "Grp (groups and homomorphisms)",
          "Top (topological spaces and continuous maps)"
        ],
        "applications": ["Unifying algebra", "Computer science", "Physics"]
      }
    },
    "latex": "g \\circ f: A \\to C",
    "relations": {
      "prerequisites": ["set-theory", "group-theory"],
      "nextTopics": ["functor", "natural-transformation"],
      "related": ["abstract-algebra"],
      "applications": ["programming-languages"]
    },
    "tags": ["범주", "category", "사상", "morphism"]
  },
  {
    "id": "functor",
    "name": { "ko": "함자", "en": "Functor" },
    "field": "category-theory",
    "subfield": "mappings",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "범주 사이의 구조를 보존하는 사상",
        "formulas": ["F: C → D", "F(f∘g) = F(f)∘F(g)", "F(id_A) = id_{F(A)}"],
        "examples": ["망각 함자 (Forgetful)", "자유 함자 (Free)", "홈 함자 Hom(A,-)"],
        "applications": ["프로그래밍 (map)", "대수적 위상", "함수형 프로그래밍"]
      },
      "en": {
        "definition": "Structure-preserving map between categories",
        "formulas": ["F: C → D", "F(f∘g) = F(f)∘F(g)", "F(id_A) = id_{F(A)}"],
        "examples": ["Forgetful functor", "Free functor", "Hom functor Hom(A,-)"],
        "applications": ["Programming (map)", "Algebraic topology", "Functional programming"]
      }
    },
    "latex": "F(g \\circ f) = F(g) \\circ F(f)",
    "relations": {
      "prerequisites": ["category-definition"],
      "nextTopics": ["natural-transformation", "adjunction"],
      "related": ["homomorphism"],
      "applications": ["haskell", "scala"]
    },
    "tags": ["함자", "functor", "사상", "mapping"]
  },
  {
    "id": "natural-transformation",
    "name": { "ko": "자연 변환", "en": "Natural Transformation" },
    "field": "category-theory",
    "subfield": "mappings",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "두 함자 사이의 \"자연스러운\" 사상 모음",
        "formulas": [
          "η: F ⇒ G",
          "자연성: G(f)∘η_A = η_B∘F(f)",
          "모든 f:A→B에 대해 다이어그램 가환"
        ],
        "examples": ["항등 자연변환", "η: Id ⇒ List (단위원)", "det: GL_n ⇒ GL_1"],
        "applications": ["모나드", "동형 이론", "언어 의미론"]
      },
      "en": {
        "definition": "Collection of \"natural\" morphisms between two functors",
        "formulas": [
          "η: F ⇒ G",
          "Naturality: G(f)∘η_A = η_B∘F(f)",
          "Diagram commutes for all f:A→B"
        ],
        "examples": ["Identity natural transformation", "η: Id ⇒ List (unit)", "det: GL_n ⇒ GL_1"],
        "applications": ["Monads", "Equivalence theory", "Semantics"]
      }
    },
    "latex": "G(f) \\circ \\eta_A = \\eta_B \\circ F(f)",
    "relations": {
      "prerequisites": ["functor"],
      "nextTopics": ["yoneda-lemma", "monad"],
      "related": ["isomorphism"],
      "applications": ["type-theory"]
    },
    "tags": ["자연변환", "natural", "transformation", "functor"]
  },
  {
    "id": "monad-category",
    "name": { "ko": "모나드", "en": "Monad" },
    "field": "category-theory",
    "subfield": "structures",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "자기함자와 두 자연변환으로 이루어진 삼중쌍",
        "formulas": [
          "(T, η, μ)",
          "T: C → C",
          "η: Id ⇒ T (unit)",
          "μ: T² ⇒ T (join)",
          "결합법칙, 단위법칙"
        ],
        "examples": ["List 모나드", "Maybe/Option 모나드", "State 모나드"],
        "applications": ["함수형 프로그래밍", "부작용 처리", "IO"]
      },
      "en": {
        "definition": "Triple of endofunctor and two natural transformations",
        "formulas": [
          "(T, η, μ)",
          "T: C → C",
          "η: Id ⇒ T (unit)",
          "μ: T² ⇒ T (join)",
          "Associativity, unit laws"
        ],
        "examples": ["List monad", "Maybe/Option monad", "State monad"],
        "applications": ["Functional programming", "Effect handling", "IO"]
      }
    },
    "latex": "\\mu \\circ T\\mu = \\mu \\circ \\mu T",
    "relations": {
      "prerequisites": ["functor", "natural-transformation"],
      "nextTopics": ["kleisli-category", "comonad"],
      "related": ["adjunction"],
      "applications": ["haskell", "effect-systems"]
    },
    "tags": ["모나드", "monad", "함수형", "functional"]
  },
  {
    "id": "adjunction",
    "name": { "ko": "수반", "en": "Adjunction" },
    "field": "category-theory",
    "subfield": "structures",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "두 함자 사이의 특별한 관계. 범주론의 핵심 개념",
        "formulas": ["F ⊣ G", "Hom_D(F(A), B) ≅ Hom_C(A, G(B))", "자연성: 양 변수에서 자연"],
        "examples": ["자유-망각 수반", "곱-대각 수반", "극한-상수함자 수반"],
        "applications": ["보편 성질", "자유 대수", "극한/쌍대극한"]
      },
      "en": {
        "definition": "Special relationship between two functors. Central concept in category theory",
        "formulas": [
          "F ⊣ G",
          "Hom_D(F(A), B) ≅ Hom_C(A, G(B))",
          "Naturality: natural in both arguments"
        ],
        "examples": [
          "Free-Forgetful adjunction",
          "Product-Diagonal adjunction",
          "Limit-Constant adjunction"
        ],
        "applications": ["Universal properties", "Free algebras", "Limits/colimits"]
      }
    },
    "latex": "\\text{Hom}_D(F(A), B) \\cong \\text{Hom}_C(A, G(B))",
    "relations": {
      "prerequisites": ["functor", "natural-transformation"],
      "nextTopics": ["monad-category"],
      "related": ["universal-property"],
      "applications": ["algebra", "logic"]
    },
    "tags": ["수반", "adjunction", "adjoint", "functor"]
  },
  {
    "id": "yoneda-lemma",
    "name": { "ko": "요네다 보조정리", "en": "Yoneda Lemma" },
    "field": "category-theory",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "표현가능 함자와 자연변환 사이의 동형을 밝히는 핵심 정리",
        "formulas": ["Nat(Hom(A,-), F) ≅ F(A)", "요네다 임베딩: C → Set^{C^op}", "y: A ↦ Hom(-,A)"],
        "examples": ["모든 자연변환은 원소로 결정", "역변환: η ↦ η_A(id_A)"],
        "applications": ["표현가능성 이론", "프리쉬프", "고차 범주"]
      },
      "en": {
        "definition": "Key lemma establishing isomorphism between representable functors and natural transformations",
        "formulas": [
          "Nat(Hom(A,-), F) ≅ F(A)",
          "Yoneda embedding: C → Set^{C^op}",
          "y: A ↦ Hom(-,A)"
        ],
        "examples": [
          "Every natural transformation determined by element",
          "Inverse: η ↦ η_A(id_A)"
        ],
        "applications": ["Representability theory", "Presheaves", "Higher categories"]
      }
    },
    "latex": "\\text{Nat}(\\text{Hom}(A,-), F) \\cong F(A)",
    "relations": {
      "prerequisites": ["functor", "natural-transformation"],
      "nextTopics": ["representable-functor", "presheaf"],
      "related": ["adjunction"],
      "applications": ["topos-theory"]
    },
    "tags": ["요네다", "Yoneda", "보조정리", "lemma"]
  },
  {
    "id": "limits-colimits",
    "name": { "ko": "극한과 쌍대극한", "en": "Limits and Colimits" },
    "field": "category-theory",
    "subfield": "constructions",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "범주에서 다이어그램의 \"가장 좋은\" 근사. 곱, 등화자, 당김 등의 일반화",
        "formulas": [
          "극한: lim F = 보편 뿔",
          "쌍대극한: colim F = 보편 공뿔",
          "Hom(X, lim F) ≅ lim Hom(X, F(-))"
        ],
        "examples": [
          "곱/쌍곱 (Product/Coproduct)",
          "등화자/쌍등화자",
          "당김/밀어내기 (Pullback/Pushout)"
        ],
        "applications": ["대수적 구성", "호몰로지", "타입 이론"]
      },
      "en": {
        "definition": "\"Best\" approximations of diagrams in categories. Generalizes products, equalizers, pullbacks",
        "formulas": [
          "Limit: lim F = universal cone",
          "Colimit: colim F = universal cocone",
          "Hom(X, lim F) ≅ lim Hom(X, F(-))"
        ],
        "examples": ["Product/Coproduct", "Equalizer/Coequalizer", "Pullback/Pushout"],
        "applications": ["Algebraic constructions", "Homology", "Type theory"]
      }
    },
    "latex": "\\text{Hom}(X, \\lim F) \\cong \\lim \\text{Hom}(X, F(-))",
    "relations": {
      "prerequisites": ["category-definition", "functor"],
      "nextTopics": ["kan-extension"],
      "related": ["adjunction"],
      "applications": ["homological-algebra"]
    },
    "tags": ["극한", "limit", "colimit", "universal"]
  },
  {
    "id": "topos",
    "name": { "ko": "토포스", "en": "Topos" },
    "field": "category-theory",
    "subfield": "advanced",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "집합의 범주와 유사한 성질을 가진 범주. 논리와 기하의 통합",
        "formulas": ["유한 극한 존재", "지수 대상 존재", "부분대상 분류자 Ω 존재"],
        "examples": ["Set (집합 범주)", "Sh(X) (층의 범주)", "Grph (유방향 그래프)"],
        "applications": ["논리학", "대수기하학", "호모토피 타입 이론"]
      },
      "en": {
        "definition": "Category with properties similar to Set. Unifies logic and geometry",
        "formulas": ["Has finite limits", "Has exponential objects", "Has subobject classifier Ω"],
        "examples": ["Set (category of sets)", "Sh(X) (sheaves)", "Grph (directed graphs)"],
        "applications": ["Logic", "Algebraic geometry", "Homotopy type theory"]
      }
    },
    "latex": "\\Omega: 1 \\to \\Omega",
    "relations": {
      "prerequisites": ["category-definition", "limits-colimits"],
      "nextTopics": ["higher-topos"],
      "related": ["logic", "set-theory"],
      "applications": ["foundations", "geometry"]
    },
    "tags": ["토포스", "topos", "논리", "logic"]
  },
  {
    "id": "manifold",
    "name": { "ko": "다양체", "en": "Manifold" },
    "field": "differential-geometry",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "국소적으로 유클리드 공간과 닮은 위상공간. 곡면의 일반화",
        "formulas": [
          "좌표계: (U, φ), φ: U → ℝⁿ",
          "전이함수: φ_β ∘ φ_α⁻¹",
          "C^k 다양체: 전이함수가 k번 미분가능"
        ],
        "examples": ["ℝⁿ", "구면 S²", "토러스 T²", "사영공간 ℝP^n"],
        "applications": ["물리학", "로봇공학", "데이터 분석"]
      },
      "en": {
        "definition": "Topological space locally resembling Euclidean space. Generalization of surfaces",
        "formulas": [
          "Charts: (U, φ), φ: U → ℝⁿ",
          "Transition: φ_β ∘ φ_α⁻¹",
          "C^k manifold: transitions k-times differentiable"
        ],
        "examples": ["ℝⁿ", "Sphere S²", "Torus T²", "Projective space ℝP^n"],
        "applications": ["Physics", "Robotics", "Data analysis"]
      }
    },
    "latex": "\\phi_\\beta \\circ \\phi_\\alpha^{-1}: \\phi_\\alpha(U_\\alpha \\cap U_\\beta) \\to \\phi_\\beta(U_\\alpha \\cap U_\\beta)",
    "relations": {
      "prerequisites": ["topology", "multivariable-calculus"],
      "nextTopics": ["tangent-space", "riemannian-metric"],
      "related": ["surface"],
      "applications": ["general-relativity", "machine-learning"]
    },
    "tags": ["다양체", "manifold", "미분기하", "topology"]
  },
  {
    "id": "tangent-space",
    "name": { "ko": "접공간", "en": "Tangent Space" },
    "field": "differential-geometry",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "다양체의 한 점에서 가능한 모든 \"방향\"들의 벡터공간",
        "formulas": ["T_p M = {γ'(0) : γ(0) = p}", "차원: dim T_p M = dim M", "기저: ∂/∂x^i |_p"],
        "examples": ["평면의 접공간 = ℝ²", "구면의 접평면"],
        "applications": ["벡터장", "미분형식", "물리학"]
      },
      "en": {
        "definition": "Vector space of all possible \"directions\" at a point on manifold",
        "formulas": [
          "T_p M = {γ'(0) : γ(0) = p}",
          "Dimension: dim T_p M = dim M",
          "Basis: ∂/∂x^i |_p"
        ],
        "examples": ["Tangent space of plane = ℝ²", "Tangent plane of sphere"],
        "applications": ["Vector fields", "Differential forms", "Physics"]
      }
    },
    "latex": "T_p M = \\{\\gamma'(0) : \\gamma(0) = p\\}",
    "relations": {
      "prerequisites": ["manifold", "linear-algebra"],
      "nextTopics": ["tangent-bundle", "vector-field"],
      "related": ["derivative"],
      "applications": ["mechanics", "optimization"]
    },
    "tags": ["접공간", "tangent", "vector", "manifold"]
  },
  {
    "id": "riemannian-metric",
    "name": { "ko": "리만 계량", "en": "Riemannian Metric" },
    "field": "differential-geometry",
    "subfield": "riemannian",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "다양체의 각 점에서 접벡터 사이의 내적을 부여하는 구조",
        "formulas": [
          "g: T_p M × T_p M → ℝ",
          "ds² = g_{ij} dx^i dx^j",
          "길이: L(γ) = ∫√(g_{ij} γ̇^i γ̇^j) dt"
        ],
        "examples": ["유클리드 계량: g_{ij} = δ_{ij}", "구면 계량: ds² = dθ² + sin²θ dφ²"],
        "applications": ["일반상대성이론", "측지선", "곡률"]
      },
      "en": {
        "definition": "Structure assigning inner product on tangent vectors at each point",
        "formulas": [
          "g: T_p M × T_p M → ℝ",
          "ds² = g_{ij} dx^i dx^j",
          "Length: L(γ) = ∫√(g_{ij} γ̇^i γ̇^j) dt"
        ],
        "examples": ["Euclidean metric: g_{ij} = δ_{ij}", "Sphere metric: ds² = dθ² + sin²θ dφ²"],
        "applications": ["General relativity", "Geodesics", "Curvature"]
      }
    },
    "latex": "ds^2 = g_{ij} dx^i dx^j",
    "relations": {
      "prerequisites": ["manifold", "tangent-space", "inner-product"],
      "nextTopics": ["geodesic", "curvature-tensor"],
      "related": ["metric-space"],
      "applications": ["physics", "geometry"]
    },
    "tags": ["리만", "Riemannian", "계량", "metric"]
  },
  {
    "id": "geodesic",
    "name": { "ko": "측지선", "en": "Geodesic" },
    "field": "differential-geometry",
    "subfield": "riemannian",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "곡면이나 다양체에서 두 점 사이의 최단 경로",
        "formulas": [
          "측지선 방정식: d²x^k/dt² + Γ^k_{ij} dx^i/dt dx^j/dt = 0",
          "크리스토펠 기호: Γ^k_{ij}"
        ],
        "examples": ["평면의 직선", "구면의 대원", "쌍곡면의 호"],
        "applications": ["항공 경로", "일반상대성이론", "컴퓨터 그래픽스"]
      },
      "en": {
        "definition": "Shortest path between two points on a surface or manifold",
        "formulas": [
          "Geodesic equation: d²x^k/dt² + Γ^k_{ij} dx^i/dt dx^j/dt = 0",
          "Christoffel symbols: Γ^k_{ij}"
        ],
        "examples": ["Straight lines on plane", "Great circles on sphere", "Arcs on hyperboloid"],
        "applications": ["Flight paths", "General relativity", "Computer graphics"]
      }
    },
    "latex": "\\frac{d^2 x^k}{dt^2} + \\Gamma^k_{ij} \\frac{dx^i}{dt} \\frac{dx^j}{dt} = 0",
    "relations": {
      "prerequisites": ["riemannian-metric"],
      "nextTopics": ["exponential-map", "curvature-tensor"],
      "related": ["shortest-path"],
      "applications": ["navigation", "physics"]
    },
    "tags": ["측지선", "geodesic", "최단경로", "shortest"]
  },
  {
    "id": "curvature-tensor",
    "name": { "ko": "곡률 텐서", "en": "Curvature Tensor" },
    "field": "differential-geometry",
    "subfield": "riemannian",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "다양체의 곡률을 측정하는 텐서. 공간이 평평한지 휜지 나타냄",
        "formulas": [
          "리만 곡률: R^ρ_{σμν}",
          "리치 곡률: R_{μν} = R^ρ_{μρν}",
          "스칼라 곡률: R = g^{μν}R_{μν}"
        ],
        "examples": ["평면: R = 0", "구면: R = 2/r²", "쌍곡면: R < 0"],
        "applications": ["일반상대성이론", "우주론", "기하학"]
      },
      "en": {
        "definition": "Tensor measuring curvature of manifold. Indicates if space is flat or curved",
        "formulas": [
          "Riemann curvature: R^ρ_{σμν}",
          "Ricci curvature: R_{μν} = R^ρ_{μρν}",
          "Scalar curvature: R = g^{μν}R_{μν}"
        ],
        "examples": ["Plane: R = 0", "Sphere: R = 2/r²", "Hyperboloid: R < 0"],
        "applications": ["General relativity", "Cosmology", "Geometry"]
      }
    },
    "latex": "R^\\rho_{\\sigma\\mu\\nu} = \\partial_\\mu \\Gamma^\\rho_{\\nu\\sigma} - \\partial_\\nu \\Gamma^\\rho_{\\mu\\sigma} + \\Gamma^\\rho_{\\mu\\lambda}\\Gamma^\\lambda_{\\nu\\sigma} - \\Gamma^\\rho_{\\nu\\lambda}\\Gamma^\\lambda_{\\mu\\sigma}",
    "relations": {
      "prerequisites": ["riemannian-metric", "geodesic"],
      "nextTopics": ["einstein-field-equations"],
      "related": ["gaussian-curvature"],
      "applications": ["general-relativity"]
    },
    "tags": ["곡률", "curvature", "리만", "Riemann"]
  },
  {
    "id": "differential-forms",
    "name": { "ko": "미분형식", "en": "Differential Forms" },
    "field": "differential-geometry",
    "subfield": "calculus",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "적분을 좌표에 무관하게 정의할 수 있는 반대칭 텐서장",
        "formulas": [
          "0-형식: f",
          "1-형식: ω = f_i dx^i",
          "2-형식: ω = f_{ij} dx^i ∧ dx^j",
          "외미분: d"
        ],
        "examples": ["dx, dy, dz", "x dy - y dx", "dx ∧ dy"],
        "applications": ["스토크스 정리", "전자기학", "드람 코호몰로지"]
      },
      "en": {
        "definition": "Antisymmetric tensor fields enabling coordinate-free integration",
        "formulas": [
          "0-form: f",
          "1-form: ω = f_i dx^i",
          "2-form: ω = f_{ij} dx^i ∧ dx^j",
          "Exterior derivative: d"
        ],
        "examples": ["dx, dy, dz", "x dy - y dx", "dx ∧ dy"],
        "applications": ["Stokes theorem", "Electromagnetism", "de Rham cohomology"]
      }
    },
    "latex": "d\\omega = \\sum_i \\frac{\\partial \\omega}{\\partial x^i} dx^i \\wedge \\omega",
    "relations": {
      "prerequisites": ["manifold", "multivariable-calculus"],
      "nextTopics": ["de-rham-cohomology", "stokes-theorem"],
      "related": ["vectors", "integration"],
      "applications": ["physics", "topology"]
    },
    "tags": ["미분형식", "differential", "forms", "exterior"]
  },
  {
    "id": "lie-groups",
    "name": { "ko": "리 군", "en": "Lie Groups" },
    "field": "differential-geometry",
    "subfield": "groups",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "군이면서 동시에 미분 다양체인 구조. 연속적인 대칭을 기술",
        "formulas": [
          "군 연산: (g,h) ↦ gh, g ↦ g⁻¹ 가 매끄러움",
          "리 대수: T_e G",
          "[X,Y] = XY - YX"
        ],
        "examples": ["GL(n,ℝ)", "SO(n)", "SU(n)", "SL(n,ℝ)"],
        "applications": ["물리학 대칭", "미분방정식", "양자역학"]
      },
      "en": {
        "definition": "Structure that is both a group and differentiable manifold. Describes continuous symmetries",
        "formulas": [
          "Group ops: (g,h) ↦ gh, g ↦ g⁻¹ are smooth",
          "Lie algebra: T_e G",
          "[X,Y] = XY - YX"
        ],
        "examples": ["GL(n,ℝ)", "SO(n)", "SU(n)", "SL(n,ℝ)"],
        "applications": ["Physics symmetry", "Differential equations", "Quantum mechanics"]
      }
    },
    "latex": "[X, Y] = XY - YX",
    "relations": {
      "prerequisites": ["group-theory", "manifold"],
      "nextTopics": ["lie-algebra", "representation-theory"],
      "related": ["symmetry"],
      "applications": ["particle-physics", "robotics"]
    },
    "tags": ["리군", "Lie", "group", "symmetry"]
  },
  {
    "id": "gaussian-curvature",
    "name": { "ko": "가우스 곡률", "en": "Gaussian Curvature" },
    "field": "differential-geometry",
    "subfield": "surfaces",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "곡면의 내재적 곡률. 두 주곡률의 곱",
        "formulas": ["K = κ₁ · κ₂", "가우스-보네: ∫∫_S K dA = 2πχ(S)", "K = (LN - M²)/(EG - F²)"],
        "examples": ["평면: K = 0", "구면: K = 1/r²", "안장: K < 0"],
        "applications": ["지도 제작", "곡면 분류", "토폴로지"]
      },
      "en": {
        "definition": "Intrinsic curvature of surface. Product of principal curvatures",
        "formulas": ["K = κ₁ · κ₂", "Gauss-Bonnet: ∫∫_S K dA = 2πχ(S)", "K = (LN - M²)/(EG - F²)"],
        "examples": ["Plane: K = 0", "Sphere: K = 1/r²", "Saddle: K < 0"],
        "applications": ["Cartography", "Surface classification", "Topology"]
      }
    },
    "latex": "K = \\kappa_1 \\cdot \\kappa_2",
    "relations": {
      "prerequisites": ["surface", "curvature"],
      "nextTopics": ["gauss-bonnet-theorem"],
      "related": ["mean-curvature"],
      "applications": ["computer-graphics", "physics"]
    },
    "tags": ["가우스", "Gaussian", "곡률", "curvature"]
  },
  {
    "id": "hypothesis-testing",
    "name": { "ko": "가설검정", "en": "Hypothesis Testing" },
    "field": "statistics",
    "subfield": "inference",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "표본 데이터를 사용하여 모집단에 대한 가설의 타당성을 검증하는 통계적 방법",
        "formulas": [
          "귀무가설 H₀ vs 대립가설 H₁",
          "검정통계량 T",
          "p-value = P(T ≥ t | H₀)",
          "유의수준 α (보통 0.05)"
        ],
        "examples": ["t-검정", "χ²-검정", "F-검정"],
        "applications": ["의학 연구", "품질 관리", "A/B 테스트"]
      },
      "en": {
        "definition": "Statistical method to test validity of hypotheses about population using sample data",
        "formulas": [
          "Null H₀ vs Alternative H₁",
          "Test statistic T",
          "p-value = P(T ≥ t | H₀)",
          "Significance level α (usually 0.05)"
        ],
        "examples": ["t-test", "χ²-test", "F-test"],
        "applications": ["Medical research", "Quality control", "A/B testing"]
      }
    },
    "latex": "p\\text{-value} = P(T \\geq t | H_0)",
    "relations": {
      "prerequisites": ["probability", "normal-distribution"],
      "nextTopics": ["confidence-interval", "anova"],
      "related": ["central-limit-theorem"],
      "applications": ["research", "data-science"]
    },
    "tags": ["가설검정", "hypothesis", "p-value", "inference"]
  },
  {
    "id": "confidence-interval",
    "name": { "ko": "신뢰구간", "en": "Confidence Interval" },
    "field": "statistics",
    "subfield": "inference",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "모수가 포함될 것으로 예상되는 값의 범위. 95% 신뢰구간은 반복 표본에서 95%가 참값 포함",
        "formulas": [
          "평균의 CI: x̄ ± z_{α/2} · σ/√n",
          "t-CI: x̄ ± t_{α/2,n-1} · s/√n",
          "비율의 CI: p̂ ± z_{α/2}√(p̂(1-p̂)/n)"
        ],
        "examples": ["95% CI for μ", "99% CI for proportion"],
        "applications": ["여론조사", "의학 연구", "품질 추정"]
      },
      "en": {
        "definition": "Range of values expected to contain parameter. 95% CI means 95% of repeated samples contain true value",
        "formulas": [
          "Mean CI: x̄ ± z_{α/2} · σ/√n",
          "t-CI: x̄ ± t_{α/2,n-1} · s/√n",
          "Proportion CI: p̂ ± z_{α/2}√(p̂(1-p̂)/n)"
        ],
        "examples": ["95% CI for μ", "99% CI for proportion"],
        "applications": ["Polling", "Medical research", "Quality estimation"]
      }
    },
    "latex": "\\bar{x} \\pm z_{\\alpha/2} \\cdot \\frac{\\sigma}{\\sqrt{n}}",
    "relations": {
      "prerequisites": ["sampling-distribution", "normal-distribution"],
      "nextTopics": ["hypothesis-testing"],
      "related": ["central-limit-theorem"],
      "applications": ["estimation", "research"]
    },
    "tags": ["신뢰구간", "confidence", "interval", "estimation"]
  },
  {
    "id": "regression-analysis",
    "name": { "ko": "회귀분석", "en": "Regression Analysis" },
    "field": "statistics",
    "subfield": "modeling",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "변수들 간의 관계를 모델링하고 예측하는 통계적 방법",
        "formulas": [
          "단순선형: y = β₀ + β₁x + ε",
          "다중선형: y = β₀ + Σβᵢxᵢ + ε",
          "OLS: min Σ(yᵢ - ŷᵢ)²",
          "R²: 결정계수"
        ],
        "examples": ["주가 예측", "매출 분석", "의료 예후"],
        "applications": ["경제학", "마케팅", "과학 연구"]
      },
      "en": {
        "definition": "Statistical method for modeling and predicting relationships between variables",
        "formulas": [
          "Simple linear: y = β₀ + β₁x + ε",
          "Multiple: y = β₀ + Σβᵢxᵢ + ε",
          "OLS: min Σ(yᵢ - ŷᵢ)²",
          "R²: coefficient of determination"
        ],
        "examples": ["Stock prediction", "Sales analysis", "Medical prognosis"],
        "applications": ["Economics", "Marketing", "Scientific research"]
      }
    },
    "latex": "y = \\beta_0 + \\beta_1 x + \\epsilon",
    "relations": {
      "prerequisites": ["correlation", "linear-algebra"],
      "nextTopics": ["logistic-regression", "anova"],
      "related": ["least-squares"],
      "applications": ["prediction", "inference"]
    },
    "tags": ["회귀", "regression", "prediction", "modeling"]
  },
  {
    "id": "anova",
    "name": { "ko": "분산분석 (ANOVA)", "en": "Analysis of Variance (ANOVA)" },
    "field": "statistics",
    "subfield": "inference",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "세 개 이상 그룹의 평균 차이를 검정하는 방법. 집단 간/내 분산 비교",
        "formulas": [
          "F = MS_between / MS_within",
          "SS_total = SS_between + SS_within",
          "df_between = k-1, df_within = N-k"
        ],
        "examples": ["약물 효과 비교", "교수법 효과", "제품 품질 비교"],
        "applications": ["실험 설계", "의학", "심리학"]
      },
      "en": {
        "definition": "Method for testing mean differences among three or more groups. Compares between/within variance",
        "formulas": [
          "F = MS_between / MS_within",
          "SS_total = SS_between + SS_within",
          "df_between = k-1, df_within = N-k"
        ],
        "examples": [
          "Drug efficacy comparison",
          "Teaching method effects",
          "Product quality comparison"
        ],
        "applications": ["Experimental design", "Medicine", "Psychology"]
      }
    },
    "latex": "F = \\frac{MS_{between}}{MS_{within}}",
    "relations": {
      "prerequisites": ["hypothesis-testing", "variance"],
      "nextTopics": ["manova", "post-hoc-tests"],
      "related": ["t-test"],
      "applications": ["experimental-research"]
    },
    "tags": ["ANOVA", "분산분석", "F-test", "comparison"]
  },
  {
    "id": "bayesian-inference",
    "name": { "ko": "베이지안 추론", "en": "Bayesian Inference" },
    "field": "statistics",
    "subfield": "bayesian",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "사전 지식과 데이터를 결합하여 사후 확률을 계산하는 통계적 추론 방법",
        "formulas": [
          "P(θ|data) ∝ P(data|θ) · P(θ)",
          "사후 ∝ 가능도 × 사전",
          "베이즈 인자: BF = P(data|M₁)/P(data|M₂)"
        ],
        "examples": ["스팸 필터", "의료 진단", "추천 시스템"],
        "applications": ["기계학습", "의사결정", "A/B 테스트"]
      },
      "en": {
        "definition": "Statistical inference combining prior knowledge with data to compute posterior probability",
        "formulas": [
          "P(θ|data) ∝ P(data|θ) · P(θ)",
          "Posterior ∝ Likelihood × Prior",
          "Bayes factor: BF = P(data|M₁)/P(data|M₂)"
        ],
        "examples": ["Spam filter", "Medical diagnosis", "Recommendation systems"],
        "applications": ["Machine learning", "Decision making", "A/B testing"]
      }
    },
    "latex": "P(\\theta|\\text{data}) \\propto P(\\text{data}|\\theta) \\cdot P(\\theta)",
    "relations": {
      "prerequisites": ["bayes-theorem", "probability"],
      "nextTopics": ["mcmc", "conjugate-priors"],
      "related": ["maximum-likelihood"],
      "applications": ["machine-learning", "statistics"]
    },
    "tags": ["베이지안", "Bayesian", "사후확률", "inference"]
  },
  {
    "id": "maximum-likelihood",
    "name": { "ko": "최대가능도 추정", "en": "Maximum Likelihood Estimation" },
    "field": "statistics",
    "subfield": "estimation",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "관측된 데이터를 가장 잘 설명하는 모수를 찾는 추정 방법",
        "formulas": [
          "가능도: L(θ) = P(data|θ) = ∏P(xᵢ|θ)",
          "로그가능도: ℓ(θ) = Σlog P(xᵢ|θ)",
          "MLE: θ̂ = argmax L(θ)"
        ],
        "examples": ["정규분포 MLE: μ̂=x̄, σ̂²=s²", "베르누이 MLE: p̂ = x̄"],
        "applications": ["모수 추정", "기계학습", "통계 모델링"]
      },
      "en": {
        "definition": "Estimation method finding parameters that best explain observed data",
        "formulas": [
          "Likelihood: L(θ) = P(data|θ) = ∏P(xᵢ|θ)",
          "Log-likelihood: ℓ(θ) = Σlog P(xᵢ|θ)",
          "MLE: θ̂ = argmax L(θ)"
        ],
        "examples": ["Normal MLE: μ̂=x̄, σ̂²=s²", "Bernoulli MLE: p̂ = x̄"],
        "applications": ["Parameter estimation", "Machine learning", "Statistical modeling"]
      }
    },
    "latex": "\\hat{\\theta} = \\arg\\max_\\theta L(\\theta)",
    "relations": {
      "prerequisites": ["probability", "calculus"],
      "nextTopics": ["bayesian-inference", "em-algorithm"],
      "related": ["least-squares"],
      "applications": ["estimation", "machine-learning"]
    },
    "tags": ["MLE", "최대가능도", "likelihood", "estimation"]
  },
  {
    "id": "time-series",
    "name": { "ko": "시계열 분석", "en": "Time Series Analysis" },
    "field": "statistics",
    "subfield": "modeling",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "시간에 따라 관측된 데이터의 패턴을 분석하고 예측하는 방법",
        "formulas": [
          "AR(p): Xₜ = Σφᵢ Xₜ₋ᵢ + εₜ",
          "MA(q): Xₜ = εₜ + Σθⱼ εₜ₋ⱼ",
          "ARIMA(p,d,q)",
          "정상성: E[Xₜ], Var[Xₜ] 일정"
        ],
        "examples": ["주가 예측", "기온 예측", "수요 예측"],
        "applications": ["금융", "기상학", "경제학"]
      },
      "en": {
        "definition": "Methods for analyzing patterns and forecasting data observed over time",
        "formulas": [
          "AR(p): Xₜ = Σφᵢ Xₜ₋ᵢ + εₜ",
          "MA(q): Xₜ = εₜ + Σθⱼ εₜ₋ⱼ",
          "ARIMA(p,d,q)",
          "Stationarity: E[Xₜ], Var[Xₜ] constant"
        ],
        "examples": ["Stock forecasting", "Temperature prediction", "Demand forecasting"],
        "applications": ["Finance", "Meteorology", "Economics"]
      }
    },
    "latex": "X_t = \\sum_{i=1}^{p} \\phi_i X_{t-i} + \\epsilon_t",
    "relations": {
      "prerequisites": ["regression-analysis", "stochastic-processes"],
      "nextTopics": ["garch", "state-space-model"],
      "related": ["forecasting"],
      "applications": ["finance", "forecasting"]
    },
    "tags": ["시계열", "time-series", "ARIMA", "forecasting"]
  },
  {
    "id": "chi-square-test",
    "name": { "ko": "카이제곱 검정", "en": "Chi-Square Test" },
    "field": "statistics",
    "subfield": "inference",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "범주형 데이터의 독립성 또는 적합도를 검정하는 비모수적 방법",
        "formulas": ["χ² = Σ(O-E)²/E", "독립성 검정: df = (r-1)(c-1)", "적합도 검정: df = k-1"],
        "examples": ["성별과 선호도 독립성", "주사위 공정성", "유전 비율"],
        "applications": ["설문조사", "품질관리", "유전학"]
      },
      "en": {
        "definition": "Non-parametric method for testing independence or goodness-of-fit of categorical data",
        "formulas": [
          "χ² = Σ(O-E)²/E",
          "Independence: df = (r-1)(c-1)",
          "Goodness-of-fit: df = k-1"
        ],
        "examples": ["Gender and preference independence", "Dice fairness", "Genetic ratios"],
        "applications": ["Surveys", "Quality control", "Genetics"]
      }
    },
    "latex": "\\chi^2 = \\sum \\frac{(O - E)^2}{E}",
    "relations": {
      "prerequisites": ["probability", "hypothesis-testing"],
      "nextTopics": ["fishers-exact-test"],
      "related": ["contingency-table"],
      "applications": ["categorical-analysis"]
    },
    "tags": ["카이제곱", "chi-square", "독립성", "goodness-of-fit"]
  },
  {
    "id": "zfc-axioms",
    "name": { "ko": "ZFC 공리계", "en": "ZFC Axioms" },
    "field": "set-theory",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "현대 수학의 표준 기초인 체르멜로-프렝켈 집합론과 선택 공리",
        "formulas": [
          "외연 공리: A=B ⟺ ∀x(x∈A ↔ x∈B)",
          "쌍 공리: ∀a∀b∃c(c={a,b})",
          "합집합 공리: ∀A∃B(B=∪A)",
          "멱집합 공리: ∀A∃B(B=P(A))",
          "무한 공리: 귀납적 집합 존재",
          "치환 공리꼴",
          "정칙성/기초 공리",
          "선택 공리(AC)"
        ],
        "examples": ["자연수 구성", "실수의 존재"],
        "applications": ["수학 기초론", "논리학", "무한 연구"]
      },
      "en": {
        "definition": "Zermelo-Fraenkel set theory with Choice - standard foundation of modern mathematics",
        "formulas": [
          "Extensionality: A=B ⟺ ∀x(x∈A ↔ x∈B)",
          "Pairing: ∀a∀b∃c(c={a,b})",
          "Union: ∀A∃B(B=∪A)",
          "Power set: ∀A∃B(B=P(A))",
          "Infinity: inductive set exists",
          "Replacement schema",
          "Regularity/Foundation",
          "Axiom of Choice (AC)"
        ],
        "examples": ["Natural number construction", "Existence of reals"],
        "applications": ["Foundations", "Logic", "Study of infinity"]
      }
    },
    "latex": "A = B \\Leftrightarrow \\forall x(x \\in A \\leftrightarrow x \\in B)",
    "relations": {
      "prerequisites": ["logic", "set-basics"],
      "nextTopics": ["ordinals", "cardinals"],
      "related": ["godel-incompleteness"],
      "applications": ["mathematics-foundations"]
    },
    "tags": ["ZFC", "공리", "axioms", "foundations"]
  },
  {
    "id": "ordinal-numbers",
    "name": { "ko": "서수", "en": "Ordinal Numbers" },
    "field": "set-theory",
    "subfield": "ordinals",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "정렬순서의 순서형을 나타내는 수. 무한 집합의 위치 개념 확장",
        "formulas": [
          "0 = ∅",
          "α+1 = α ∪ {α} (후속서수)",
          "ω = {0,1,2,...} (최초 극한서수)",
          "α < β ⟺ α ∈ β"
        ],
        "examples": ["ω+1, ω+2, ...", "ω·2 = ω+ω", "ω², ω^ω", "ε₀ = ω^ω^ω^..."],
        "applications": ["초한귀납법", "집합론", "증명론"]
      },
      "en": {
        "definition": "Numbers representing order types of well-orderings. Extension of position concept to infinite sets",
        "formulas": [
          "0 = ∅",
          "α+1 = α ∪ {α} (successor)",
          "ω = {0,1,2,...} (first limit ordinal)",
          "α < β ⟺ α ∈ β"
        ],
        "examples": ["ω+1, ω+2, ...", "ω·2 = ω+ω", "ω², ω^ω", "ε₀ = ω^ω^ω^..."],
        "applications": ["Transfinite induction", "Set theory", "Proof theory"]
      }
    },
    "latex": "\\omega = \\{0, 1, 2, ...\\}",
    "relations": {
      "prerequisites": ["zfc-axioms", "well-ordering"],
      "nextTopics": ["cardinals", "epsilon-numbers"],
      "related": ["natural-numbers"],
      "applications": ["induction", "recursion"]
    },
    "tags": ["서수", "ordinal", "초한", "transfinite"]
  },
  {
    "id": "cardinal-numbers",
    "name": { "ko": "기수", "en": "Cardinal Numbers" },
    "field": "set-theory",
    "subfield": "cardinals",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "집합의 크기를 나타내는 수. 무한 집합의 크기 비교 가능",
        "formulas": [
          "|A| = |B| ⟺ 전단사 존재",
          "|A| ≤ |B| ⟺ 단사 존재",
          "ℵ₀ = |ℕ| (가산 무한)",
          "c = |ℝ| = 2^ℵ₀",
          "칸토어 정리: |A| < |P(A)|"
        ],
        "examples": ["ℵ₀, ℵ₁, ℵ₂, ...", "연속체 가설: c = ℵ₁?"],
        "applications": ["무한 비교", "집합론", "기초론"]
      },
      "en": {
        "definition": "Numbers representing size of sets. Enables comparison of infinite set sizes",
        "formulas": [
          "|A| = |B| ⟺ bijection exists",
          "|A| ≤ |B| ⟺ injection exists",
          "ℵ₀ = |ℕ| (countable infinity)",
          "c = |ℝ| = 2^ℵ₀",
          "Cantor: |A| < |P(A)|"
        ],
        "examples": ["ℵ₀, ℵ₁, ℵ₂, ...", "Continuum hypothesis: c = ℵ₁?"],
        "applications": ["Infinity comparison", "Set theory", "Foundations"]
      }
    },
    "latex": "|A| < |\\mathcal{P}(A)|",
    "relations": {
      "prerequisites": ["bijection", "ordinal-numbers"],
      "nextTopics": ["continuum-hypothesis", "cardinal-arithmetic"],
      "related": ["countability"],
      "applications": ["set-theory", "logic"]
    },
    "tags": ["기수", "cardinal", "aleph", "infinity"]
  },
  {
    "id": "axiom-of-choice",
    "name": { "ko": "선택 공리", "en": "Axiom of Choice" },
    "field": "set-theory",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "공집합이 아닌 집합들의 모임에서 각 집합의 원소를 하나씩 선택하는 함수가 존재",
        "formulas": [
          "∀𝒜(∅∉𝒜 → ∃f:𝒜→∪𝒜, ∀A∈𝒜(f(A)∈A))",
          "동치: 정렬 가능 정리",
          "동치: 초른의 보조정리"
        ],
        "examples": ["양말 선택 문제", "무한 집합의 선택"],
        "applications": ["대수학", "해석학", "위상수학"]
      },
      "en": {
        "definition": "For any collection of non-empty sets, there exists a function selecting one element from each",
        "formulas": [
          "∀𝒜(∅∉𝒜 → ∃f:𝒜→∪𝒜, ∀A∈𝒜(f(A)∈A))",
          "Equivalent: Well-ordering theorem",
          "Equivalent: Zorn's lemma"
        ],
        "examples": ["Sock selection problem", "Infinite set selection"],
        "applications": ["Algebra", "Analysis", "Topology"]
      }
    },
    "latex": "\\forall \\mathcal{A}(\\emptyset \\notin \\mathcal{A} \\rightarrow \\exists f: \\mathcal{A} \\to \\bigcup\\mathcal{A})",
    "relations": {
      "prerequisites": ["zfc-axioms"],
      "nextTopics": ["zorns-lemma", "well-ordering-theorem"],
      "related": ["banach-tarski"],
      "applications": ["algebra", "analysis"]
    },
    "tags": ["선택공리", "AC", "choice", "axiom"]
  },
  {
    "id": "zorns-lemma",
    "name": { "ko": "초른의 보조정리", "en": "Zorn's Lemma" },
    "field": "set-theory",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "모든 사슬이 상계를 가지는 부분순서집합은 극대원소를 갖는다",
        "formulas": ["(P,≤) 부분순서, 모든 사슬 C⊆P에 대해 ∃상계 → ∃극대원소"],
        "examples": ["벡터공간의 기저 존재", "이상의 극대이상 존재", "필터의 극대필터(초필터)"],
        "applications": ["대수학", "해석학", "함수해석"]
      },
      "en": {
        "definition": "A partially ordered set where every chain has an upper bound contains a maximal element",
        "formulas": ["(P,≤) poset, every chain C⊆P has upper bound → ∃maximal element"],
        "examples": ["Existence of vector space basis", "Maximal ideals", "Ultrafilters"],
        "applications": ["Algebra", "Analysis", "Functional analysis"]
      }
    },
    "latex": "\\text{Every chain has upper bound} \\Rightarrow \\exists \\text{ maximal element}",
    "relations": {
      "prerequisites": ["partial-order", "axiom-of-choice"],
      "nextTopics": ["hamel-basis", "hahn-banach"],
      "related": ["well-ordering-theorem"],
      "applications": ["algebra", "functional-analysis"]
    },
    "tags": ["초른", "Zorn", "극대원소", "maximal"]
  },
  {
    "id": "continuum-hypothesis",
    "name": { "ko": "연속체 가설", "en": "Continuum Hypothesis" },
    "field": "set-theory",
    "subfield": "cardinals",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "ℵ₀과 2^ℵ₀ 사이에 다른 기수가 없다는 가설. ZFC와 독립",
        "formulas": [
          "CH: 2^ℵ₀ = ℵ₁",
          "GCH: 2^ℵα = ℵα₊₁",
          "괴델: Con(ZFC) → Con(ZFC+CH)",
          "코헨: Con(ZFC) → Con(ZFC+¬CH)"
        ],
        "examples": ["실수 집합의 부분집합 기수"],
        "applications": ["집합론", "기초론", "수학철학"]
      },
      "en": {
        "definition": "Hypothesis that no cardinal exists between ℵ₀ and 2^ℵ₀. Independent of ZFC",
        "formulas": [
          "CH: 2^ℵ₀ = ℵ₁",
          "GCH: 2^ℵα = ℵα₊₁",
          "Gödel: Con(ZFC) → Con(ZFC+CH)",
          "Cohen: Con(ZFC) → Con(ZFC+¬CH)"
        ],
        "examples": ["Cardinality of subsets of reals"],
        "applications": ["Set theory", "Foundations", "Philosophy of math"]
      }
    },
    "latex": "2^{\\aleph_0} = \\aleph_1",
    "relations": {
      "prerequisites": ["cardinal-numbers", "zfc-axioms"],
      "nextTopics": ["forcing", "large-cardinals"],
      "related": ["godel-incompleteness"],
      "applications": ["set-theory", "logic"]
    },
    "tags": ["연속체", "continuum", "CH", "independence"]
  },
  {
    "id": "cantors-theorem",
    "name": { "ko": "칸토어 정리", "en": "Cantor's Theorem" },
    "field": "set-theory",
    "subfield": "cardinals",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "집합의 기수는 항상 그 멱집합의 기수보다 작다",
        "formulas": ["|A| < |P(A)|", "증명: 대각선 논법", "결과: 무한 기수의 무한 계층"],
        "examples": ["|ℕ| < |P(ℕ)| = |ℝ|", "|ℝ| < |P(ℝ)|"],
        "applications": ["무한의 계층", "기수 이론", "대각선 논법"]
      },
      "en": {
        "definition": "Cardinality of a set is always strictly less than its power set",
        "formulas": [
          "|A| < |P(A)|",
          "Proof: Diagonal argument",
          "Result: Infinite hierarchy of infinite cardinals"
        ],
        "examples": ["|ℕ| < |P(ℕ)| = |ℝ|", "|ℝ| < |P(ℝ)|"],
        "applications": ["Hierarchy of infinity", "Cardinal theory", "Diagonal argument"]
      }
    },
    "latex": "|A| < |\\mathcal{P}(A)|",
    "relations": {
      "prerequisites": ["bijection", "power-set"],
      "nextTopics": ["cardinal-numbers", "continuum-hypothesis"],
      "related": ["russells-paradox"],
      "applications": ["set-theory", "logic"]
    },
    "tags": ["칸토어", "Cantor", "대각선", "diagonal"]
  },
  {
    "id": "well-ordering-theorem",
    "name": { "ko": "정렬 가능 정리", "en": "Well-Ordering Theorem" },
    "field": "set-theory",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "모든 집합은 정렬순서를 가질 수 있다. 선택 공리와 동치",
        "formulas": ["∀A∃≤(A,≤)가 정렬집합)", "정렬: 모든 부분집합이 최소원소 보유"],
        "examples": ["ℕ의 자연스러운 정렬", "ℝ의 정렬 (비구성적)"],
        "applications": ["초한귀납법", "서수 이론", "집합론"]
      },
      "en": {
        "definition": "Every set can be well-ordered. Equivalent to Axiom of Choice",
        "formulas": ["∀A∃≤((A,≤) is well-ordered)", "Well-order: every subset has least element"],
        "examples": ["Natural ordering of ℕ", "Well-ordering of ℝ (non-constructive)"],
        "applications": ["Transfinite induction", "Ordinal theory", "Set theory"]
      }
    },
    "latex": "\\forall A \\exists \\leq \\text{ such that } (A, \\leq) \\text{ is well-ordered}",
    "relations": {
      "prerequisites": ["partial-order", "axiom-of-choice"],
      "nextTopics": ["ordinal-numbers", "transfinite-induction"],
      "related": ["zorns-lemma"],
      "applications": ["induction", "set-theory"]
    },
    "tags": ["정렬", "well-ordering", "선택공리", "equivalence"]
  },
  {
    "id": "linear-programming",
    "name": { "ko": "선형 계획법", "en": "Linear Programming" },
    "field": "operations-research",
    "subfield": "optimization",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "선형 목적함수를 선형 제약조건 하에서 최적화하는 방법",
        "formulas": ["max c^T x", "s.t. Ax ≤ b", "x ≥ 0", "단체법 (Simplex Method)"],
        "examples": ["생산 계획", "운송 문제", "자원 배분"],
        "applications": ["제조업", "물류", "금융"]
      },
      "en": {
        "definition": "Method for optimizing linear objective function subject to linear constraints",
        "formulas": ["max c^T x", "s.t. Ax ≤ b", "x ≥ 0", "Simplex Method"],
        "examples": ["Production planning", "Transportation problem", "Resource allocation"],
        "applications": ["Manufacturing", "Logistics", "Finance"]
      }
    },
    "latex": "\\max c^T x \\quad \\text{s.t.} \\quad Ax \\leq b, \\; x \\geq 0",
    "relations": {
      "prerequisites": ["linear-algebra", "optimization-basics"],
      "nextTopics": ["integer-programming", "duality"],
      "related": ["simplex-method"],
      "applications": ["optimization", "resource-allocation"]
    },
    "tags": ["LP", "선형계획", "simplex", "optimization"]
  },
  {
    "id": "integer-programming",
    "name": { "ko": "정수 계획법", "en": "Integer Programming" },
    "field": "operations-research",
    "subfield": "optimization",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "변수가 정수 값만 가질 수 있는 최적화 문제",
        "formulas": [
          "max c^T x, s.t. Ax ≤ b, x ∈ ℤⁿ",
          "MIP: 일부 변수만 정수",
          "분기한정법 (Branch & Bound)"
        ],
        "examples": ["스케줄링", "시설 위치 선정", "차량 경로"],
        "applications": ["항공", "통신", "공급망"]
      },
      "en": {
        "definition": "Optimization where variables can only take integer values",
        "formulas": [
          "max c^T x, s.t. Ax ≤ b, x ∈ ℤⁿ",
          "MIP: some variables integer",
          "Branch & Bound"
        ],
        "examples": ["Scheduling", "Facility location", "Vehicle routing"],
        "applications": ["Airlines", "Telecommunications", "Supply chain"]
      }
    },
    "latex": "\\max c^T x \\quad \\text{s.t.} \\quad Ax \\leq b, \\; x \\in \\mathbb{Z}^n",
    "relations": {
      "prerequisites": ["linear-programming"],
      "nextTopics": ["cutting-planes", "column-generation"],
      "related": ["combinatorial-optimization"],
      "applications": ["scheduling", "logistics"]
    },
    "tags": ["IP", "MIP", "정수계획", "integer"]
  },
  {
    "id": "network-flow",
    "name": { "ko": "네트워크 흐름", "en": "Network Flow" },
    "field": "operations-research",
    "subfield": "networks",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "그래프에서 흐름을 최적화하는 문제. 최대 흐름, 최소 비용 흐름 등",
        "formulas": [
          "최대흐름-최소컷 정리: max flow = min cut",
          "흐름 보존: Σf_in = Σf_out",
          "포드-풀커슨 알고리즘"
        ],
        "examples": ["교통 흐름", "데이터 전송", "배관 시스템"],
        "applications": ["통신", "운송", "공급망"]
      },
      "en": {
        "definition": "Optimization of flow in graphs. Maximum flow, minimum cost flow, etc.",
        "formulas": [
          "Max-flow Min-cut: max flow = min cut",
          "Flow conservation: Σf_in = Σf_out",
          "Ford-Fulkerson algorithm"
        ],
        "examples": ["Traffic flow", "Data transmission", "Pipeline systems"],
        "applications": ["Telecommunications", "Transportation", "Supply chain"]
      }
    },
    "latex": "\\max f \\quad \\text{s.t. flow conservation}",
    "relations": {
      "prerequisites": ["graph-theory", "linear-programming"],
      "nextTopics": ["minimum-cost-flow", "matching"],
      "related": ["shortest-path"],
      "applications": ["logistics", "telecommunications"]
    },
    "tags": ["네트워크", "flow", "최대흐름", "max-flow"]
  },
  {
    "id": "queueing-theory",
    "name": { "ko": "대기행렬 이론", "en": "Queueing Theory" },
    "field": "operations-research",
    "subfield": "stochastic",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "대기열 시스템의 수학적 분석. 도착, 서비스, 대기 시간 모델링",
        "formulas": [
          "M/M/1: λ < μ일 때 안정",
          "이용률: ρ = λ/μ",
          "평균 대기시간: W = L/λ (리틀의 법칙)",
          "M/M/c: c개 서버"
        ],
        "examples": ["은행 창구", "콜센터", "서버 큐"],
        "applications": ["서비스 설계", "용량 계획", "시스템 분석"]
      },
      "en": {
        "definition": "Mathematical analysis of waiting line systems. Modeling arrivals, service, waiting times",
        "formulas": [
          "M/M/1: stable if λ < μ",
          "Utilization: ρ = λ/μ",
          "Mean wait: W = L/λ (Little's law)",
          "M/M/c: c servers"
        ],
        "examples": ["Bank tellers", "Call centers", "Server queues"],
        "applications": ["Service design", "Capacity planning", "System analysis"]
      }
    },
    "latex": "W = \\frac{L}{\\lambda}",
    "relations": {
      "prerequisites": ["probability", "stochastic-processes"],
      "nextTopics": ["markov-chains", "simulation"],
      "related": ["poisson-process"],
      "applications": ["service-engineering", "capacity-planning"]
    },
    "tags": ["큐잉", "queue", "대기열", "Little's law"]
  },
  {
    "id": "dynamic-programming-or",
    "name": { "ko": "동적 계획법 (OR)", "en": "Dynamic Programming (OR)" },
    "field": "operations-research",
    "subfield": "optimization",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "복잡한 문제를 하위 문제로 분해하여 순차적으로 최적화",
        "formulas": [
          "벨만 방정식: V(s) = max_a {r(s,a) + γV(s')}",
          "최적 부분구조",
          "중복 부분문제"
        ],
        "examples": ["배낭 문제", "최단 경로", "재고 관리"],
        "applications": ["자원 배분", "투자", "로봇공학"]
      },
      "en": {
        "definition": "Decomposing complex problems into subproblems for sequential optimization",
        "formulas": [
          "Bellman equation: V(s) = max_a {r(s,a) + γV(s')}",
          "Optimal substructure",
          "Overlapping subproblems"
        ],
        "examples": ["Knapsack problem", "Shortest path", "Inventory management"],
        "applications": ["Resource allocation", "Investment", "Robotics"]
      }
    },
    "latex": "V(s) = \\max_a \\{r(s,a) + \\gamma V(s')\\}",
    "relations": {
      "prerequisites": ["optimization-basics", "recursion"],
      "nextTopics": ["reinforcement-learning", "markov-decision-process"],
      "related": ["bellman-equation"],
      "applications": ["control", "ai"]
    },
    "tags": ["DP", "동적계획", "Bellman", "optimization"]
  },
  {
    "id": "inventory-theory",
    "name": { "ko": "재고 이론", "en": "Inventory Theory" },
    "field": "operations-research",
    "subfield": "supply-chain",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "재고 보유 비용과 주문 비용을 최소화하는 최적 재고 정책 결정",
        "formulas": ["EOQ: Q* = √(2DK/h)", "재주문점: ROP = d × L", "ABC 분석", "(s,S) 정책"],
        "examples": ["제조업 원자재", "소매 재고", "창고 관리"],
        "applications": ["공급망", "제조", "소매"]
      },
      "en": {
        "definition": "Determining optimal inventory policies minimizing holding and ordering costs",
        "formulas": [
          "EOQ: Q* = √(2DK/h)",
          "Reorder point: ROP = d × L",
          "ABC analysis",
          "(s,S) policy"
        ],
        "examples": ["Manufacturing raw materials", "Retail inventory", "Warehouse management"],
        "applications": ["Supply chain", "Manufacturing", "Retail"]
      }
    },
    "latex": "Q^* = \\sqrt{\\frac{2DK}{h}}",
    "relations": {
      "prerequisites": ["optimization-basics", "probability"],
      "nextTopics": ["supply-chain-optimization"],
      "related": ["queueing-theory"],
      "applications": ["logistics", "manufacturing"]
    },
    "tags": ["재고", "inventory", "EOQ", "supply-chain"]
  },
  {
    "id": "scheduling-theory",
    "name": { "ko": "스케줄링 이론", "en": "Scheduling Theory" },
    "field": "operations-research",
    "subfield": "scheduling",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "작업들을 자원에 시간적으로 배정하여 목적함수 최적화",
        "formulas": [
          "단일기계: 1||Σwⱼcⱼ",
          "병렬기계: P||Cmax",
          "흐름작업: F||Cmax",
          "작업장: J||Cmax"
        ],
        "examples": ["공장 스케줄링", "프로젝트 관리", "CPU 스케줄링"],
        "applications": ["제조", "컴퓨터 시스템", "항공"]
      },
      "en": {
        "definition": "Temporal assignment of jobs to resources to optimize objective function",
        "formulas": [
          "Single machine: 1||Σwⱼcⱼ",
          "Parallel: P||Cmax",
          "Flow shop: F||Cmax",
          "Job shop: J||Cmax"
        ],
        "examples": ["Factory scheduling", "Project management", "CPU scheduling"],
        "applications": ["Manufacturing", "Computer systems", "Airlines"]
      }
    },
    "latex": "\\min C_{max} = \\max_j C_j",
    "relations": {
      "prerequisites": ["graph-theory", "combinatorial-optimization"],
      "nextTopics": ["constraint-programming"],
      "related": ["integer-programming"],
      "applications": ["manufacturing", "computing"]
    },
    "tags": ["스케줄링", "scheduling", "makespan", "jobs"]
  },
  {
    "id": "markov-decision-process",
    "name": { "ko": "마르코프 결정 과정", "en": "Markov Decision Process" },
    "field": "operations-research",
    "subfield": "stochastic",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "순차적 의사결정을 위한 확률적 모델. 상태, 행동, 보상, 전이확률",
        "formulas": [
          "(S, A, P, R, γ)",
          "벨만 최적 방정식: V*(s) = max_a Σ P(s'|s,a)[R + γV*(s')]",
          "정책: π(s) → a"
        ],
        "examples": ["로봇 네비게이션", "게임 AI", "추천 시스템"],
        "applications": ["강화학습", "로봇공학", "금융"]
      },
      "en": {
        "definition": "Stochastic model for sequential decision making. States, actions, rewards, transitions",
        "formulas": [
          "(S, A, P, R, γ)",
          "Bellman optimality: V*(s) = max_a Σ P(s'|s,a)[R + γV*(s')]",
          "Policy: π(s) → a"
        ],
        "examples": ["Robot navigation", "Game AI", "Recommendation systems"],
        "applications": ["Reinforcement learning", "Robotics", "Finance"]
      }
    },
    "latex": "V^*(s) = \\max_a \\sum_{s'} P(s'|s,a)[R(s,a,s') + \\gamma V^*(s')]",
    "relations": {
      "prerequisites": ["markov-chains", "dynamic-programming-or"],
      "nextTopics": ["reinforcement-learning", "pomdp"],
      "related": ["bellman-equation"],
      "applications": ["ai", "robotics", "control"]
    },
    "tags": ["MDP", "마르코프", "decision", "reinforcement"]
  },
  {
    "id": "algebraic-variety",
    "name": { "ko": "대수적 다양체", "en": "Algebraic Variety" },
    "field": "algebraic-geometry",
    "subfield": "varieties",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "다항식 방정식의 해집합. 대수기하학의 기본 연구 대상",
        "formulas": [
          "V(I) = {x ∈ kⁿ : f(x) = 0, ∀f ∈ I}",
          "아핀 다양체: Aⁿ의 부분집합",
          "사영 다양체: Pⁿ의 부분집합"
        ],
        "examples": ["원: x² + y² = 1", "타원곡선: y² = x³ + ax + b", "곡면: xyz = 1"],
        "applications": ["암호학", "정수론", "물리학"]
      },
      "en": {
        "definition": "Solution set of polynomial equations. Fundamental objects in algebraic geometry",
        "formulas": [
          "V(I) = {x ∈ kⁿ : f(x) = 0, ∀f ∈ I}",
          "Affine variety: subset of Aⁿ",
          "Projective variety: subset of Pⁿ"
        ],
        "examples": ["Circle: x² + y² = 1", "Elliptic curve: y² = x³ + ax + b", "Surface: xyz = 1"],
        "applications": ["Cryptography", "Number theory", "Physics"]
      }
    },
    "latex": "V(I) = \\{x \\in k^n : f(x) = 0, \\; \\forall f \\in I\\}",
    "relations": {
      "prerequisites": ["polynomial-ring", "ideal"],
      "nextTopics": ["scheme", "sheaf"],
      "related": ["manifold"],
      "applications": ["cryptography", "physics"]
    },
    "tags": ["다양체", "variety", "대수기하", "algebraic"]
  },
  {
    "id": "projective-space",
    "name": { "ko": "사영 공간", "en": "Projective Space" },
    "field": "algebraic-geometry",
    "subfield": "spaces",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "벡터공간의 1차원 부분공간들의 집합. \"무한점\"을 포함하여 기하학 완성",
        "formulas": ["Pⁿ = (kⁿ⁺¹ - {0})/~", "[x₀:x₁:...:xₙ] (동차좌표)", "P¹ = k ∪ {∞}"],
        "examples": ["P¹ (사영직선)", "P² (사영평면)", "무한점에서 만나는 평행선"],
        "applications": ["대수기하", "컴퓨터 비전", "원근법"]
      },
      "en": {
        "definition": "Set of 1-dimensional subspaces of vector space. Completes geometry by including \"points at infinity\"",
        "formulas": ["Pⁿ = (kⁿ⁺¹ - {0})/~", "[x₀:x₁:...:xₙ] (homogeneous coords)", "P¹ = k ∪ {∞}"],
        "examples": [
          "P¹ (projective line)",
          "P² (projective plane)",
          "Parallel lines meeting at infinity"
        ],
        "applications": ["Algebraic geometry", "Computer vision", "Perspective"]
      }
    },
    "latex": "\\mathbb{P}^n = (k^{n+1} - \\{0\\})/\\sim",
    "relations": {
      "prerequisites": ["linear-algebra", "equivalence-relation"],
      "nextTopics": ["algebraic-variety", "grassmannian"],
      "related": ["affine-space"],
      "applications": ["computer-graphics", "geometry"]
    },
    "tags": ["사영", "projective", "동차좌표", "homogeneous"]
  },
  {
    "id": "scheme",
    "name": { "ko": "스킴", "en": "Scheme" },
    "field": "algebraic-geometry",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "국소환달린 공간. 대수적 다양체의 일반화로 현대 대수기하의 기초",
        "formulas": ["(X, O_X)", "Spec A: 소 아이디얼의 집합", "구조층: O_X (국소환의 층)"],
        "examples": ["Spec ℤ", "Spec k[x]", "Proj (사영 스킴)"],
        "applications": ["수론", "대수기하", "호몰로지대수"]
      },
      "en": {
        "definition": "Locally ringed space. Generalization of varieties, foundation of modern algebraic geometry",
        "formulas": [
          "(X, O_X)",
          "Spec A: set of prime ideals",
          "Structure sheaf: O_X (sheaf of local rings)"
        ],
        "examples": ["Spec ℤ", "Spec k[x]", "Proj (projective scheme)"],
        "applications": ["Number theory", "Algebraic geometry", "Homological algebra"]
      }
    },
    "latex": "(X, \\mathcal{O}_X)",
    "relations": {
      "prerequisites": ["algebraic-variety", "commutative-algebra", "sheaf"],
      "nextTopics": ["coherent-sheaf", "morphism"],
      "related": ["manifold"],
      "applications": ["number-theory", "moduli"]
    },
    "tags": ["스킴", "scheme", "Spec", "Grothendieck"]
  },
  {
    "id": "sheaf-theory",
    "name": { "ko": "층 이론", "en": "Sheaf Theory" },
    "field": "algebraic-geometry",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "위상공간의 열린집합에 대수적 데이터를 붙이는 구조",
        "formulas": [
          "전층: F: Open(X)^op → C",
          "층 조건: 접합 공리",
          "층화: 전층 → 층",
          "층 코호몰로지: Hⁿ(X, F)"
        ],
        "examples": ["연속함수 층", "미분형식 층", "정칙함수 층 O"],
        "applications": ["대수기하", "복소해석", "위상수학"]
      },
      "en": {
        "definition": "Structure attaching algebraic data to open sets of topological space",
        "formulas": [
          "Presheaf: F: Open(X)^op → C",
          "Sheaf condition: gluing axiom",
          "Sheafification: presheaf → sheaf",
          "Sheaf cohomology: Hⁿ(X, F)"
        ],
        "examples": [
          "Sheaf of continuous functions",
          "Sheaf of differential forms",
          "Structure sheaf O"
        ],
        "applications": ["Algebraic geometry", "Complex analysis", "Topology"]
      }
    },
    "latex": "H^n(X, \\mathcal{F})",
    "relations": {
      "prerequisites": ["topology", "category-definition"],
      "nextTopics": ["scheme", "derived-category"],
      "related": ["cohomology"],
      "applications": ["algebraic-geometry", "complex-analysis"]
    },
    "tags": ["층", "sheaf", "코호몰로지", "cohomology"]
  },
  {
    "id": "bezouts-theorem",
    "name": { "ko": "베주 정리", "en": "Bézout's Theorem" },
    "field": "algebraic-geometry",
    "subfield": "intersection",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "두 사영 곡선의 교점 개수는 차수의 곱 (적절히 세면)",
        "formulas": ["deg(C₁) · deg(C₂) = Σ m_p", "중복도 포함, 복소수 체, 무한점 포함"],
        "examples": ["직선과 원뿔곡선: 2점", "두 원뿔곡선: 4점"],
        "applications": ["교점 이론", "대수기하", "기하학"]
      },
      "en": {
        "definition": "Number of intersection points of two projective curves equals product of degrees (counted properly)",
        "formulas": ["deg(C₁) · deg(C₂) = Σ m_p", "With multiplicity, over ℂ, including infinity"],
        "examples": ["Line and conic: 2 points", "Two conics: 4 points"],
        "applications": ["Intersection theory", "Algebraic geometry", "Geometry"]
      }
    },
    "latex": "\\deg(C_1) \\cdot \\deg(C_2) = \\sum_p m_p",
    "relations": {
      "prerequisites": ["projective-space", "polynomial-degree"],
      "nextTopics": ["intersection-multiplicity"],
      "related": ["fundamental-theorem-algebra"],
      "applications": ["intersection-theory"]
    },
    "tags": ["베주", "Bézout", "교점", "intersection"]
  },
  {
    "id": "hilbert-nullstellensatz",
    "name": { "ko": "힐베르트 영점정리", "en": "Hilbert Nullstellensatz" },
    "field": "algebraic-geometry",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "다항식의 아이디얼과 대수적 집합 사이의 대응. 대수기하학의 기초",
        "formulas": [
          "I(V(I)) = √I (근기)",
          "약한 형태: k 대수폐체, I ≠ k[x] ⟹ V(I) ≠ ∅",
          "I, V 사이의 갈루아 대응"
        ],
        "examples": ["V(x²) = {0}, I(V(x²)) = (x)"],
        "applications": ["대수기하", "가환대수", "정수론"]
      },
      "en": {
        "definition": "Correspondence between polynomial ideals and algebraic sets. Foundation of algebraic geometry",
        "formulas": [
          "I(V(I)) = √I (radical)",
          "Weak form: k alg. closed, I ≠ k[x] ⟹ V(I) ≠ ∅",
          "Galois correspondence between I, V"
        ],
        "examples": ["V(x²) = {0}, I(V(x²)) = (x)"],
        "applications": ["Algebraic geometry", "Commutative algebra", "Number theory"]
      }
    },
    "latex": "I(V(I)) = \\sqrt{I}",
    "relations": {
      "prerequisites": ["ideal", "polynomial-ring"],
      "nextTopics": ["algebraic-variety", "scheme"],
      "related": ["fundamental-theorem-algebra"],
      "applications": ["algebraic-geometry"]
    },
    "tags": ["힐베르트", "Nullstellensatz", "영점", "radical"]
  },
  {
    "id": "riemann-roch",
    "name": { "ko": "리만-로흐 정리", "en": "Riemann-Roch Theorem" },
    "field": "algebraic-geometry",
    "subfield": "curves",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "대수곡선 위 인자의 선형계 차원을 계산하는 기본 정리",
        "formulas": ["ℓ(D) - ℓ(K-D) = deg(D) - g + 1", "g: 종수, K: 표준인자", "ℓ(D) = dim L(D)"],
        "examples": ["g=0: ℓ(D) = max(0, deg(D)+1)", "g=1 타원곡선"],
        "applications": ["곡선론", "암호학", "코딩이론"]
      },
      "en": {
        "definition": "Fundamental theorem computing dimension of linear systems of divisors on algebraic curves",
        "formulas": [
          "ℓ(D) - ℓ(K-D) = deg(D) - g + 1",
          "g: genus, K: canonical divisor",
          "ℓ(D) = dim L(D)"
        ],
        "examples": ["g=0: ℓ(D) = max(0, deg(D)+1)", "g=1 elliptic curve"],
        "applications": ["Curve theory", "Cryptography", "Coding theory"]
      }
    },
    "latex": "\\ell(D) - \\ell(K-D) = \\deg(D) - g + 1",
    "relations": {
      "prerequisites": ["algebraic-variety", "divisor"],
      "nextTopics": ["grothendieck-riemann-roch"],
      "related": ["genus"],
      "applications": ["curves", "coding-theory"]
    },
    "tags": ["리만로흐", "Riemann-Roch", "종수", "genus"]
  },
  {
    "id": "elliptic-curves-ag",
    "name": { "ko": "타원곡선 (대수기하)", "en": "Elliptic Curves (Algebraic Geometry)" },
    "field": "algebraic-geometry",
    "subfield": "curves",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "종수 1의 비특이 사영곡선. 군 구조를 가지며 정수론과 암호학의 핵심",
        "formulas": [
          "y² = x³ + ax + b (바이어슈트라스)",
          "Δ = -16(4a³ + 27b²) ≠ 0",
          "점 덧셈: P + Q + R = O"
        ],
        "examples": ["y² = x³ - x", "y² = x³ - 432"],
        "applications": ["암호학", "페르마의 마지막 정리", "정수론"]
      },
      "en": {
        "definition": "Non-singular projective curve of genus 1. Has group structure, central to number theory and cryptography",
        "formulas": [
          "y² = x³ + ax + b (Weierstrass)",
          "Δ = -16(4a³ + 27b²) ≠ 0",
          "Point addition: P + Q + R = O"
        ],
        "examples": ["y² = x³ - x", "y² = x³ - 432"],
        "applications": ["Cryptography", "Fermat's Last Theorem", "Number theory"]
      }
    },
    "latex": "y^2 = x^3 + ax + b",
    "relations": {
      "prerequisites": ["algebraic-variety", "group-theory"],
      "nextTopics": ["abelian-variety", "modular-forms"],
      "related": ["elliptic-curve-crypto"],
      "applications": ["cryptography", "number-theory"]
    },
    "tags": ["타원곡선", "elliptic", "암호", "group-law"]
  },
  {
    "id": "banach-space",
    "name": { "ko": "바나흐 공간", "en": "Banach Space" },
    "field": "functional-analysis",
    "subfield": "spaces",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "완비 노름공간. 모든 코시 수열이 수렴하는 노름 벡터공간",
        "formulas": [
          "||x|| ≥ 0, ||x|| = 0 ⟺ x = 0",
          "||αx|| = |α| ||x||",
          "||x + y|| ≤ ||x|| + ||y||",
          "완비성: 코시 수열 수렴"
        ],
        "examples": ["ℝⁿ, Cⁿ (유한차원)", "Lᵖ(Ω), C([a,b])", "ℓᵖ (수열 공간)"],
        "applications": ["미분방정식", "양자역학", "최적화"]
      },
      "en": {
        "definition": "Complete normed space. Normed vector space where every Cauchy sequence converges",
        "formulas": [
          "||x|| ≥ 0, ||x|| = 0 ⟺ x = 0",
          "||αx|| = |α| ||x||",
          "||x + y|| ≤ ||x|| + ||y||",
          "Completeness: Cauchy sequences converge"
        ],
        "examples": ["ℝⁿ, Cⁿ (finite dim)", "Lᵖ(Ω), C([a,b])", "ℓᵖ (sequence spaces)"],
        "applications": ["Differential equations", "Quantum mechanics", "Optimization"]
      }
    },
    "latex": "\\|x + y\\| \\leq \\|x\\| + \\|y\\|",
    "relations": {
      "prerequisites": ["normed-space", "cauchy-sequence"],
      "nextTopics": ["hilbert-space", "bounded-operators"],
      "related": ["metric-space"],
      "applications": ["pde", "optimization"]
    },
    "tags": ["바나흐", "Banach", "완비", "normed"]
  },
  {
    "id": "hilbert-space",
    "name": { "ko": "힐베르트 공간", "en": "Hilbert Space" },
    "field": "functional-analysis",
    "subfield": "spaces",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "내적이 정의된 완비 공간. 유한차원 유클리드 공간의 무한차원 일반화",
        "formulas": [
          "⟨x, y⟩ = ⟨y, x⟩̄ (켤레 대칭)",
          "⟨x, x⟩ ≥ 0",
          "||x|| = √⟨x, x⟩",
          "정규직교기저: ⟨eᵢ, eⱼ⟩ = δᵢⱼ"
        ],
        "examples": ["L²(ℝ)", "ℓ²", "양자 상태 공간"],
        "applications": ["양자역학", "푸리에 해석", "신호처리"]
      },
      "en": {
        "definition": "Complete space with inner product. Infinite-dimensional generalization of Euclidean space",
        "formulas": [
          "⟨x, y⟩ = ⟨y, x⟩̄ (conjugate symmetry)",
          "⟨x, x⟩ ≥ 0",
          "||x|| = √⟨x, x⟩",
          "Orthonormal basis: ⟨eᵢ, eⱼ⟩ = δᵢⱼ"
        ],
        "examples": ["L²(ℝ)", "ℓ²", "Quantum state space"],
        "applications": ["Quantum mechanics", "Fourier analysis", "Signal processing"]
      }
    },
    "latex": "\\|x\\| = \\sqrt{\\langle x, x \\rangle}",
    "relations": {
      "prerequisites": ["inner-product", "banach-space"],
      "nextTopics": ["spectral-theorem", "self-adjoint"],
      "related": ["euclidean-space"],
      "applications": ["quantum-mechanics", "signal-processing"]
    },
    "tags": ["힐베르트", "Hilbert", "내적", "inner-product"]
  },
  {
    "id": "bounded-linear-operator",
    "name": { "ko": "유계 선형 작용소", "en": "Bounded Linear Operator" },
    "field": "functional-analysis",
    "subfield": "operators",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "노름이 유한인 선형 작용소. B(X,Y)는 X에서 Y로의 유계 작용소들의 바나흐 공간",
        "formulas": ["||T|| = sup{||Tx|| : ||x|| ≤ 1}", "||Tx|| ≤ ||T|| ||x||", "유계 ⟺ 연속"],
        "examples": ["적분 작용소", "미분 작용소 (비유계)", "행렬 (유한차원)"],
        "applications": ["미분방정식", "양자역학", "근사이론"]
      },
      "en": {
        "definition": "Linear operator with finite norm. B(X,Y) is Banach space of bounded operators from X to Y",
        "formulas": [
          "||T|| = sup{||Tx|| : ||x|| ≤ 1}",
          "||Tx|| ≤ ||T|| ||x||",
          "Bounded ⟺ Continuous"
        ],
        "examples": ["Integral operator", "Differentiation (unbounded)", "Matrix (finite dim)"],
        "applications": ["Differential equations", "Quantum mechanics", "Approximation theory"]
      }
    },
    "latex": "\\|T\\| = \\sup\\{\\|Tx\\| : \\|x\\| \\leq 1\\}",
    "relations": {
      "prerequisites": ["linear-map", "banach-space"],
      "nextTopics": ["spectral-theory", "compact-operator"],
      "related": ["matrix"],
      "applications": ["operator-theory"]
    },
    "tags": ["작용소", "operator", "유계", "bounded"]
  },
  {
    "id": "spectral-theorem",
    "name": { "ko": "스펙트럼 정리", "en": "Spectral Theorem" },
    "field": "functional-analysis",
    "subfield": "spectral-theory",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "자기수반(에르미트) 작용소는 고유값과 고유벡터로 대각화 가능",
        "formulas": ["T = ∫λ dE_λ (스펙트럼 분해)", "유한차원: T = Σλᵢ Pᵢ", "σ(T) ⊂ ℝ (자기수반)"],
        "examples": ["대칭 행렬", "양자 관측 가능량", "슈튀름-리우빌 문제"],
        "applications": ["양자역학", "미분방정식", "진동 해석"]
      },
      "en": {
        "definition": "Self-adjoint (Hermitian) operators can be diagonalized via eigenvalues and eigenvectors",
        "formulas": [
          "T = ∫λ dE_λ (spectral decomposition)",
          "Finite dim: T = Σλᵢ Pᵢ",
          "σ(T) ⊂ ℝ (self-adjoint)"
        ],
        "examples": ["Symmetric matrices", "Quantum observables", "Sturm-Liouville problems"],
        "applications": ["Quantum mechanics", "Differential equations", "Vibration analysis"]
      }
    },
    "latex": "T = \\int \\lambda \\, dE_\\lambda",
    "relations": {
      "prerequisites": ["hilbert-space", "eigenvalues"],
      "nextTopics": ["functional-calculus"],
      "related": ["eigenvalue-decomposition"],
      "applications": ["quantum-mechanics", "pde"]
    },
    "tags": ["스펙트럼", "spectral", "자기수반", "self-adjoint"]
  },
  {
    "id": "hahn-banach-theorem",
    "name": { "ko": "한-바나흐 정리", "en": "Hahn-Banach Theorem" },
    "field": "functional-analysis",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "부분공간에서 정의된 유계 선형 범함수를 전체 공간으로 노름 보존 확장",
        "formulas": [
          "f: M → ℝ 유계 선형 ⟹ ∃F: X → ℝ 확장",
          "||F|| = ||f||",
          "분리 버전: 볼록집합 분리"
        ],
        "examples": ["이중공간 구성", "점 평가 확장"],
        "applications": ["최적화", "경제학", "이론 해석"]
      },
      "en": {
        "definition": "Bounded linear functional on subspace can be extended to whole space preserving norm",
        "formulas": [
          "f: M → ℝ bounded linear ⟹ ∃F: X → ℝ extension",
          "||F|| = ||f||",
          "Separation version: separating convex sets"
        ],
        "examples": ["Dual space construction", "Point evaluation extension"],
        "applications": ["Optimization", "Economics", "Theoretical analysis"]
      }
    },
    "latex": "\\|F\\| = \\|f\\|",
    "relations": {
      "prerequisites": ["banach-space", "zorns-lemma"],
      "nextTopics": ["dual-space", "reflexive-space"],
      "related": ["separation-theorem"],
      "applications": ["optimization", "duality"]
    },
    "tags": ["한바나흐", "Hahn-Banach", "확장", "extension"]
  },
  {
    "id": "open-mapping-theorem",
    "name": { "ko": "열린 사상 정리", "en": "Open Mapping Theorem" },
    "field": "functional-analysis",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "바나흐 공간 사이의 전사 유계 선형 작용소는 열린 집합을 열린 집합으로 보냄",
        "formulas": [
          "T: X → Y 전사, 유계, 선형 ⟹ T(열린집합) = 열린집합",
          "역사상 정리: T 전단사 ⟹ T⁻¹ 유계"
        ],
        "examples": ["역행렬의 유계성", "미분방정식 해의 존재성"],
        "applications": ["작용소 이론", "미분방정식"]
      },
      "en": {
        "definition": "Surjective bounded linear operator between Banach spaces maps open sets to open sets",
        "formulas": [
          "T: X → Y surjective, bounded, linear ⟹ T(open) = open",
          "Inverse mapping: T bijective ⟹ T⁻¹ bounded"
        ],
        "examples": ["Boundedness of inverse", "Existence of PDE solutions"],
        "applications": ["Operator theory", "Differential equations"]
      }
    },
    "latex": "T(\\text{open}) = \\text{open}",
    "relations": {
      "prerequisites": ["banach-space", "bounded-linear-operator"],
      "nextTopics": ["closed-graph-theorem"],
      "related": ["inverse-function-theorem"],
      "applications": ["operator-theory"]
    },
    "tags": ["열린사상", "open-mapping", "바나흐", "surjective"]
  },
  {
    "id": "compact-operator",
    "name": { "ko": "컴팩트 작용소", "en": "Compact Operator" },
    "field": "functional-analysis",
    "subfield": "operators",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "유계 집합을 상대적으로 컴팩트한 집합으로 보내는 작용소",
        "formulas": [
          "T: X → Y, T(단위구)가 상대적 컴팩트",
          "유한계수 작용소의 노름 극한",
          "σ(T) \\ {0}는 고립된 고유값"
        ],
        "examples": ["적분 작용소 (연속 핵)", "볼테라 작용소", "유한계수 작용소"],
        "applications": ["적분방정식", "프레드홀름 이론", "스펙트럼 이론"]
      },
      "en": {
        "definition": "Operator mapping bounded sets to relatively compact sets",
        "formulas": [
          "T: X → Y, T(unit ball) relatively compact",
          "Norm limit of finite-rank operators",
          "σ(T) \\ {0} isolated eigenvalues"
        ],
        "examples": [
          "Integral operator (continuous kernel)",
          "Volterra operator",
          "Finite-rank operators"
        ],
        "applications": ["Integral equations", "Fredholm theory", "Spectral theory"]
      }
    },
    "latex": "T(B_X) \\text{ relatively compact}",
    "relations": {
      "prerequisites": ["bounded-linear-operator", "compactness"],
      "nextTopics": ["fredholm-theory", "spectral-theorem"],
      "related": ["finite-rank"],
      "applications": ["integral-equations"]
    },
    "tags": ["컴팩트", "compact", "작용소", "operator"]
  },
  {
    "id": "weak-convergence",
    "name": { "ko": "약수렴", "en": "Weak Convergence" },
    "field": "functional-analysis",
    "subfield": "convergence",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "모든 연속 선형 범함수에 대해 수렴하는 수열. 노름 수렴보다 약함",
        "formulas": [
          "xₙ ⇀ x ⟺ ∀f ∈ X*, f(xₙ) → f(x)",
          "약*수렴: fₙ ⇀* f ⟺ ∀x, fₙ(x) → f(x)",
          "노름 수렴 ⟹ 약수렴"
        ],
        "examples": ["L²에서의 약수렴", "힐베르트 공간의 직교수열"],
        "applications": ["변분법", "편미분방정식", "최적화"]
      },
      "en": {
        "definition": "Convergence with respect to all continuous linear functionals. Weaker than norm convergence",
        "formulas": [
          "xₙ ⇀ x ⟺ ∀f ∈ X*, f(xₙ) → f(x)",
          "Weak*: fₙ ⇀* f ⟺ ∀x, fₙ(x) → f(x)",
          "Norm convergence ⟹ Weak convergence"
        ],
        "examples": ["Weak convergence in L²", "Orthogonal sequences in Hilbert space"],
        "applications": ["Calculus of variations", "PDEs", "Optimization"]
      }
    },
    "latex": "x_n \\rightharpoonup x \\Leftrightarrow \\forall f \\in X^*, \\; f(x_n) \\to f(x)",
    "relations": {
      "prerequisites": ["dual-space", "banach-space"],
      "nextTopics": ["weak-compactness"],
      "related": ["norm-convergence"],
      "applications": ["pde", "variational-methods"]
    },
    "tags": ["약수렴", "weak", "convergence", "dual"]
  },
  {
    "id": "generating-functions",
    "name": { "ko": "생성함수", "en": "Generating Functions" },
    "field": "combinatorics",
    "subfield": "enumeration",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "수열을 다항식 또는 멱급수의 계수로 인코딩하여 조합 문제를 해결하는 도구",
        "formulas": ["OGF: G(x) = Σaₙxⁿ", "EGF: E(x) = Σaₙxⁿ/n!", "피보나치: G(x) = x/(1-x-x²)"],
        "examples": ["분할수", "카탈란 수", "스털링 수"],
        "applications": ["점화식 해결", "조합 항등식", "확률론"]
      },
      "en": {
        "definition": "Tool encoding sequences as coefficients of polynomials or power series to solve combinatorial problems",
        "formulas": ["OGF: G(x) = Σaₙxⁿ", "EGF: E(x) = Σaₙxⁿ/n!", "Fibonacci: G(x) = x/(1-x-x²)"],
        "examples": ["Partition numbers", "Catalan numbers", "Stirling numbers"],
        "applications": ["Solving recurrences", "Combinatorial identities", "Probability"]
      }
    },
    "latex": "G(x) = \\sum_{n=0}^{\\infty} a_n x^n",
    "relations": {
      "prerequisites": ["sequences-and-series", "taylor-series"],
      "nextTopics": ["analytic-combinatorics"],
      "related": ["recurrence-relations"],
      "applications": ["enumeration", "probability"]
    },
    "tags": ["생성함수", "generating", "enumeration", "series"]
  },
  {
    "id": "catalan-numbers",
    "name": { "ko": "카탈란 수", "en": "Catalan Numbers" },
    "field": "combinatorics",
    "subfield": "enumeration",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "다양한 조합 구조의 개수를 세는 수열. Cₙ = (2n)!/((n+1)!n!)",
        "formulas": ["Cₙ = C(2n,n)/(n+1)", "Cₙ = ΣCᵢCₙ₋₁₋ᵢ", "G(x) = (1-√(1-4x))/(2x)"],
        "examples": ["괄호 배열", "이진 트리", "격자 경로", "볼록 다각형 삼각분할"],
        "applications": ["알고리즘", "파싱", "기하학"]
      },
      "en": {
        "definition": "Sequence counting various combinatorial structures. Cₙ = (2n)!/((n+1)!n!)",
        "formulas": ["Cₙ = C(2n,n)/(n+1)", "Cₙ = ΣCᵢCₙ₋₁₋ᵢ", "G(x) = (1-√(1-4x))/(2x)"],
        "examples": [
          "Parenthesizations",
          "Binary trees",
          "Lattice paths",
          "Polygon triangulations"
        ],
        "applications": ["Algorithms", "Parsing", "Geometry"]
      }
    },
    "latex": "C_n = \\frac{1}{n+1}\\binom{2n}{n}",
    "relations": {
      "prerequisites": ["binomial-coefficient", "recursion"],
      "nextTopics": ["generating-functions"],
      "related": ["fibonacci-sequence"],
      "applications": ["computer-science", "combinatorics"]
    },
    "tags": ["카탈란", "Catalan", "열거", "enumeration"]
  },
  {
    "id": "stirling-numbers",
    "name": { "ko": "스털링 수", "en": "Stirling Numbers" },
    "field": "combinatorics",
    "subfield": "enumeration",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "순열과 집합 분할을 세는 두 종류의 조합수",
        "formulas": [
          "제1종 s(n,k): n개를 k개 순환으로 배열",
          "제2종 S(n,k): n개를 k개 부분집합으로 분할",
          "S(n,k) = kS(n-1,k) + S(n-1,k-1)"
        ],
        "examples": ["s(4,2) = 11", "S(4,2) = 7", "벨 수: Bₙ = ΣS(n,k)"],
        "applications": ["분할", "다항식", "확률론"]
      },
      "en": {
        "definition": "Two types of combinatorial numbers counting permutations and set partitions",
        "formulas": [
          "First kind s(n,k): n elements into k cycles",
          "Second kind S(n,k): n into k subsets",
          "S(n,k) = kS(n-1,k) + S(n-1,k-1)"
        ],
        "examples": ["s(4,2) = 11", "S(4,2) = 7", "Bell number: Bₙ = ΣS(n,k)"],
        "applications": ["Partitions", "Polynomials", "Probability"]
      }
    },
    "latex": "S(n,k) = k \\cdot S(n-1,k) + S(n-1,k-1)",
    "relations": {
      "prerequisites": ["permutations", "partitions"],
      "nextTopics": ["bell-numbers"],
      "related": ["binomial-coefficient"],
      "applications": ["set-partitions", "polynomials"]
    },
    "tags": ["스털링", "Stirling", "분할", "partition"]
  },
  {
    "id": "polya-enumeration",
    "name": { "ko": "폴리아 열거 정리", "en": "Pólya Enumeration Theorem" },
    "field": "combinatorics",
    "subfield": "enumeration",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "대칭성을 고려하여 구별 불가능한 구조의 개수를 세는 정리",
        "formulas": ["|X/G| = (1/|G|) Σ |X^g|", "순환 지표: Z(G)", "색칠 수: PG(c₁,c₂,...,cₖ)"],
        "examples": ["목걸이 색칠", "정다면체 색칠", "그래프 동형"],
        "applications": ["화학", "그래프 이론", "분자 구조"]
      },
      "en": {
        "definition": "Theorem counting indistinguishable structures considering symmetry",
        "formulas": ["|X/G| = (1/|G|) Σ |X^g|", "Cycle index: Z(G)", "Colorings: PG(c₁,c₂,...,cₖ)"],
        "examples": ["Necklace coloring", "Polyhedra coloring", "Graph isomorphism"],
        "applications": ["Chemistry", "Graph theory", "Molecular structures"]
      }
    },
    "latex": "|X/G| = \\frac{1}{|G|} \\sum_{g \\in G} |X^g|",
    "relations": {
      "prerequisites": ["group-theory", "group-actions"],
      "nextTopics": ["burnside-lemma"],
      "related": ["symmetry"],
      "applications": ["chemistry", "graph-theory"]
    },
    "tags": ["폴리아", "Pólya", "대칭", "symmetry"]
  },
  {
    "id": "ramsey-theory",
    "name": { "ko": "램지 이론", "en": "Ramsey Theory" },
    "field": "combinatorics",
    "subfield": "extremal",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "충분히 큰 구조에서는 규칙적인 부분구조가 반드시 존재함을 연구",
        "formulas": [
          "R(r,s): 최소 n where Kₙ 2색칠에 Kr 또는 Ks 단색 존재",
          "R(3,3) = 6",
          "R(4,4) = 18"
        ],
        "examples": ["파티 문제", "반데르바르덴 정리", "헤일스-주엣 정리"],
        "applications": ["조합론", "컴퓨터과학", "논리학"]
      },
      "en": {
        "definition": "Study of conditions guaranteeing regular substructures in large enough structures",
        "formulas": [
          "R(r,s): min n where Kₙ 2-coloring has mono Kr or Ks",
          "R(3,3) = 6",
          "R(4,4) = 18"
        ],
        "examples": ["Party problem", "Van der Waerden theorem", "Hales-Jewett theorem"],
        "applications": ["Combinatorics", "Computer science", "Logic"]
      }
    },
    "latex": "R(r,s) = \\min\\{n : K_n \\to K_r \\text{ or } K_s\\}",
    "relations": {
      "prerequisites": ["graph-theory", "pigeonhole-principle"],
      "nextTopics": ["extremal-graph-theory"],
      "related": ["probabilistic-method"],
      "applications": ["theoretical-cs", "logic"]
    },
    "tags": ["램지", "Ramsey", "극값", "extremal"]
  },
  {
    "id": "partition-theory",
    "name": { "ko": "분할 이론", "en": "Partition Theory" },
    "field": "combinatorics",
    "subfield": "enumeration",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "양의 정수를 양의 정수들의 합으로 나타내는 방법을 연구",
        "formulas": [
          "p(n): n의 분할수",
          "Σp(n)xⁿ = ∏1/(1-xᵏ)",
          "오일러 항등식",
          "하디-라마누잔 점근식"
        ],
        "examples": ["p(5) = 7: 5=4+1=3+2=3+1+1=...", "영 다이어그램"],
        "applications": ["정수론", "표현론", "물리학"]
      },
      "en": {
        "definition": "Study of ways to represent positive integers as sums of positive integers",
        "formulas": [
          "p(n): partition number of n",
          "Σp(n)xⁿ = ∏1/(1-xᵏ)",
          "Euler identities",
          "Hardy-Ramanujan asymptotic"
        ],
        "examples": ["p(5) = 7: 5=4+1=3+2=3+1+1=...", "Young diagrams"],
        "applications": ["Number theory", "Representation theory", "Physics"]
      }
    },
    "latex": "\\sum_{n=0}^{\\infty} p(n)x^n = \\prod_{k=1}^{\\infty} \\frac{1}{1-x^k}",
    "relations": {
      "prerequisites": ["generating-functions", "number-theory"],
      "nextTopics": ["young-tableaux"],
      "related": ["modular-forms"],
      "applications": ["representation-theory", "physics"]
    },
    "tags": ["분할", "partition", "정수", "integer"]
  },
  {
    "id": "mobius-inversion",
    "name": { "ko": "뫼비우스 반전", "en": "Möbius Inversion" },
    "field": "combinatorics",
    "subfield": "enumeration",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "포셋(부분순서집합)에서 함수들 사이의 반전 공식",
        "formulas": [
          "g(n) = Σf(d) ⟹ f(n) = Σμ(n/d)g(d)",
          "뫼비우스 함수: μ(1)=1, μ(소수곱)=(-1)^k",
          "포셋: g = f*ζ ⟹ f = g*μ"
        ],
        "examples": ["오일러 토션트 함수", "포함-배제 원리"],
        "applications": ["정수론", "조합론", "암호학"]
      },
      "en": {
        "definition": "Inversion formula between functions on posets (partially ordered sets)",
        "formulas": [
          "g(n) = Σf(d) ⟹ f(n) = Σμ(n/d)g(d)",
          "Möbius function: μ(1)=1, μ(squarefree)=(-1)^k",
          "Poset: g = f*ζ ⟹ f = g*μ"
        ],
        "examples": ["Euler totient function", "Inclusion-exclusion principle"],
        "applications": ["Number theory", "Combinatorics", "Cryptography"]
      }
    },
    "latex": "f(n) = \\sum_{d|n} \\mu(n/d) g(d)",
    "relations": {
      "prerequisites": ["divisibility", "poset"],
      "nextTopics": ["analytic-number-theory"],
      "related": ["inclusion-exclusion"],
      "applications": ["number-theory", "combinatorics"]
    },
    "tags": ["뫼비우스", "Möbius", "반전", "inversion"]
  },
  {
    "id": "probabilistic-method",
    "name": { "ko": "확률적 방법", "en": "Probabilistic Method" },
    "field": "combinatorics",
    "subfield": "techniques",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "확률 논증을 사용하여 조합 구조의 존재를 증명하는 방법",
        "formulas": [
          "P(A) > 0 ⟹ A 원소 존재",
          "기댓값 논증: E[X] > 0 ⟹ X > 0인 경우 존재",
          "로바스 국소 보조정리"
        ],
        "examples": ["램지 수 하계", "색칠 수", "완전 매칭"],
        "applications": ["그래프 이론", "조합 최적화", "알고리즘"]
      },
      "en": {
        "definition": "Method using probabilistic arguments to prove existence of combinatorial structures",
        "formulas": [
          "P(A) > 0 ⟹ element of A exists",
          "Expectation: E[X] > 0 ⟹ case with X > 0 exists",
          "Lovász Local Lemma"
        ],
        "examples": ["Ramsey number bounds", "Chromatic numbers", "Perfect matchings"],
        "applications": ["Graph theory", "Combinatorial optimization", "Algorithms"]
      }
    },
    "latex": "P(A) > 0 \\Rightarrow \\exists x \\in A",
    "relations": {
      "prerequisites": ["probability", "expectation"],
      "nextTopics": ["derandomization"],
      "related": ["ramsey-theory"],
      "applications": ["existence-proofs", "algorithms"]
    },
    "tags": ["확률적방법", "probabilistic", "Erdős", "existence"]
  },
  {
    "id": "group-representation",
    "name": { "ko": "군의 표현", "en": "Group Representation" },
    "field": "representation-theory",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "군을 벡터공간의 가역 선형변환들의 군으로 실현하는 준동형",
        "formulas": ["ρ: G → GL(V)", "ρ(gh) = ρ(g)ρ(h)", "차원 = dim V"],
        "examples": ["순환군의 표현", "대칭군 Sₙ의 표현", "자명한 표현"],
        "applications": ["양자역학", "화학", "물리학"]
      },
      "en": {
        "definition": "Homomorphism realizing group as group of invertible linear transformations on vector space",
        "formulas": ["ρ: G → GL(V)", "ρ(gh) = ρ(g)ρ(h)", "Degree = dim V"],
        "examples": [
          "Cyclic group representations",
          "Symmetric group Sₙ",
          "Trivial representation"
        ],
        "applications": ["Quantum mechanics", "Chemistry", "Physics"]
      }
    },
    "latex": "\\rho: G \\to GL(V)",
    "relations": {
      "prerequisites": ["group-theory", "linear-algebra"],
      "nextTopics": ["irreducible-representation", "character-theory"],
      "related": ["module-theory"],
      "applications": ["physics", "chemistry"]
    },
    "tags": ["표현", "representation", "군", "group"]
  },
  {
    "id": "irreducible-representation",
    "name": { "ko": "기약 표현", "en": "Irreducible Representation" },
    "field": "representation-theory",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "비자명한 진부분 표현을 갖지 않는 표현. 표현론의 기본 구성 요소",
        "formulas": [
          "마슈케 정리: 유한군, char=0이면 완전 가약",
          "슈어 보조정리: Hom(V,W) = 0 또는 동형"
        ],
        "examples": ["1차원 표현", "S₃의 2차원 기약 표현"],
        "applications": ["분류 문제", "양자역학", "입자물리"]
      },
      "en": {
        "definition": "Representation with no nontrivial proper subrepresentations. Building blocks of representation theory",
        "formulas": [
          "Maschke: finite group, char=0 ⟹ completely reducible",
          "Schur lemma: Hom(V,W) = 0 or isomorphism"
        ],
        "examples": ["1-dimensional representations", "S₃ 2-dim irreducible"],
        "applications": ["Classification", "Quantum mechanics", "Particle physics"]
      }
    },
    "latex": "V = V_1 \\oplus V_2 \\oplus \\cdots \\oplus V_k",
    "relations": {
      "prerequisites": ["group-representation"],
      "nextTopics": ["character-theory"],
      "related": ["simple-module"],
      "applications": ["quantum-mechanics", "particle-physics"]
    },
    "tags": ["기약", "irreducible", "단순", "simple"]
  },
  {
    "id": "character-theory",
    "name": { "ko": "지표 이론", "en": "Character Theory" },
    "field": "representation-theory",
    "subfield": "characters",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "표현의 대각합(트레이스)을 통해 표현을 연구하는 방법",
        "formulas": [
          "χ_V(g) = tr(ρ(g))",
          "직교성: ⟨χ_V, χ_W⟩ = δ_{V,W}",
          "지표표",
          "정규 표현 분해"
        ],
        "examples": ["S₃의 지표표", "순환군의 지표"],
        "applications": ["표현 분류", "분자 대칭", "번사이드 정리"]
      },
      "en": {
        "definition": "Study of representations through trace (diagonal sum) of matrices",
        "formulas": [
          "χ_V(g) = tr(ρ(g))",
          "Orthogonality: ⟨χ_V, χ_W⟩ = δ_{V,W}",
          "Character table",
          "Regular rep decomposition"
        ],
        "examples": ["Character table of S₃", "Characters of cyclic groups"],
        "applications": ["Representation classification", "Molecular symmetry", "Burnside theorem"]
      }
    },
    "latex": "\\chi_V(g) = \\text{tr}(\\rho(g))",
    "relations": {
      "prerequisites": ["group-representation", "trace"],
      "nextTopics": ["induced-representation"],
      "related": ["harmonic-analysis"],
      "applications": ["chemistry", "physics"]
    },
    "tags": ["지표", "character", "trace", "대각합"]
  },
  {
    "id": "young-tableaux",
    "name": { "ko": "영 타블로", "en": "Young Tableaux" },
    "field": "representation-theory",
    "subfield": "symmetric-group",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "대칭군의 기약 표현을 기술하고 조합론적으로 계산하는 도구",
        "formulas": [
          "영 다이어그램: λ = (λ₁ ≥ λ₂ ≥ ...)",
          "표준 타블로: 행/열 증가",
          "훅 길이 공식: dim = n!/∏hook"
        ],
        "examples": ["(3,2)에 대한 S₅ 표현", "로빈슨-셴스테드 대응"],
        "applications": ["대칭군 표현", "슈어 함수", "양자군"]
      },
      "en": {
        "definition": "Tool for describing and computing irreducible representations of symmetric group",
        "formulas": [
          "Young diagram: λ = (λ₁ ≥ λ₂ ≥ ...)",
          "Standard tableau: rows/cols increasing",
          "Hook length: dim = n!/∏hook"
        ],
        "examples": ["S₅ rep for (3,2)", "Robinson-Schensted correspondence"],
        "applications": ["Symmetric group reps", "Schur functions", "Quantum groups"]
      }
    },
    "latex": "\\dim V_\\lambda = \\frac{n!}{\\prod_{\\text{boxes}} \\text{hook length}}",
    "relations": {
      "prerequisites": ["symmetric-group", "partition-theory"],
      "nextTopics": ["schur-functions"],
      "related": ["combinatorics"],
      "applications": ["algebraic-combinatorics"]
    },
    "tags": ["영타블로", "Young", "tableau", "symmetric"]
  },
  {
    "id": "lie-algebra-representation",
    "name": { "ko": "리 대수의 표현", "en": "Lie Algebra Representation" },
    "field": "representation-theory",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "리 대수를 벡터공간의 자기준동형으로 실현하는 준동형",
        "formulas": ["ρ: 𝔤 → gl(V)", "ρ([X,Y]) = [ρ(X), ρ(Y)]", "최고 무게 표현"],
        "examples": ["sl(2,ℂ)의 유한차원 표현", "수반 표현"],
        "applications": ["양자역학", "입자물리학", "미분기하학"]
      },
      "en": {
        "definition": "Homomorphism realizing Lie algebra as endomorphisms of vector space",
        "formulas": ["ρ: 𝔤 → gl(V)", "ρ([X,Y]) = [ρ(X), ρ(Y)]", "Highest weight representations"],
        "examples": ["Finite-dim reps of sl(2,ℂ)", "Adjoint representation"],
        "applications": ["Quantum mechanics", "Particle physics", "Differential geometry"]
      }
    },
    "latex": "\\rho([X,Y]) = [\\rho(X), \\rho(Y)]",
    "relations": {
      "prerequisites": ["lie-groups", "linear-algebra"],
      "nextTopics": ["root-systems", "weyl-group"],
      "related": ["group-representation"],
      "applications": ["physics", "geometry"]
    },
    "tags": ["리대수", "Lie", "표현", "representation"]
  },
  {
    "id": "root-systems",
    "name": { "ko": "근계", "en": "Root Systems" },
    "field": "representation-theory",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "반단순 리 대수의 구조를 기술하는 유한 벡터 집합",
        "formulas": [
          "반사: sα(β) = β - 2⟨α,β⟩/⟨α,α⟩ α",
          "카르탄 행렬: Aᵢⱼ = 2⟨αᵢ,αⱼ⟩/⟨αᵢ,αᵢ⟩",
          "딘킨 도표"
        ],
        "examples": ["Aₙ (sl(n+1))", "Bₙ, Cₙ, Dₙ", "예외형: G₂, F₄, E₆, E₇, E₈"],
        "applications": ["리 대수 분류", "양자군", "물리학"]
      },
      "en": {
        "definition": "Finite set of vectors describing structure of semisimple Lie algebras",
        "formulas": [
          "Reflection: sα(β) = β - 2⟨α,β⟩/⟨α,α⟩ α",
          "Cartan matrix: Aᵢⱼ = 2⟨αᵢ,αⱼ⟩/⟨αᵢ,αᵢ⟩",
          "Dynkin diagrams"
        ],
        "examples": ["Aₙ (sl(n+1))", "Bₙ, Cₙ, Dₙ", "Exceptional: G₂, F₄, E₆, E₇, E₈"],
        "applications": ["Lie algebra classification", "Quantum groups", "Physics"]
      }
    },
    "latex": "s_\\alpha(\\beta) = \\beta - \\frac{2\\langle\\alpha,\\beta\\rangle}{\\langle\\alpha,\\alpha\\rangle}\\alpha",
    "relations": {
      "prerequisites": ["lie-algebra-representation", "linear-algebra"],
      "nextTopics": ["weyl-group", "highest-weight"],
      "related": ["cartan-subalgebra"],
      "applications": ["classification", "physics"]
    },
    "tags": ["근계", "root", "Dynkin", "Cartan"]
  },
  {
    "id": "tensor-product-rep",
    "name": { "ko": "텐서곱 표현", "en": "Tensor Product Representation" },
    "field": "representation-theory",
    "subfield": "constructions",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "두 표현의 텐서곱으로 새로운 표현을 구성하는 방법",
        "formulas": [
          "V ⊗ W",
          "g(v ⊗ w) = gv ⊗ gw",
          "χ_{V⊗W}(g) = χ_V(g)χ_W(g)",
          "클렙쉬-고르단 분해"
        ],
        "examples": ["SU(2)의 스핀 결합", "양자 얽힘 상태"],
        "applications": ["양자역학", "입자물리", "양자정보"]
      },
      "en": {
        "definition": "Constructing new representations from tensor product of two representations",
        "formulas": [
          "V ⊗ W",
          "g(v ⊗ w) = gv ⊗ gw",
          "χ_{V⊗W}(g) = χ_V(g)χ_W(g)",
          "Clebsch-Gordan decomposition"
        ],
        "examples": ["SU(2) spin coupling", "Quantum entangled states"],
        "applications": ["Quantum mechanics", "Particle physics", "Quantum information"]
      }
    },
    "latex": "\\chi_{V \\otimes W}(g) = \\chi_V(g) \\chi_W(g)",
    "relations": {
      "prerequisites": ["group-representation", "tensor-product"],
      "nextTopics": ["clebsch-gordan"],
      "related": ["character-theory"],
      "applications": ["quantum-physics"]
    },
    "tags": ["텐서곱", "tensor", "표현", "product"]
  },
  {
    "id": "induced-representation",
    "name": { "ko": "유도 표현", "en": "Induced Representation" },
    "field": "representation-theory",
    "subfield": "constructions",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "부분군의 표현에서 전체 군의 표현을 구성하는 방법",
        "formulas": [
          "Ind_H^G V = ℂ[G] ⊗_{ℂ[H]} V",
          "프로베니우스 상호성: ⟨Ind V, W⟩_G = ⟨V, Res W⟩_H",
          "dim Ind V = [G:H] dim V"
        ],
        "examples": ["순환군에서 대칭군으로 유도", "정규 표현 = Ind_1^G 1"],
        "applications": ["표현 구성", "맥키 정리", "해석적 정수론"]
      },
      "en": {
        "definition": "Constructing representation of group from representation of subgroup",
        "formulas": [
          "Ind_H^G V = ℂ[G] ⊗_{ℂ[H]} V",
          "Frobenius reciprocity: ⟨Ind V, W⟩_G = ⟨V, Res W⟩_H",
          "dim Ind V = [G:H] dim V"
        ],
        "examples": ["Inducing from cyclic to symmetric", "Regular rep = Ind_1^G 1"],
        "applications": ["Representation construction", "Mackey theory", "Analytic number theory"]
      }
    },
    "latex": "\\text{Ind}_H^G V = \\mathbb{C}[G] \\otimes_{\\mathbb{C}[H]} V",
    "relations": {
      "prerequisites": ["group-representation", "tensor-product"],
      "nextTopics": ["mackey-theory"],
      "related": ["restriction"],
      "applications": ["number-theory", "physics"]
    },
    "tags": ["유도", "induced", "Frobenius", "induction"]
  },
  {
    "id": "chain-complex",
    "name": { "ko": "사슬 복합체", "en": "Chain Complex" },
    "field": "homological-algebra",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "경계 사상의 합성이 0인 모듈(또는 아벨군)들의 열",
        "formulas": [
          "...→ Cₙ₊₁ →^{∂ₙ₊₁} Cₙ →^{∂ₙ} Cₙ₋₁ →...",
          "∂ₙ ∘ ∂ₙ₊₁ = 0",
          "Hₙ(C) = ker ∂ₙ / im ∂ₙ₊₁"
        ],
        "examples": ["단체 복합체", "셀룰러 복합체", "드람 복합체"],
        "applications": ["위상수학", "대수기하", "물리학"]
      },
      "en": {
        "definition": "Sequence of modules (or abelian groups) where composition of boundary maps is zero",
        "formulas": [
          "...→ Cₙ₊₁ →^{∂ₙ₊₁} Cₙ →^{∂ₙ} Cₙ₋₁ →...",
          "∂ₙ ∘ ∂ₙ₊₁ = 0",
          "Hₙ(C) = ker ∂ₙ / im ∂ₙ₊₁"
        ],
        "examples": ["Simplicial complex", "Cellular complex", "de Rham complex"],
        "applications": ["Topology", "Algebraic geometry", "Physics"]
      }
    },
    "latex": "\\partial_n \\circ \\partial_{n+1} = 0",
    "relations": {
      "prerequisites": ["module-theory", "abelian-groups"],
      "nextTopics": ["homology", "exact-sequence"],
      "related": ["cohomology"],
      "applications": ["topology", "algebra"]
    },
    "tags": ["사슬", "chain", "복합체", "complex"]
  },
  {
    "id": "exact-sequence",
    "name": { "ko": "완전열", "en": "Exact Sequence" },
    "field": "homological-algebra",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "각 위치에서 상(image)이 다음 핵(kernel)과 같은 사상들의 열",
        "formulas": ["...→ A →^f B →^g C →...", "im f = ker g", "단완전열: 0 → A → B → C → 0"],
        "examples": ["0 → ℤ →^{×2} ℤ → ℤ/2ℤ → 0", "분할되는 완전열"],
        "applications": ["확장 문제", "호몰로지", "대수적 K-이론"]
      },
      "en": {
        "definition": "Sequence of maps where image at each position equals kernel of next map",
        "formulas": ["...→ A →^f B →^g C →...", "im f = ker g", "Short exact: 0 → A → B → C → 0"],
        "examples": ["0 → ℤ →^{×2} ℤ → ℤ/2ℤ → 0", "Split exact sequence"],
        "applications": ["Extension problems", "Homology", "Algebraic K-theory"]
      }
    },
    "latex": "\\text{im } f = \\ker g",
    "relations": {
      "prerequisites": ["kernel", "image", "homomorphism"],
      "nextTopics": ["long-exact-sequence", "snake-lemma"],
      "related": ["chain-complex"],
      "applications": ["algebra", "topology"]
    },
    "tags": ["완전열", "exact", "sequence", "kernel"]
  },
  {
    "id": "derived-functor",
    "name": { "ko": "유도 함자", "en": "Derived Functor" },
    "field": "homological-algebra",
    "subfield": "functors",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "완전하지 않은 함자를 \"수정\"하여 얻는 함자의 모임",
        "formulas": ["Lₙ F (좌유도)", "Rⁿ F (우유도)", "Ext, Tor 함자"],
        "examples": ["Extⁿ(A,B) = Rⁿ Hom(A,-)(B)", "Torₙ(A,B) = Lₙ (A⊗-)(B)"],
        "applications": ["확장 분류", "호몰로지 대수", "대수기하"]
      },
      "en": {
        "definition": "Collection of functors obtained by \"correcting\" non-exact functors",
        "formulas": ["Lₙ F (left derived)", "Rⁿ F (right derived)", "Ext, Tor functors"],
        "examples": ["Extⁿ(A,B) = Rⁿ Hom(A,-)(B)", "Torₙ(A,B) = Lₙ (A⊗-)(B)"],
        "applications": ["Extension classification", "Homological algebra", "Algebraic geometry"]
      }
    },
    "latex": "R^n F, \\; L_n F",
    "relations": {
      "prerequisites": ["functor", "exact-sequence", "resolution"],
      "nextTopics": ["spectral-sequence"],
      "related": ["ext-functor", "tor-functor"],
      "applications": ["algebraic-geometry", "representation-theory"]
    },
    "tags": ["유도", "derived", "함자", "functor"]
  },
  {
    "id": "ext-functor",
    "name": { "ko": "Ext 함자", "en": "Ext Functor" },
    "field": "homological-algebra",
    "subfield": "functors",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "Hom 함자의 우유도 함자. 모듈 확장을 분류",
        "formulas": ["Extⁿ(A,B) = Rⁿ Hom(A,-)(B)", "Ext¹(A,B): 0→B→E→A→0 확장", "긴 완전열"],
        "examples": ["Ext¹(ℤ/n, ℤ) = ℤ/n", "Ext¹(ℤ, ℤ) = 0"],
        "applications": ["확장 이론", "코호몰로지", "표현론"]
      },
      "en": {
        "definition": "Right derived functor of Hom. Classifies module extensions",
        "formulas": [
          "Extⁿ(A,B) = Rⁿ Hom(A,-)(B)",
          "Ext¹(A,B): 0→B→E→A→0 extensions",
          "Long exact sequence"
        ],
        "examples": ["Ext¹(ℤ/n, ℤ) = ℤ/n", "Ext¹(ℤ, ℤ) = 0"],
        "applications": ["Extension theory", "Cohomology", "Representation theory"]
      }
    },
    "latex": "\\text{Ext}^n(A,B) = R^n \\text{Hom}(A,-)(B)",
    "relations": {
      "prerequisites": ["derived-functor", "hom-functor"],
      "nextTopics": ["group-cohomology"],
      "related": ["tor-functor"],
      "applications": ["cohomology", "extensions"]
    },
    "tags": ["Ext", "확장", "extension", "derived"]
  },
  {
    "id": "tor-functor",
    "name": { "ko": "Tor 함자", "en": "Tor Functor" },
    "field": "homological-algebra",
    "subfield": "functors",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "텐서곱 함자의 좌유도 함자. 텐서곱의 \"비틀림\"을 측정",
        "formulas": [
          "Torₙ(A,B) = Lₙ(A⊗-)(B)",
          "Tor₁(A,B): 텐서곱의 비자명한 관계",
          "평탄 모듈: Tor₁(-,F) = 0"
        ],
        "examples": ["Tor₁(ℤ/m, ℤ/n) = ℤ/gcd(m,n)", "Tor(A,B) = 0 if A or B free"],
        "applications": ["평탄성", "대수기하", "호몰로지"]
      },
      "en": {
        "definition": "Left derived functor of tensor product. Measures \"torsion\" in tensor product",
        "formulas": [
          "Torₙ(A,B) = Lₙ(A⊗-)(B)",
          "Tor₁(A,B): nontrivial relations in tensor",
          "Flat module: Tor₁(-,F) = 0"
        ],
        "examples": ["Tor₁(ℤ/m, ℤ/n) = ℤ/gcd(m,n)", "Tor(A,B) = 0 if A or B free"],
        "applications": ["Flatness", "Algebraic geometry", "Homology"]
      }
    },
    "latex": "\\text{Tor}_n(A,B) = L_n(A \\otimes -)(B)",
    "relations": {
      "prerequisites": ["derived-functor", "tensor-product"],
      "nextTopics": ["flatness"],
      "related": ["ext-functor"],
      "applications": ["flatness", "homology"]
    },
    "tags": ["Tor", "비틀림", "torsion", "derived"]
  },
  {
    "id": "spectral-sequence",
    "name": { "ko": "스펙트럴 수열", "en": "Spectral Sequence" },
    "field": "homological-algebra",
    "subfield": "advanced",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "호몰로지를 단계적으로 계산하는 대수적 도구",
        "formulas": ["Eᵣ^{p,q} ⟹ Hⁿ", "dᵣ: Eᵣ^{p,q} → Eᵣ^{p+r,q-r+1}", "Eᵣ₊₁ = H(Eᵣ, dᵣ)"],
        "examples": ["세르 스펙트럴 수열", "그로텐딕 스펙트럴 수열", "레레이 스펙트럴 수열"],
        "applications": ["호몰로지 계산", "위상수학", "대수기하"]
      },
      "en": {
        "definition": "Algebraic tool for computing homology in stages",
        "formulas": ["Eᵣ^{p,q} ⟹ Hⁿ", "dᵣ: Eᵣ^{p,q} → Eᵣ^{p+r,q-r+1}", "Eᵣ₊₁ = H(Eᵣ, dᵣ)"],
        "examples": [
          "Serre spectral sequence",
          "Grothendieck spectral sequence",
          "Leray spectral sequence"
        ],
        "applications": ["Homology computation", "Topology", "Algebraic geometry"]
      }
    },
    "latex": "E_r^{p,q} \\Rightarrow H^{p+q}",
    "relations": {
      "prerequisites": ["chain-complex", "derived-functor"],
      "nextTopics": ["derived-category"],
      "related": ["filtration"],
      "applications": ["topology", "algebraic-geometry"]
    },
    "tags": ["스펙트럴", "spectral", "수열", "sequence"]
  },
  {
    "id": "projective-module",
    "name": { "ko": "사영 모듈", "en": "Projective Module" },
    "field": "homological-algebra",
    "subfield": "modules",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "자유 모듈의 직합인수. 사영 분해의 기본 구성 요소",
        "formulas": [
          "리프팅: P →f A →^π B → 0, ∃g: P → A with πg = f",
          "동치: 분할되는 전사의 정의역",
          "동치: Hom(P,-)가 완전"
        ],
        "examples": ["자유 모듈", "ℤ/6 위의 ℤ/2 ⊕ ℤ/3"],
        "applications": ["호몰로지", "대수적 K-이론", "표현론"]
      },
      "en": {
        "definition": "Direct summand of free module. Building block for projective resolutions",
        "formulas": [
          "Lifting: P →f A →^π B → 0, ∃g: P → A with πg = f",
          "Equiv: domain of split epimorphism",
          "Equiv: Hom(P,-) exact"
        ],
        "examples": ["Free modules", "ℤ/2 ⊕ ℤ/3 over ℤ/6"],
        "applications": ["Homology", "Algebraic K-theory", "Representation theory"]
      }
    },
    "latex": "\\text{Hom}(P, -) \\text{ is exact}",
    "relations": {
      "prerequisites": ["module-theory", "exact-sequence"],
      "nextTopics": ["projective-resolution"],
      "related": ["injective-module", "flat-module"],
      "applications": ["resolutions", "k-theory"]
    },
    "tags": ["사영", "projective", "모듈", "module"]
  },
  {
    "id": "injective-module",
    "name": { "ko": "단사 모듈", "en": "Injective Module" },
    "field": "homological-algebra",
    "subfield": "modules",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "단사 분해의 기본 구성 요소. 사영 모듈의 쌍대",
        "formulas": [
          "확장: 0 → A →^ι B → C, ∃g: B → I with gι = f",
          "동치: 분할되는 단사의 공역",
          "동치: Hom(-,I)가 완전",
          "베어 기준"
        ],
        "examples": ["ℚ/ℤ", "나눗셈군"],
        "applications": ["호몰로지", "층 이론", "대수기하"]
      },
      "en": {
        "definition": "Building block for injective resolutions. Dual of projective module",
        "formulas": [
          "Extension: 0 → A →^ι B → C, ∃g: B → I with gι = f",
          "Equiv: codomain of split mono",
          "Equiv: Hom(-,I) exact",
          "Baer criterion"
        ],
        "examples": ["ℚ/ℤ", "Divisible groups"],
        "applications": ["Homology", "Sheaf theory", "Algebraic geometry"]
      }
    },
    "latex": "\\text{Hom}(-, I) \\text{ is exact}",
    "relations": {
      "prerequisites": ["module-theory", "exact-sequence"],
      "nextTopics": ["injective-resolution"],
      "related": ["projective-module"],
      "applications": ["sheaves", "cohomology"]
    },
    "tags": ["단사", "injective", "모듈", "module"]
  },
  {
    "id": "euler-lagrange-equation",
    "name": { "ko": "오일러-라그랑주 방정식", "en": "Euler-Lagrange Equation" },
    "field": "calculus-of-variations",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "범함수의 극값을 구하기 위한 필요조건. 변분법의 기본 방정식",
        "formulas": ["J[y] = ∫L(x,y,y')dx", "∂L/∂y - d/dx(∂L/∂y') = 0", "자연 경계조건"],
        "examples": ["최단 경로 (측지선)", "현수선", "브라키스토크론"],
        "applications": ["고전역학", "광학", "최적 제어"]
      },
      "en": {
        "definition": "Necessary condition for extrema of functionals. Fundamental equation of calculus of variations",
        "formulas": [
          "J[y] = ∫L(x,y,y')dx",
          "∂L/∂y - d/dx(∂L/∂y') = 0",
          "Natural boundary conditions"
        ],
        "examples": ["Shortest path (geodesic)", "Catenary", "Brachistochrone"],
        "applications": ["Classical mechanics", "Optics", "Optimal control"]
      }
    },
    "latex": "\\frac{\\partial L}{\\partial y} - \\frac{d}{dx}\\frac{\\partial L}{\\partial y'} = 0",
    "relations": {
      "prerequisites": ["multivariable-calculus", "differential-equations"],
      "nextTopics": ["hamiltons-principle", "optimal-control"],
      "related": ["lagrangian-mechanics"],
      "applications": ["physics", "engineering"]
    },
    "tags": ["오일러라그랑주", "Euler-Lagrange", "변분", "variation"]
  },
  {
    "id": "hamiltons-principle",
    "name": { "ko": "해밀턴의 원리", "en": "Hamilton's Principle" },
    "field": "calculus-of-variations",
    "subfield": "mechanics",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "물리계의 실제 경로는 작용을 정류시키는 경로. 고전역학의 변분 원리",
        "formulas": ["δS = 0", "S = ∫L dt = ∫(T - V)dt", "L = 운동에너지 - 위치에너지"],
        "examples": ["자유 입자", "조화 진동자", "행성 운동"],
        "applications": ["고전역학", "장이론", "양자역학"]
      },
      "en": {
        "definition": "Actual path of physical system makes action stationary. Variational principle of classical mechanics",
        "formulas": ["δS = 0", "S = ∫L dt = ∫(T - V)dt", "L = Kinetic - Potential energy"],
        "examples": ["Free particle", "Harmonic oscillator", "Planetary motion"],
        "applications": ["Classical mechanics", "Field theory", "Quantum mechanics"]
      }
    },
    "latex": "\\delta S = \\delta \\int L \\, dt = 0",
    "relations": {
      "prerequisites": ["euler-lagrange-equation", "newtons-laws"],
      "nextTopics": ["hamiltonian-mechanics"],
      "related": ["fermats-principle"],
      "applications": ["physics", "field-theory"]
    },
    "tags": ["해밀턴", "Hamilton", "작용", "action"]
  },
  {
    "id": "brachistochrone",
    "name": { "ko": "브라키스토크론 문제", "en": "Brachistochrone Problem" },
    "field": "calculus-of-variations",
    "subfield": "classic-problems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "중력장에서 두 점 사이를 가장 빠르게 이동하는 곡선을 찾는 문제",
        "formulas": [
          "T = ∫ds/v = ∫√(1+y'²)/√(2gy) dx",
          "해: 사이클로이드",
          "x = a(θ - sinθ), y = a(1 - cosθ)"
        ],
        "examples": ["롤러코스터 설계", "스키 점프대"],
        "applications": ["물리학", "최적화", "역사적 중요성"]
      },
      "en": {
        "definition": "Finding curve of fastest descent between two points in gravitational field",
        "formulas": [
          "T = ∫ds/v = ∫√(1+y'²)/√(2gy) dx",
          "Solution: cycloid",
          "x = a(θ - sinθ), y = a(1 - cosθ)"
        ],
        "examples": ["Roller coaster design", "Ski jump ramps"],
        "applications": ["Physics", "Optimization", "Historical importance"]
      }
    },
    "latex": "x = a(\\theta - \\sin\\theta), \\; y = a(1 - \\cos\\theta)",
    "relations": {
      "prerequisites": ["euler-lagrange-equation"],
      "nextTopics": ["isoperimetric-problem"],
      "related": ["cycloid"],
      "applications": ["physics", "optimization"]
    },
    "tags": ["브라키스토크론", "brachistochrone", "사이클로이드", "cycloid"]
  },
  {
    "id": "isoperimetric-problem",
    "name": { "ko": "등주 문제", "en": "Isoperimetric Problem" },
    "field": "calculus-of-variations",
    "subfield": "classic-problems",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "주어진 둘레로 최대 넓이를 갖는 도형을 찾는 문제. 원이 해답",
        "formulas": ["max A = ∬dA, subject to ∮ds = L", "라그랑주 승수: δ(A - λP) = 0", "해: 원"],
        "examples": ["비누방울", "세포 형태", "동물 영역"],
        "applications": ["생물학", "건축", "최적화"]
      },
      "en": {
        "definition": "Finding shape with maximum area for given perimeter. Circle is the solution",
        "formulas": [
          "max A = ∬dA, subject to ∮ds = L",
          "Lagrange multiplier: δ(A - λP) = 0",
          "Solution: circle"
        ],
        "examples": ["Soap bubbles", "Cell shapes", "Animal territories"],
        "applications": ["Biology", "Architecture", "Optimization"]
      }
    },
    "latex": "\\frac{A}{P^2} \\leq \\frac{1}{4\\pi}",
    "relations": {
      "prerequisites": ["euler-lagrange-equation", "lagrange-multiplier"],
      "nextTopics": ["plateau-problem"],
      "related": ["geometric-optimization"],
      "applications": ["biology", "design"]
    },
    "tags": ["등주", "isoperimetric", "넓이", "perimeter"]
  },
  {
    "id": "pontryagin-maximum",
    "name": { "ko": "폰트랴긴 최대 원리", "en": "Pontryagin Maximum Principle" },
    "field": "calculus-of-variations",
    "subfield": "optimal-control",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "최적 제어 문제의 필요조건. 해밀토니안 최대화",
        "formulas": [
          "ẋ = f(x,u), min J = ∫L dt + Φ(x_f)",
          "H = p·f - L",
          "∂H/∂u = 0 또는 경계",
          "ṗ = -∂H/∂x"
        ],
        "examples": ["로켓 궤적", "경제 성장 모델", "자원 관리"],
        "applications": ["항공우주", "경제학", "로봇공학"]
      },
      "en": {
        "definition": "Necessary conditions for optimal control problems. Hamiltonian maximization",
        "formulas": [
          "ẋ = f(x,u), min J = ∫L dt + Φ(x_f)",
          "H = p·f - L",
          "∂H/∂u = 0 or boundary",
          "ṗ = -∂H/∂x"
        ],
        "examples": ["Rocket trajectories", "Economic growth models", "Resource management"],
        "applications": ["Aerospace", "Economics", "Robotics"]
      }
    },
    "latex": "H(x^*, u^*, p) \\geq H(x^*, u, p)",
    "relations": {
      "prerequisites": ["euler-lagrange-equation", "hamiltons-principle"],
      "nextTopics": ["dynamic-programming-or", "bang-bang-control"],
      "related": ["bellman-equation"],
      "applications": ["control-theory", "economics"]
    },
    "tags": ["폰트랴긴", "Pontryagin", "최적제어", "optimal-control"]
  },
  {
    "id": "direct-methods",
    "name": { "ko": "직접 방법", "en": "Direct Methods" },
    "field": "calculus-of-variations",
    "subfield": "methods",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "범함수의 극값 존재를 함수공간의 컴팩트성과 하반연속성으로 증명",
        "formulas": ["J: X → ℝ 하반연속, 강제적", "inf J 달성됨", "약수렴 + 하반연속성"],
        "examples": ["디리클레 원리", "탄성 에너지 최소화", "PDE 약해 존재"],
        "applications": ["편미분방정식", "탄성이론", "기하학"]
      },
      "en": {
        "definition": "Proving existence of extrema using compactness and lower semicontinuity in function spaces",
        "formulas": [
          "J: X → ℝ lower semicontinuous, coercive",
          "inf J attained",
          "Weak convergence + lower semicontinuity"
        ],
        "examples": ["Dirichlet principle", "Elastic energy minimization", "PDE weak solutions"],
        "applications": ["PDEs", "Elasticity theory", "Geometry"]
      }
    },
    "latex": "\\inf_X J \\text{ is attained}",
    "relations": {
      "prerequisites": ["weak-convergence", "functional-analysis"],
      "nextTopics": ["gamma-convergence"],
      "related": ["sobolev-spaces"],
      "applications": ["pde", "mechanics"]
    },
    "tags": ["직접법", "direct", "변분", "existence"]
  },
  {
    "id": "fermats-principle",
    "name": { "ko": "페르마의 원리", "en": "Fermat's Principle" },
    "field": "calculus-of-variations",
    "subfield": "optics",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "빛은 두 점 사이를 최소 시간 경로로 이동. 광학의 변분 원리",
        "formulas": ["δT = δ∫ds/v = 0", "n = c/v", "광학 경로 길이: ∫n ds"],
        "examples": ["반사 법칙", "굴절 법칙 (스넬)", "신기루"],
        "applications": ["렌즈 설계", "광섬유", "기하광학"]
      },
      "en": {
        "definition": "Light travels the path of least time between two points. Variational principle of optics",
        "formulas": ["δT = δ∫ds/v = 0", "n = c/v", "Optical path length: ∫n ds"],
        "examples": ["Law of reflection", "Snell's law (refraction)", "Mirages"],
        "applications": ["Lens design", "Fiber optics", "Geometrical optics"]
      }
    },
    "latex": "\\delta \\int n \\, ds = 0",
    "relations": {
      "prerequisites": ["euler-lagrange-equation"],
      "nextTopics": ["hamiltons-principle"],
      "related": ["snells-law"],
      "applications": ["optics", "physics"]
    },
    "tags": ["페르마", "Fermat", "광학", "optics"]
  },
  {
    "id": "noethers-theorem",
    "name": { "ko": "뇌터의 정리", "en": "Noether's Theorem" },
    "field": "calculus-of-variations",
    "subfield": "symmetry",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "작용의 연속 대칭마다 보존량이 대응. 물리학의 근본 정리",
        "formulas": [
          "대칭 ⟹ 보존 법칙",
          "시간 불변 → 에너지 보존",
          "공간 불변 → 운동량 보존",
          "회전 불변 → 각운동량 보존"
        ],
        "examples": ["에너지-운동량-각운동량 보존", "게이지 대칭과 전하 보존"],
        "applications": ["입자물리학", "일반상대성이론", "장이론"]
      },
      "en": {
        "definition": "Every continuous symmetry of action corresponds to conservation law. Fundamental theorem of physics",
        "formulas": [
          "Symmetry ⟹ Conservation law",
          "Time invariance → Energy",
          "Space invariance → Momentum",
          "Rotation invariance → Angular momentum"
        ],
        "examples": [
          "Energy-momentum-angular momentum conservation",
          "Gauge symmetry and charge conservation"
        ],
        "applications": ["Particle physics", "General relativity", "Field theory"]
      }
    },
    "latex": "\\text{Symmetry} \\Leftrightarrow \\text{Conservation Law}",
    "relations": {
      "prerequisites": ["hamiltons-principle", "lie-groups"],
      "nextTopics": ["gauge-theory"],
      "related": ["conservation-laws"],
      "applications": ["physics", "field-theory"]
    },
    "tags": ["뇌터", "Noether", "대칭", "symmetry"]
  },
  {
    "id": "shannon-entropy",
    "name": { "ko": "섀넌 엔트로피", "en": "Shannon Entropy" },
    "field": "information-theory",
    "subfield": "foundations",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "확률변수의 불확실성을 측정하는 정보량. 정보이론의 기본 개념",
        "formulas": [
          "H(X) = -Σ p(x) log₂ p(x)",
          "H(X) ≥ 0",
          "최대: H = log₂ n (균등분포)",
          "결합 엔트로피: H(X,Y)"
        ],
        "examples": ["공정한 동전: H = 1 bit", "편향 동전: H < 1 bit"],
        "applications": ["데이터 압축", "암호학", "기계학습"]
      },
      "en": {
        "definition": "Measure of uncertainty of random variable. Fundamental concept of information theory",
        "formulas": [
          "H(X) = -Σ p(x) log₂ p(x)",
          "H(X) ≥ 0",
          "Maximum: H = log₂ n (uniform)",
          "Joint entropy: H(X,Y)"
        ],
        "examples": ["Fair coin: H = 1 bit", "Biased coin: H < 1 bit"],
        "applications": ["Data compression", "Cryptography", "Machine learning"]
      }
    },
    "latex": "H(X) = -\\sum_{x} p(x) \\log_2 p(x)",
    "relations": {
      "prerequisites": ["probability", "logarithm"],
      "nextTopics": ["mutual-information", "channel-capacity"],
      "related": ["thermodynamic-entropy"],
      "applications": ["compression", "machine-learning"]
    },
    "tags": ["섀넌", "Shannon", "엔트로피", "entropy"]
  },
  {
    "id": "mutual-information",
    "name": { "ko": "상호 정보량", "en": "Mutual Information" },
    "field": "information-theory",
    "subfield": "foundations",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "두 확률변수가 공유하는 정보량. 한 변수가 다른 변수에 대해 제공하는 정보",
        "formulas": [
          "I(X;Y) = H(X) + H(Y) - H(X,Y)",
          "I(X;Y) = H(X) - H(X|Y)",
          "I(X;Y) = Σ p(x,y) log(p(x,y)/(p(x)p(y)))"
        ],
        "examples": ["독립이면 I(X;Y) = 0", "결정적 관계면 I(X;Y) = H(X)"],
        "applications": ["특징 선택", "채널 용량", "인과 추론"]
      },
      "en": {
        "definition": "Information shared between two random variables. Information one provides about the other",
        "formulas": [
          "I(X;Y) = H(X) + H(Y) - H(X,Y)",
          "I(X;Y) = H(X) - H(X|Y)",
          "I(X;Y) = Σ p(x,y) log(p(x,y)/(p(x)p(y)))"
        ],
        "examples": ["Independent: I(X;Y) = 0", "Deterministic: I(X;Y) = H(X)"],
        "applications": ["Feature selection", "Channel capacity", "Causal inference"]
      }
    },
    "latex": "I(X;Y) = H(X) + H(Y) - H(X,Y)",
    "relations": {
      "prerequisites": ["shannon-entropy"],
      "nextTopics": ["channel-capacity"],
      "related": ["correlation"],
      "applications": ["feature-selection", "causality"]
    },
    "tags": ["상호정보", "mutual", "information", "dependence"]
  },
  {
    "id": "channel-capacity",
    "name": { "ko": "채널 용량", "en": "Channel Capacity" },
    "field": "information-theory",
    "subfield": "communication",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "잡음 채널을 통해 신뢰성 있게 전송 가능한 최대 정보량",
        "formulas": [
          "C = max_{p(x)} I(X;Y)",
          "섀넌 정리: R < C면 오류 0 가능",
          "BSC: C = 1 - H(p)",
          "AWGN: C = ½log(1 + S/N)"
        ],
        "examples": ["이진 대칭 채널", "소거 채널", "가우시안 채널"],
        "applications": ["통신 시스템", "데이터 저장", "네트워크"]
      },
      "en": {
        "definition": "Maximum information rate reliably transmittable through noisy channel",
        "formulas": [
          "C = max_{p(x)} I(X;Y)",
          "Shannon theorem: R < C allows error-free",
          "BSC: C = 1 - H(p)",
          "AWGN: C = ½log(1 + S/N)"
        ],
        "examples": ["Binary symmetric channel", "Erasure channel", "Gaussian channel"],
        "applications": ["Communication systems", "Data storage", "Networks"]
      }
    },
    "latex": "C = \\max_{p(x)} I(X;Y)",
    "relations": {
      "prerequisites": ["mutual-information", "probability"],
      "nextTopics": ["error-correcting-codes"],
      "related": ["shannon-entropy"],
      "applications": ["telecommunications", "networking"]
    },
    "tags": ["채널용량", "channel", "capacity", "Shannon"]
  },
  {
    "id": "kl-divergence",
    "name": { "ko": "KL 발산", "en": "KL Divergence" },
    "field": "information-theory",
    "subfield": "divergences",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "두 확률분포 사이의 차이를 측정하는 비대칭적 척도",
        "formulas": [
          "D_KL(P||Q) = Σ P(x) log(P(x)/Q(x))",
          "D_KL ≥ 0, = 0 iff P = Q",
          "비대칭: D_KL(P||Q) ≠ D_KL(Q||P)"
        ],
        "examples": ["가우시안 간 KL", "VAE 손실 함수"],
        "applications": ["기계학습", "통계적 추론", "변분 추론"]
      },
      "en": {
        "definition": "Asymmetric measure of difference between two probability distributions",
        "formulas": [
          "D_KL(P||Q) = Σ P(x) log(P(x)/Q(x))",
          "D_KL ≥ 0, = 0 iff P = Q",
          "Asymmetric: D_KL(P||Q) ≠ D_KL(Q||P)"
        ],
        "examples": ["KL between Gaussians", "VAE loss function"],
        "applications": ["Machine learning", "Statistical inference", "Variational inference"]
      }
    },
    "latex": "D_{KL}(P||Q) = \\sum_x P(x) \\log \\frac{P(x)}{Q(x)}",
    "relations": {
      "prerequisites": ["probability", "shannon-entropy"],
      "nextTopics": ["cross-entropy", "js-divergence"],
      "related": ["mutual-information"],
      "applications": ["machine-learning", "statistics"]
    },
    "tags": ["KL", "발산", "divergence", "Kullback-Leibler"]
  },
  {
    "id": "source-coding-theorem",
    "name": { "ko": "소스 부호화 정리", "en": "Source Coding Theorem" },
    "field": "information-theory",
    "subfield": "coding",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "무손실 압축의 이론적 한계. 평균 코드 길이는 엔트로피 이상",
        "formulas": [
          "H(X) ≤ L̄ < H(X) + 1",
          "크래프트 부등식: Σ 2^{-lᵢ} ≤ 1",
          "최적 코드 길이: lᵢ ≈ -log₂ p(xᵢ)"
        ],
        "examples": ["허프만 코드", "산술 코드", "Lempel-Ziv"],
        "applications": ["ZIP 압축", "이미지/비디오 압축", "통신"]
      },
      "en": {
        "definition": "Theoretical limit of lossless compression. Average code length ≥ entropy",
        "formulas": [
          "H(X) ≤ L̄ < H(X) + 1",
          "Kraft inequality: Σ 2^{-lᵢ} ≤ 1",
          "Optimal code length: lᵢ ≈ -log₂ p(xᵢ)"
        ],
        "examples": ["Huffman code", "Arithmetic coding", "Lempel-Ziv"],
        "applications": ["ZIP compression", "Image/video compression", "Communication"]
      }
    },
    "latex": "H(X) \\leq \\bar{L} < H(X) + 1",
    "relations": {
      "prerequisites": ["shannon-entropy", "coding-theory"],
      "nextTopics": ["huffman-coding", "arithmetic-coding"],
      "related": ["data-compression"],
      "applications": ["compression"]
    },
    "tags": ["소스부호화", "source", "coding", "compression"]
  },
  {
    "id": "error-correcting-codes",
    "name": { "ko": "오류 정정 부호", "en": "Error-Correcting Codes" },
    "field": "information-theory",
    "subfield": "coding",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "전송 중 발생한 오류를 감지하고 정정할 수 있는 부호화 방식",
        "formulas": [
          "해밍 거리: d(x,y)",
          "최소 거리: d_min",
          "t-오류 정정: d_min ≥ 2t+1",
          "싱글턴 한계: k ≤ n - d + 1"
        ],
        "examples": ["해밍 코드", "Reed-Solomon", "LDPC", "Turbo 코드"],
        "applications": ["CD/DVD", "QR 코드", "위성 통신", "저장장치"]
      },
      "en": {
        "definition": "Coding schemes that can detect and correct errors during transmission",
        "formulas": [
          "Hamming distance: d(x,y)",
          "Minimum distance: d_min",
          "t-error correction: d_min ≥ 2t+1",
          "Singleton bound: k ≤ n - d + 1"
        ],
        "examples": ["Hamming code", "Reed-Solomon", "LDPC", "Turbo codes"],
        "applications": ["CD/DVD", "QR codes", "Satellite communication", "Storage"]
      }
    },
    "latex": "d_{min} \\geq 2t + 1",
    "relations": {
      "prerequisites": ["linear-algebra", "channel-capacity"],
      "nextTopics": ["ldpc-codes", "turbo-codes"],
      "related": ["coding-theory"],
      "applications": ["storage", "communications"]
    },
    "tags": ["오류정정", "error-correcting", "Hamming", "coding"]
  },
  {
    "id": "rate-distortion",
    "name": { "ko": "율-왜곡 이론", "en": "Rate-Distortion Theory" },
    "field": "information-theory",
    "subfield": "coding",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "허용 가능한 왜곡 수준에서 필요한 최소 전송률",
        "formulas": ["R(D) = min_{p(x̂|x):E[d(X,X̂)]≤D} I(X;X̂)", "D: 왜곡 측도", "R(0) = H(X)"],
        "examples": ["가우시안 소스", "이미지 압축", "비디오 코딩"],
        "applications": ["손실 압축", "스트리밍", "이미지/비디오 코덱"]
      },
      "en": {
        "definition": "Minimum rate required for given acceptable distortion level",
        "formulas": [
          "R(D) = min_{p(x̂|x):E[d(X,X̂)]≤D} I(X;X̂)",
          "D: distortion measure",
          "R(0) = H(X)"
        ],
        "examples": ["Gaussian source", "Image compression", "Video coding"],
        "applications": ["Lossy compression", "Streaming", "Image/video codecs"]
      }
    },
    "latex": "R(D) = \\min_{p(\\hat{x}|x)} I(X;\\hat{X})",
    "relations": {
      "prerequisites": ["mutual-information", "source-coding-theorem"],
      "nextTopics": ["quantization"],
      "related": ["lossy-compression"],
      "applications": ["video-compression", "audio-compression"]
    },
    "tags": ["율왜곡", "rate-distortion", "손실압축", "lossy"]
  },
  {
    "id": "differential-entropy",
    "name": { "ko": "미분 엔트로피", "en": "Differential Entropy" },
    "field": "information-theory",
    "subfield": "continuous",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "연속 확률변수의 엔트로피. 이산 엔트로피의 연속 확장",
        "formulas": [
          "h(X) = -∫f(x) log f(x) dx",
          "정규분포: h(X) = ½log(2πeσ²)",
          "균등분포: h(X) = log(b-a)"
        ],
        "examples": ["가우시안은 주어진 분산에서 최대 엔트로피", "지수분포"],
        "applications": ["연속 채널", "아날로그 신호", "통계"]
      },
      "en": {
        "definition": "Entropy for continuous random variables. Continuous extension of discrete entropy",
        "formulas": [
          "h(X) = -∫f(x) log f(x) dx",
          "Normal: h(X) = ½log(2πeσ²)",
          "Uniform: h(X) = log(b-a)"
        ],
        "examples": ["Gaussian maximizes entropy for given variance", "Exponential distribution"],
        "applications": ["Continuous channels", "Analog signals", "Statistics"]
      }
    },
    "latex": "h(X) = -\\int f(x) \\log f(x) \\, dx",
    "relations": {
      "prerequisites": ["shannon-entropy", "continuous-probability"],
      "nextTopics": ["gaussian-channel"],
      "related": ["entropy"],
      "applications": ["continuous-communication"]
    },
    "tags": ["미분", "differential", "continuous", "entropy"]
  },
  {
    "id": "markov-chain",
    "name": { "ko": "마르코프 체인", "en": "Markov Chain" },
    "field": "stochastic-processes",
    "subfield": "discrete",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "미래 상태가 현재 상태에만 의존하는 확률 과정 (무기억성)",
        "formulas": ["P(Xₙ₊₁|Xₙ,...,X₀) = P(Xₙ₊₁|Xₙ)", "전이 행렬: P = (pᵢⱼ)", "정상 분포: πP = π"],
        "examples": ["랜덤 워크", "날씨 모델", "페이지랭크"],
        "applications": ["금융", "유전학", "자연어처리"]
      },
      "en": {
        "definition": "Stochastic process where future depends only on present state (memoryless)",
        "formulas": [
          "P(Xₙ₊₁|Xₙ,...,X₀) = P(Xₙ₊₁|Xₙ)",
          "Transition matrix: P = (pᵢⱼ)",
          "Stationary: πP = π"
        ],
        "examples": ["Random walk", "Weather model", "PageRank"],
        "applications": ["Finance", "Genetics", "NLP"]
      }
    },
    "latex": "P(X_{n+1}|X_n) = P_{X_n, X_{n+1}}",
    "relations": {
      "prerequisites": ["probability", "matrix-operations"],
      "nextTopics": ["markov-decision-process", "hidden-markov-model"],
      "related": ["random-walk"],
      "applications": ["machine-learning", "finance"]
    },
    "tags": ["마르코프", "Markov", "체인", "chain"]
  },
  {
    "id": "brownian-motion",
    "name": { "ko": "브라운 운동", "en": "Brownian Motion" },
    "field": "stochastic-processes",
    "subfield": "continuous",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "연속 시간, 연속 상태의 기본 확률 과정. 위너 과정이라고도 함",
        "formulas": ["W(0) = 0", "W(t) - W(s) ~ N(0, t-s)", "독립 증분", "연속 경로"],
        "examples": ["주가 모델", "입자 확산", "열 방정식"],
        "applications": ["금융 수학", "물리학", "생물학"]
      },
      "en": {
        "definition": "Fundamental continuous-time, continuous-state stochastic process. Also called Wiener process",
        "formulas": [
          "W(0) = 0",
          "W(t) - W(s) ~ N(0, t-s)",
          "Independent increments",
          "Continuous paths"
        ],
        "examples": ["Stock price model", "Particle diffusion", "Heat equation"],
        "applications": ["Financial math", "Physics", "Biology"]
      }
    },
    "latex": "W(t) - W(s) \\sim N(0, t-s)",
    "relations": {
      "prerequisites": ["normal-distribution", "limits"],
      "nextTopics": ["ito-calculus", "stochastic-differential-equations"],
      "related": ["random-walk"],
      "applications": ["finance", "physics"]
    },
    "tags": ["브라운", "Brownian", "위너", "Wiener"]
  },
  {
    "id": "poisson-process",
    "name": { "ko": "포아송 과정", "en": "Poisson Process" },
    "field": "stochastic-processes",
    "subfield": "counting",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "사건이 일정한 평균 비율로 독립적으로 발생하는 계수 과정",
        "formulas": ["N(0) = 0", "P(N(t) = k) = (λt)^k e^{-λt}/k!", "독립 증분", "E[N(t)] = λt"],
        "examples": ["고객 도착", "방사선 붕괴", "웹사이트 방문"],
        "applications": ["대기행렬", "보험", "통신"]
      },
      "en": {
        "definition": "Counting process where events occur independently at constant average rate",
        "formulas": [
          "N(0) = 0",
          "P(N(t) = k) = (λt)^k e^{-λt}/k!",
          "Independent increments",
          "E[N(t)] = λt"
        ],
        "examples": ["Customer arrivals", "Radioactive decay", "Website visits"],
        "applications": ["Queueing", "Insurance", "Telecommunications"]
      }
    },
    "latex": "P(N(t) = k) = \\frac{(\\lambda t)^k e^{-\\lambda t}}{k!}",
    "relations": {
      "prerequisites": ["poisson-distribution", "exponential-distribution"],
      "nextTopics": ["compound-poisson", "renewal-process"],
      "related": ["queueing-theory"],
      "applications": ["queueing", "insurance"]
    },
    "tags": ["포아송", "Poisson", "계수과정", "counting"]
  },
  {
    "id": "ito-calculus",
    "name": { "ko": "이토 적분", "en": "Itô Calculus" },
    "field": "stochastic-processes",
    "subfield": "stochastic-calculus",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "확률 과정에 대한 적분 이론. 확률미분방정식의 기초",
        "formulas": [
          "∫f dW (이토 적분)",
          "이토 공식: df = (∂f/∂t + ½σ²∂²f/∂x²)dt + σ∂f/∂x dW",
          "(dW)² = dt"
        ],
        "examples": ["기하 브라운 운동", "옵션 가격 결정", "확률 미분방정식"],
        "applications": ["금융 공학", "물리학", "생물학"]
      },
      "en": {
        "definition": "Integration theory for stochastic processes. Foundation of SDEs",
        "formulas": [
          "∫f dW (Itô integral)",
          "Itô formula: df = (∂f/∂t + ½σ²∂²f/∂x²)dt + σ∂f/∂x dW",
          "(dW)² = dt"
        ],
        "examples": ["Geometric Brownian motion", "Option pricing", "SDEs"],
        "applications": ["Financial engineering", "Physics", "Biology"]
      }
    },
    "latex": "df = \\left(\\frac{\\partial f}{\\partial t} + \\frac{1}{2}\\sigma^2\\frac{\\partial^2 f}{\\partial x^2}\\right)dt + \\sigma\\frac{\\partial f}{\\partial x}dW",
    "relations": {
      "prerequisites": ["brownian-motion", "calculus"],
      "nextTopics": ["black-scholes", "sde"],
      "related": ["measure-theory"],
      "applications": ["finance", "physics"]
    },
    "tags": ["이토", "Itô", "확률적분", "stochastic"]
  },
  {
    "id": "martingale",
    "name": { "ko": "마팅게일", "en": "Martingale" },
    "field": "stochastic-processes",
    "subfield": "theory",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "조건부 기댓값이 현재 값과 같은 확률 과정 (공정한 게임)",
        "formulas": ["E[Xₙ₊₁|ℱₙ] = Xₙ", "서브마팅게일: E[Xₙ₊₁|ℱₙ] ≥ Xₙ", "슈퍼마팅게일: ≤"],
        "examples": ["공정한 도박", "브라운 운동", "주가 (위험중립 측도)"],
        "applications": ["금융", "최적 정지", "확률론"]
      },
      "en": {
        "definition": "Stochastic process where conditional expectation equals current value (fair game)",
        "formulas": ["E[Xₙ₊₁|ℱₙ] = Xₙ", "Submartingale: E[Xₙ₊₁|ℱₙ] ≥ Xₙ", "Supermartingale: ≤"],
        "examples": ["Fair gambling", "Brownian motion", "Stock prices (risk-neutral)"],
        "applications": ["Finance", "Optimal stopping", "Probability"]
      }
    },
    "latex": "E[X_{n+1}|\\mathcal{F}_n] = X_n",
    "relations": {
      "prerequisites": ["conditional-expectation", "filtration"],
      "nextTopics": ["optional-stopping", "doob-martingale"],
      "related": ["brownian-motion"],
      "applications": ["finance", "gambling"]
    },
    "tags": ["마팅게일", "martingale", "공정", "fair"]
  },
  {
    "id": "ergodic-theory",
    "name": { "ko": "에르고딕 이론", "en": "Ergodic Theory" },
    "field": "stochastic-processes",
    "subfield": "theory",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "동역학계의 장기 평균 행동 연구. 시간 평균 = 공간 평균",
        "formulas": [
          "lim (1/n)Σf(Tⁱx) = ∫f dμ (a.e.)",
          "에르고딕: 불변 집합이 자명",
          "혼합: 상관관계 소멸"
        ],
        "examples": ["회전 변환", "베르누이 이동", "빵 반죽 변환"],
        "applications": ["통계역학", "정수론", "카오스"]
      },
      "en": {
        "definition": "Study of long-term average behavior of dynamical systems. Time average = Space average",
        "formulas": [
          "lim (1/n)Σf(Tⁱx) = ∫f dμ (a.e.)",
          "Ergodic: invariant sets trivial",
          "Mixing: correlations decay"
        ],
        "examples": ["Rotation", "Bernoulli shift", "Baker's map"],
        "applications": ["Statistical mechanics", "Number theory", "Chaos"]
      }
    },
    "latex": "\\lim_{n\\to\\infty} \\frac{1}{n}\\sum_{i=0}^{n-1} f(T^i x) = \\int f \\, d\\mu",
    "relations": {
      "prerequisites": ["measure-theory", "dynamical-systems"],
      "nextTopics": ["entropy-dynamics"],
      "related": ["chaos-theory"],
      "applications": ["statistical-mechanics", "number-theory"]
    },
    "tags": ["에르고딕", "ergodic", "동역학", "dynamics"]
  },
  {
    "id": "stochastic-differential-equations",
    "name": { "ko": "확률미분방정식 (SDE)", "en": "Stochastic Differential Equations" },
    "field": "stochastic-processes",
    "subfield": "stochastic-calculus",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "무작위 노이즈 항을 포함하는 미분방정식",
        "formulas": [
          "dX = μ(X,t)dt + σ(X,t)dW",
          "기하 브라운: dS = μS dt + σS dW",
          "해: S(t) = S(0)exp((μ-σ²/2)t + σW(t))"
        ],
        "examples": ["주가 모델", "이자율 모델", "인구 동역학"],
        "applications": ["금융", "물리학", "생물학"]
      },
      "en": {
        "definition": "Differential equations with random noise term",
        "formulas": [
          "dX = μ(X,t)dt + σ(X,t)dW",
          "Geometric Brownian: dS = μS dt + σS dW",
          "Solution: S(t) = S(0)exp((μ-σ²/2)t + σW(t))"
        ],
        "examples": ["Stock price model", "Interest rate model", "Population dynamics"],
        "applications": ["Finance", "Physics", "Biology"]
      }
    },
    "latex": "dX_t = \\mu(X_t, t)dt + \\sigma(X_t, t)dW_t",
    "relations": {
      "prerequisites": ["ito-calculus", "differential-equations"],
      "nextTopics": ["black-scholes", "feynman-kac"],
      "related": ["brownian-motion"],
      "applications": ["finance", "physics"]
    },
    "tags": ["SDE", "확률미분", "stochastic", "differential"]
  },
  {
    "id": "hidden-markov-model",
    "name": { "ko": "은닉 마르코프 모델 (HMM)", "en": "Hidden Markov Model" },
    "field": "stochastic-processes",
    "subfield": "models",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "관측되지 않는 마르코프 체인에서 관측값이 생성되는 모델",
        "formulas": [
          "상태 전이: P(zₜ|zₜ₋₁)",
          "방출: P(xₜ|zₜ)",
          "전방-후방 알고리즘",
          "비터비 알고리즘"
        ],
        "examples": ["음성 인식", "품사 태깅", "DNA 서열 분석"],
        "applications": ["자연어처리", "생물정보학", "금융"]
      },
      "en": {
        "definition": "Model where observations are generated from unobserved Markov chain",
        "formulas": [
          "State transition: P(zₜ|zₜ₋₁)",
          "Emission: P(xₜ|zₜ)",
          "Forward-backward algorithm",
          "Viterbi algorithm"
        ],
        "examples": ["Speech recognition", "POS tagging", "DNA sequence analysis"],
        "applications": ["NLP", "Bioinformatics", "Finance"]
      }
    },
    "latex": "P(x_{1:T}, z_{1:T}) = P(z_1)\\prod_{t=2}^T P(z_t|z_{t-1})\\prod_{t=1}^T P(x_t|z_t)",
    "relations": {
      "prerequisites": ["markov-chain", "bayesian-inference"],
      "nextTopics": ["kalman-filter", "particle-filter"],
      "related": ["graphical-models"],
      "applications": ["speech", "nlp", "bioinformatics"]
    },
    "tags": ["HMM", "은닉", "hidden", "Markov"]
  },
  {
    "id": "heat-equation",
    "name": { "ko": "열 방정식", "en": "Heat Equation" },
    "field": "partial-differential-equations",
    "subfield": "parabolic",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "열의 확산을 기술하는 포물선형 편미분방정식",
        "formulas": ["∂u/∂t = α∇²u", "1D: ∂u/∂t = α ∂²u/∂x²", "기본해: u = (1/√4παt)exp(-x²/4αt)"],
        "examples": ["금속 막대의 열전도", "확산 과정", "브라운 운동"],
        "applications": ["열역학", "금융 (Black-Scholes)", "이미지 처리"]
      },
      "en": {
        "definition": "Parabolic PDE describing heat diffusion",
        "formulas": [
          "∂u/∂t = α∇²u",
          "1D: ∂u/∂t = α ∂²u/∂x²",
          "Fundamental: u = (1/√4παt)exp(-x²/4αt)"
        ],
        "examples": ["Heat conduction in rod", "Diffusion processes", "Brownian motion"],
        "applications": ["Thermodynamics", "Finance (Black-Scholes)", "Image processing"]
      }
    },
    "latex": "\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u",
    "relations": {
      "prerequisites": ["partial-derivatives", "fourier-series"],
      "nextTopics": ["black-scholes", "diffusion-equation"],
      "related": ["laplace-equation"],
      "applications": ["physics", "finance"]
    },
    "tags": ["열방정식", "heat", "parabolic", "diffusion"]
  },
  {
    "id": "wave-equation-pde",
    "name": { "ko": "파동 방정식", "en": "Wave Equation" },
    "field": "partial-differential-equations",
    "subfield": "hyperbolic",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "파동의 전파를 기술하는 쌍곡선형 편미분방정식",
        "formulas": [
          "∂²u/∂t² = c²∇²u",
          "달랑베르 해: u = f(x-ct) + g(x+ct)",
          "특성선: x ± ct = const"
        ],
        "examples": ["현의 진동", "음파", "전자기파"],
        "applications": ["음향학", "광학", "지진학"]
      },
      "en": {
        "definition": "Hyperbolic PDE describing wave propagation",
        "formulas": [
          "∂²u/∂t² = c²∇²u",
          "d'Alembert: u = f(x-ct) + g(x+ct)",
          "Characteristics: x ± ct = const"
        ],
        "examples": ["String vibration", "Sound waves", "EM waves"],
        "applications": ["Acoustics", "Optics", "Seismology"]
      }
    },
    "latex": "\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u",
    "relations": {
      "prerequisites": ["partial-derivatives", "ode"],
      "nextTopics": ["maxwell-equations"],
      "related": ["heat-equation"],
      "applications": ["physics", "engineering"]
    },
    "tags": ["파동", "wave", "hyperbolic", "propagation"]
  },
  {
    "id": "laplace-equation",
    "name": { "ko": "라플라스 방정식", "en": "Laplace Equation" },
    "field": "partial-differential-equations",
    "subfield": "elliptic",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "정상 상태를 기술하는 타원형 편미분방정식. 조화함수를 정의",
        "formulas": ["∇²u = 0", "∂²u/∂x² + ∂²u/∂y² = 0", "평균값 성질", "최대값 원리"],
        "examples": ["정전기 포텐셜", "정상 열전도", "유체 흐름"],
        "applications": ["전자기학", "유체역학", "중력"]
      },
      "en": {
        "definition": "Elliptic PDE describing steady state. Defines harmonic functions",
        "formulas": [
          "∇²u = 0",
          "∂²u/∂x² + ∂²u/∂y² = 0",
          "Mean value property",
          "Maximum principle"
        ],
        "examples": ["Electrostatic potential", "Steady heat conduction", "Fluid flow"],
        "applications": ["Electromagnetism", "Fluid mechanics", "Gravity"]
      }
    },
    "latex": "\\nabla^2 u = 0",
    "relations": {
      "prerequisites": ["partial-derivatives", "multivariable-calculus"],
      "nextTopics": ["poisson-equation", "harmonic-functions"],
      "related": ["heat-equation"],
      "applications": ["physics", "engineering"]
    },
    "tags": ["라플라스", "Laplace", "elliptic", "harmonic"]
  },
  {
    "id": "navier-stokes",
    "name": { "ko": "나비에-스토크스 방정식", "en": "Navier-Stokes Equations" },
    "field": "partial-differential-equations",
    "subfield": "fluid",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "점성 유체의 운동을 기술하는 비선형 편미분방정식",
        "formulas": [
          "ρ(∂v/∂t + v·∇v) = -∇p + μ∇²v + f",
          "∇·v = 0 (비압축성)",
          "레이놀즈 수: Re = ρvL/μ"
        ],
        "examples": ["공기 흐름", "해류", "혈류"],
        "applications": ["항공역학", "기상학", "생체역학"]
      },
      "en": {
        "definition": "Nonlinear PDE describing viscous fluid motion",
        "formulas": [
          "ρ(∂v/∂t + v·∇v) = -∇p + μ∇²v + f",
          "∇·v = 0 (incompressible)",
          "Reynolds: Re = ρvL/μ"
        ],
        "examples": ["Air flow", "Ocean currents", "Blood flow"],
        "applications": ["Aerodynamics", "Meteorology", "Biomechanics"]
      }
    },
    "latex": "\\rho\\left(\\frac{\\partial \\mathbf{v}}{\\partial t} + \\mathbf{v} \\cdot \\nabla\\mathbf{v}\\right) = -\\nabla p + \\mu\\nabla^2\\mathbf{v}",
    "relations": {
      "prerequisites": ["vector-calculus", "fluid-dynamics"],
      "nextTopics": ["turbulence", "cfd"],
      "related": ["euler-equations"],
      "applications": ["engineering", "physics"]
    },
    "tags": ["나비에스토크스", "Navier-Stokes", "fluid", "millennium"]
  },
  {
    "id": "separation-of-variables",
    "name": { "ko": "변수 분리법", "en": "Separation of Variables" },
    "field": "partial-differential-equations",
    "subfield": "methods",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "PDE를 여러 ODE로 분해하여 푸는 방법",
        "formulas": ["가정: u(x,t) = X(x)T(t)", "각 변수별 ODE로 분리", "고유값 문제 + 급수 해"],
        "examples": ["열 방정식", "파동 방정식", "라플라스 방정식"],
        "applications": ["물리학", "공학", "경계값 문제"]
      },
      "en": {
        "definition": "Method solving PDEs by decomposing into several ODEs",
        "formulas": [
          "Assume: u(x,t) = X(x)T(t)",
          "Separate into ODEs per variable",
          "Eigenvalue problem + series solution"
        ],
        "examples": ["Heat equation", "Wave equation", "Laplace equation"],
        "applications": ["Physics", "Engineering", "Boundary value problems"]
      }
    },
    "latex": "u(x,t) = X(x)T(t)",
    "relations": {
      "prerequisites": ["ode", "fourier-series"],
      "nextTopics": ["sturm-liouville"],
      "related": ["eigenvalue-problems"],
      "applications": ["physics", "engineering"]
    },
    "tags": ["변수분리", "separation", "variables", "method"]
  },
  {
    "id": "greens-function",
    "name": { "ko": "그린 함수", "en": "Green's Function" },
    "field": "partial-differential-equations",
    "subfield": "methods",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "점 소스에 대한 응답. 선형 미분방정식의 해를 적분으로 표현",
        "formulas": ["LG(x,ξ) = δ(x-ξ)", "해: u(x) = ∫G(x,ξ)f(ξ)dξ", "상반정리: G(x,ξ) = G(ξ,x)"],
        "examples": ["포아송 방정식", "열 방정식", "파동 방정식"],
        "applications": ["전자기학", "양자역학", "음향학"]
      },
      "en": {
        "definition": "Response to point source. Expresses solution of linear DE as integral",
        "formulas": [
          "LG(x,ξ) = δ(x-ξ)",
          "Solution: u(x) = ∫G(x,ξ)f(ξ)dξ",
          "Reciprocity: G(x,ξ) = G(ξ,x)"
        ],
        "examples": ["Poisson equation", "Heat equation", "Wave equation"],
        "applications": ["Electromagnetism", "Quantum mechanics", "Acoustics"]
      }
    },
    "latex": "u(x) = \\int G(x,\\xi) f(\\xi) \\, d\\xi",
    "relations": {
      "prerequisites": ["laplace-equation", "dirac-delta"],
      "nextTopics": ["integral-equations"],
      "related": ["convolution"],
      "applications": ["physics", "engineering"]
    },
    "tags": ["그린", "Green", "함수", "function"]
  },
  {
    "id": "finite-difference-method",
    "name": { "ko": "유한 차분법", "en": "Finite Difference Method" },
    "field": "partial-differential-equations",
    "subfield": "numerical",
    "difficulty": 4,
    "content": {
      "ko": {
        "definition": "미분을 차분으로 근사하여 PDE를 수치적으로 푸는 방법",
        "formulas": [
          "∂u/∂x ≈ (u_{i+1} - u_{i-1})/(2Δx)",
          "∂²u/∂x² ≈ (u_{i+1} - 2uᵢ + u_{i-1})/(Δx)²",
          "CFL 조건: cΔt/Δx ≤ 1"
        ],
        "examples": ["열 방정식 (명시적/암시적)", "파동 방정식"],
        "applications": ["CFD", "기상 예측", "금융"]
      },
      "en": {
        "definition": "Numerical method solving PDEs by approximating derivatives with differences",
        "formulas": [
          "∂u/∂x ≈ (u_{i+1} - u_{i-1})/(2Δx)",
          "∂²u/∂x² ≈ (u_{i+1} - 2uᵢ + u_{i-1})/(Δx)²",
          "CFL condition: cΔt/Δx ≤ 1"
        ],
        "examples": ["Heat equation (explicit/implicit)", "Wave equation"],
        "applications": ["CFD", "Weather prediction", "Finance"]
      }
    },
    "latex": "\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta x)^2}",
    "relations": {
      "prerequisites": ["taylor-series", "linear-algebra"],
      "nextTopics": ["finite-element-method", "stability-analysis"],
      "related": ["numerical-integration"],
      "applications": ["simulation", "cfd"]
    },
    "tags": ["유한차분", "finite-difference", "numerical", "discretization"]
  },
  {
    "id": "boundary-conditions",
    "name": { "ko": "경계 조건", "en": "Boundary Conditions" },
    "field": "partial-differential-equations",
    "subfield": "foundations",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "PDE의 유일한 해를 결정하기 위한 경계에서의 조건",
        "formulas": ["디리클레: u = g on ∂Ω", "노이만: ∂u/∂n = h on ∂Ω", "로빈: αu + β∂u/∂n = g"],
        "examples": ["고정 끝 (Dirichlet)", "단열 (Neumann)", "복사 (Robin)"],
        "applications": ["물리 모델링", "공학", "수치해석"]
      },
      "en": {
        "definition": "Conditions at boundary to determine unique solution of PDE",
        "formulas": [
          "Dirichlet: u = g on ∂Ω",
          "Neumann: ∂u/∂n = h on ∂Ω",
          "Robin: αu + β∂u/∂n = g"
        ],
        "examples": ["Fixed end (Dirichlet)", "Insulated (Neumann)", "Radiating (Robin)"],
        "applications": ["Physics modeling", "Engineering", "Numerical analysis"]
      }
    },
    "latex": "u = g \\text{ on } \\partial\\Omega",
    "relations": {
      "prerequisites": ["calculus", "ode"],
      "nextTopics": ["well-posedness"],
      "related": ["initial-conditions"],
      "applications": ["physics", "engineering"]
    },
    "tags": ["경계조건", "boundary", "Dirichlet", "Neumann"]
  },
  {
    "id": "lu-decomposition",
    "name": { "ko": "LU 분해", "en": "LU Decomposition" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 3,
    "content": {
      "ko": "행렬을 하삼각행렬(L)과 상삼각행렬(U)의 곱으로 분해하는 방법입니다. 연립방정식을 효율적으로 풀 때 사용됩니다.",
      "en": "A method of decomposing a matrix into the product of a lower triangular matrix (L) and an upper triangular matrix (U). Used for efficiently solving systems of linear equations."
    },
    "latex": "A = LU, \\quad L_{ij} = 0 \\text{ for } i < j, \\quad U_{ij} = 0 \\text{ for } i > j",
    "relations": {
      "prerequisites": ["matrix", "gaussian-elimination"],
      "nextTopics": ["cholesky-decomposition", "qr-decomposition"],
      "related": ["determinant", "matrix-inverse"],
      "applications": ["solving-linear-systems", "circuit-analysis"]
    },
    "tags": ["numerical", "matrix-decomposition", "linear-systems"]
  },
  {
    "id": "qr-decomposition",
    "name": { "ko": "QR 분해", "en": "QR Decomposition" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 3,
    "content": {
      "ko": "행렬을 직교행렬(Q)과 상삼각행렬(R)의 곱으로 분해하는 방법입니다. 최소제곱문제와 고유값 계산에 사용됩니다.",
      "en": "A method of decomposing a matrix into the product of an orthogonal matrix (Q) and an upper triangular matrix (R). Used for least squares problems and eigenvalue computation."
    },
    "latex": "A = QR, \\quad Q^TQ = I, \\quad R \\text{ upper triangular}",
    "relations": {
      "prerequisites": ["orthogonal-matrix", "gram-schmidt"],
      "nextTopics": ["svd", "qr-algorithm"],
      "related": ["least-squares", "eigenvalue"],
      "applications": ["regression", "signal-processing"]
    },
    "tags": ["numerical", "matrix-decomposition", "orthogonalization"]
  },
  {
    "id": "svd",
    "name": { "ko": "특이값 분해", "en": "Singular Value Decomposition" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 4,
    "content": {
      "ko": "임의의 행렬을 두 직교행렬과 대각행렬의 곱으로 분해하는 방법입니다. 데이터 압축, 차원 축소, 의사역행렬 계산에 핵심적입니다.",
      "en": "A method of decomposing any matrix into the product of two orthogonal matrices and a diagonal matrix. Essential for data compression, dimensionality reduction, and pseudoinverse computation."
    },
    "latex": "A = U\\Sigma V^T, \\quad \\Sigma = \\text{diag}(\\sigma_1, \\ldots, \\sigma_r)",
    "relations": {
      "prerequisites": ["eigenvalue", "orthogonal-matrix"],
      "nextTopics": ["pca", "low-rank-approximation"],
      "related": ["matrix-rank", "pseudoinverse"],
      "applications": ["image-compression", "recommendation-systems", "nlp"]
    },
    "tags": ["numerical", "matrix-decomposition", "data-science"]
  },
  {
    "id": "cholesky-decomposition",
    "name": { "ko": "촐레스키 분해", "en": "Cholesky Decomposition" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 3,
    "content": {
      "ko": "양정치 대칭행렬을 하삼각행렬과 그 전치행렬의 곱으로 분해하는 방법입니다. LU 분해보다 효율적이고 수치적으로 안정합니다.",
      "en": "A method of decomposing a positive definite symmetric matrix into the product of a lower triangular matrix and its transpose. More efficient and numerically stable than LU decomposition."
    },
    "latex": "A = LL^T, \\quad L_{ii} = \\sqrt{A_{ii} - \\sum_{k=1}^{i-1} L_{ik}^2}",
    "relations": {
      "prerequisites": ["positive-definite-matrix", "lu-decomposition"],
      "nextTopics": ["conjugate-gradient"],
      "related": ["covariance-matrix", "kalman-filter"],
      "applications": ["optimization", "statistics", "finance"]
    },
    "tags": ["numerical", "matrix-decomposition", "positive-definite"]
  },
  {
    "id": "iterative-methods",
    "name": { "ko": "반복법", "en": "Iterative Methods" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 3,
    "content": {
      "ko": "연립방정식을 반복적으로 근사하여 푸는 방법입니다. 야코비, 가우스-자이델, SOR 방법 등이 있으며 대규모 희소행렬에 적합합니다.",
      "en": "Methods that iteratively approximate solutions to systems of equations. Includes Jacobi, Gauss-Seidel, and SOR methods, suitable for large sparse matrices."
    },
    "latex": "x^{(k+1)} = Bx^{(k)} + c, \\quad \\text{Jacobi: } x_i^{(k+1)} = \\frac{1}{a_{ii}}\\left(b_i - \\sum_{j\\neq i} a_{ij}x_j^{(k)}\\right)",
    "relations": {
      "prerequisites": ["matrix", "convergence"],
      "nextTopics": ["conjugate-gradient", "gmres"],
      "related": ["spectral-radius", "preconditioning"],
      "applications": ["pde-solving", "large-scale-systems"]
    },
    "tags": ["numerical", "iterative", "sparse-matrix"]
  },
  {
    "id": "conjugate-gradient",
    "name": { "ko": "켤레 기울기법", "en": "Conjugate Gradient Method" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 4,
    "content": {
      "ko": "양정치 대칭행렬의 연립방정식을 푸는 효율적인 반복법입니다. 이차형식의 최소화와 동치이며, 최적화에도 널리 사용됩니다.",
      "en": "An efficient iterative method for solving systems with positive definite symmetric matrices. Equivalent to minimizing a quadratic form, widely used in optimization."
    },
    "latex": "\\min_x \\frac{1}{2}x^TAx - b^Tx, \\quad r_k = b - Ax_k, \\quad p_{k+1} = r_{k+1} + \\beta_k p_k",
    "relations": {
      "prerequisites": ["positive-definite-matrix", "gradient-descent"],
      "nextTopics": ["preconditioned-cg", "gmres"],
      "related": ["krylov-subspace", "optimization"],
      "applications": ["finite-element", "machine-learning"]
    },
    "tags": ["numerical", "iterative", "optimization"]
  },
  {
    "id": "eigenvalue-algorithms",
    "name": { "ko": "고유값 알고리즘", "en": "Eigenvalue Algorithms" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 4,
    "content": {
      "ko": "행렬의 고유값과 고유벡터를 수치적으로 계산하는 알고리즘입니다. 거듭제곱법, QR 알고리즘, 야코비 방법 등이 있습니다.",
      "en": "Algorithms for numerically computing eigenvalues and eigenvectors of matrices. Includes power method, QR algorithm, and Jacobi method."
    },
    "latex": "\\text{Power: } v_{k+1} = \\frac{Av_k}{\\|Av_k\\|}, \\quad \\text{QR: } A_k = Q_kR_k, A_{k+1} = R_kQ_k",
    "relations": {
      "prerequisites": ["eigenvalue", "qr-decomposition"],
      "nextTopics": ["svd", "schur-decomposition"],
      "related": ["spectral-theorem", "matrix-diagonalization"],
      "applications": ["vibration-analysis", "pca", "google-pagerank"]
    },
    "tags": ["numerical", "eigenvalue", "spectral"]
  },
  {
    "id": "condition-number",
    "name": { "ko": "조건수", "en": "Condition Number" },
    "field": "numerical-analysis",
    "subfield": "numerical-linear-algebra",
    "difficulty": 3,
    "content": {
      "ko": "입력의 작은 변화에 대한 출력의 민감도를 측정하는 수입니다. 조건수가 크면 문제가 ill-conditioned하여 수치적으로 불안정합니다.",
      "en": "A measure of sensitivity of output to small changes in input. Large condition numbers indicate ill-conditioned problems that are numerically unstable."
    },
    "latex": "\\kappa(A) = \\|A\\| \\cdot \\|A^{-1}\\| = \\frac{\\sigma_{\\max}}{\\sigma_{\\min}}",
    "relations": {
      "prerequisites": ["matrix-norm", "svd"],
      "nextTopics": ["preconditioning", "regularization"],
      "related": ["numerical-stability", "floating-point"],
      "applications": ["error-analysis", "algorithm-design"]
    },
    "tags": ["numerical", "stability", "error-analysis"]
  },
  {
    "id": "graph-coloring",
    "name": { "ko": "그래프 색칠", "en": "Graph Coloring" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 3,
    "content": {
      "ko": "인접한 정점이 같은 색을 갖지 않도록 정점에 색을 배정하는 문제입니다. 색상수는 필요한 최소 색의 개수입니다.",
      "en": "The problem of assigning colors to vertices such that no adjacent vertices share the same color. The chromatic number is the minimum number of colors needed."
    },
    "latex": "\\chi(G) = \\min\\{k : G \\text{ is } k\\text{-colorable}\\}",
    "relations": {
      "prerequisites": ["graph", "vertex-edge"],
      "nextTopics": ["four-color-theorem", "chromatic-polynomial"],
      "related": ["planar-graph", "np-complete"],
      "applications": ["scheduling", "register-allocation", "map-coloring"]
    },
    "tags": ["graph-theory", "combinatorics", "np-hard"]
  },
  {
    "id": "planar-graph",
    "name": { "ko": "평면 그래프", "en": "Planar Graph" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 3,
    "content": {
      "ko": "변이 교차하지 않게 평면에 그릴 수 있는 그래프입니다. 오일러 공식 V-E+F=2가 성립하며, K₅와 K₃,₃를 부분 그래프로 포함하지 않습니다.",
      "en": "A graph that can be drawn on a plane without edge crossings. Euler's formula V-E+F=2 holds, and it contains neither K₅ nor K₃,₃ as a subdivision."
    },
    "latex": "V - E + F = 2, \\quad E \\leq 3V - 6 \\text{ (simple connected)}",
    "relations": {
      "prerequisites": ["graph", "euler-formula"],
      "nextTopics": ["kuratowski-theorem", "four-color-theorem"],
      "related": ["graph-embedding", "genus"],
      "applications": ["circuit-layout", "geographic-maps"]
    },
    "tags": ["graph-theory", "topology", "euler"]
  },
  {
    "id": "network-flow",
    "name": { "ko": "네트워크 흐름", "en": "Network Flow" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 4,
    "content": {
      "ko": "방향 그래프에서 소스에서 싱크로 흐르는 최대 흐름을 찾는 문제입니다. 최대흐름-최소절단 정리가 핵심 결과입니다.",
      "en": "The problem of finding maximum flow from source to sink in a directed graph. The max-flow min-cut theorem is the key result."
    },
    "latex": "\\max |f| = \\min_{S-T \\text{ cut}} c(S,T), \\quad \\sum_{v:(u,v)\\in E} f(u,v) = \\sum_{v:(v,u)\\in E} f(v,u)",
    "relations": {
      "prerequisites": ["directed-graph", "graph-algorithms"],
      "nextTopics": ["ford-fulkerson", "bipartite-matching"],
      "related": ["linear-programming", "min-cost-flow"],
      "applications": ["transportation", "assignment", "image-segmentation"]
    },
    "tags": ["graph-theory", "optimization", "algorithms"]
  },
  {
    "id": "spectral-graph-theory",
    "name": { "ko": "스펙트럼 그래프 이론", "en": "Spectral Graph Theory" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 4,
    "content": {
      "ko": "그래프의 인접행렬이나 라플라시안 행렬의 고유값을 연구합니다. 그래프의 연결성, 확장성 등 구조적 성질과 밀접한 관련이 있습니다.",
      "en": "Studies eigenvalues of adjacency or Laplacian matrices of graphs. Closely related to structural properties like connectivity and expansion."
    },
    "latex": "L = D - A, \\quad \\lambda_2(L) > 0 \\Leftrightarrow G \\text{ connected}",
    "relations": {
      "prerequisites": ["eigenvalue", "graph", "laplacian-matrix"],
      "nextTopics": ["cheeger-inequality", "graph-partitioning"],
      "related": ["random-walks", "expander-graphs"],
      "applications": ["clustering", "community-detection", "pagerank"]
    },
    "tags": ["graph-theory", "linear-algebra", "spectral"]
  },
  {
    "id": "random-graphs",
    "name": { "ko": "랜덤 그래프", "en": "Random Graphs" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 4,
    "content": {
      "ko": "확률적으로 생성되는 그래프를 연구합니다. Erdős-Rényi 모델 G(n,p)에서 위상 전이와 임계 현상을 분석합니다.",
      "en": "Studies graphs generated probabilistically. Analyzes phase transitions and threshold phenomena in the Erdős-Rényi model G(n,p)."
    },
    "latex": "G(n,p): \\Pr[\\text{edge } (i,j)] = p, \\quad \\text{threshold for connectivity: } p = \\frac{\\ln n}{n}",
    "relations": {
      "prerequisites": ["probability", "graph"],
      "nextTopics": ["small-world-networks", "scale-free-networks"],
      "related": ["percolation-theory", "probabilistic-method"],
      "applications": ["social-networks", "epidemiology", "internet-modeling"]
    },
    "tags": ["graph-theory", "probability", "complex-networks"]
  },
  {
    "id": "matching-theory",
    "name": { "ko": "매칭 이론", "en": "Matching Theory" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 3,
    "content": {
      "ko": "그래프에서 공유 정점이 없는 변들의 집합을 찾는 문제입니다. 이분 그래프의 완전 매칭 존재 조건은 Hall의 정리로 주어집니다.",
      "en": "The problem of finding a set of edges with no shared vertices. The existence of a perfect matching in bipartite graphs is given by Hall's theorem."
    },
    "latex": "|N(S)| \\geq |S| \\text{ for all } S \\subseteq X \\Rightarrow \\text{perfect matching exists}",
    "relations": {
      "prerequisites": ["bipartite-graph", "graph"],
      "nextTopics": ["hungarian-algorithm", "stable-matching"],
      "related": ["network-flow", "vertex-cover"],
      "applications": ["job-assignment", "kidney-exchange", "marriage-problem"]
    },
    "tags": ["graph-theory", "combinatorics", "optimization"]
  },
  {
    "id": "tree-algorithms",
    "name": { "ko": "트리 알고리즘", "en": "Tree Algorithms" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 3,
    "content": {
      "ko": "트리 구조에서의 알고리즘입니다. 최소 신장 트리(Kruskal, Prim), 최소 공통 조상(LCA), 트리 DP 등이 포함됩니다.",
      "en": "Algorithms on tree structures. Includes minimum spanning tree (Kruskal, Prim), lowest common ancestor (LCA), and tree DP."
    },
    "latex": "\\text{MST: } \\min \\sum_{e \\in T} w(e), \\quad |E(T)| = |V| - 1",
    "relations": {
      "prerequisites": ["tree", "graph-algorithms"],
      "nextTopics": ["heavy-light-decomposition", "centroid-decomposition"],
      "related": ["greedy-algorithm", "dynamic-programming"],
      "applications": ["network-design", "clustering", "phylogenetics"]
    },
    "tags": ["graph-theory", "algorithms", "tree"]
  },
  {
    "id": "graph-isomorphism",
    "name": { "ko": "그래프 동형", "en": "Graph Isomorphism" },
    "field": "discrete-mathematics",
    "subfield": "graph-theory",
    "difficulty": 4,
    "content": {
      "ko": "두 그래프가 구조적으로 같은지 판별하는 문제입니다. 복잡도 클래스 NP에 속하지만 NP-완전인지는 미해결입니다.",
      "en": "The problem of determining if two graphs are structurally identical. Belongs to complexity class NP, but whether it's NP-complete is unknown."
    },
    "latex": "G_1 \\cong G_2 \\Leftrightarrow \\exists \\phi: V_1 \\to V_2 \\text{ bijective, } (u,v) \\in E_1 \\Leftrightarrow (\\phi(u),\\phi(v)) \\in E_2",
    "relations": {
      "prerequisites": ["graph", "bijection"],
      "nextTopics": ["weisfeiler-lehman", "babai-algorithm"],
      "related": ["group-theory", "complexity-theory"],
      "applications": ["chemical-structure", "pattern-recognition"]
    },
    "tags": ["graph-theory", "complexity", "algorithms"]
  },
  {
    "id": "godel-incompleteness",
    "name": { "ko": "괴델의 불완전성 정리", "en": "Gödel's Incompleteness Theorems" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "충분히 강력한 형식 체계는 참이지만 증명할 수 없는 명제를 포함하며(제1정리), 자신의 무모순성을 증명할 수 없습니다(제2정리).",
      "en": "Sufficiently powerful formal systems contain true but unprovable statements (first theorem) and cannot prove their own consistency (second theorem)."
    },
    "latex": "\\text{Con}(T) \\Rightarrow \\exists \\varphi: T \\nvdash \\varphi \\land T \\nvdash \\neg\\varphi",
    "relations": {
      "prerequisites": ["first-order-logic", "peano-arithmetic"],
      "nextTopics": ["proof-theory", "recursion-theory"],
      "related": ["halting-problem", "undecidability"],
      "applications": ["foundations-of-mathematics", "philosophy-of-math"]
    },
    "tags": ["logic", "foundations", "incompleteness"]
  },
  {
    "id": "model-theory",
    "name": { "ko": "모델 이론", "en": "Model Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "형식 언어와 그것이 해석되는 수학적 구조(모델) 사이의 관계를 연구합니다. 완전성, 콤팩트성, 뢰벤하임-스콜렘 정리가 핵심입니다.",
      "en": "Studies the relationship between formal languages and mathematical structures (models) interpreting them. Completeness, compactness, and Löwenheim-Skolem are key results."
    },
    "latex": "T \\models \\varphi \\Leftrightarrow T \\vdash \\varphi \\quad \\text{(Completeness)}",
    "relations": {
      "prerequisites": ["first-order-logic", "set-theory"],
      "nextTopics": ["stability-theory", "categoricity"],
      "related": ["universal-algebra", "ultraproducts"],
      "applications": ["algebraic-geometry", "number-theory"]
    },
    "tags": ["logic", "model-theory", "semantics"]
  },
  {
    "id": "proof-theory",
    "name": { "ko": "증명 이론", "en": "Proof Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "형식적 증명 자체를 수학적 대상으로 연구합니다. 자연 연역, 시퀀트 계산, 컷 제거, 증명의 정규화가 핵심 주제입니다.",
      "en": "Studies formal proofs as mathematical objects. Natural deduction, sequent calculus, cut elimination, and proof normalization are key topics."
    },
    "latex": "\\frac{\\Gamma \\vdash A \\quad \\Delta, A \\vdash B}{\\Gamma, \\Delta \\vdash B} \\text{ (Cut)}",
    "relations": {
      "prerequisites": ["first-order-logic", "formal-systems"],
      "nextTopics": ["ordinal-analysis", "reverse-mathematics"],
      "related": ["type-theory", "constructive-mathematics"],
      "applications": ["automated-theorem-proving", "program-verification"]
    },
    "tags": ["logic", "proof-theory", "formal-methods"]
  },
  {
    "id": "computability-theory",
    "name": { "ko": "계산 가능성 이론", "en": "Computability Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 4,
    "content": {
      "ko": "알고리즘으로 계산 가능한 것의 한계를 연구합니다. 튜링 기계, 정지 문제, 결정 불가능성, 튜링 차수가 핵심 개념입니다.",
      "en": "Studies the limits of what can be computed algorithmically. Turing machines, halting problem, undecidability, and Turing degrees are key concepts."
    },
    "latex": "\\text{HALT} = \\{\\langle M, w \\rangle : M \\text{ halts on } w\\} \\text{ is undecidable}",
    "relations": {
      "prerequisites": ["turing-machine", "formal-languages"],
      "nextTopics": ["complexity-theory", "oracle-computation"],
      "related": ["godel-incompleteness", "church-turing-thesis"],
      "applications": ["theoretical-computer-science", "ai-limits"]
    },
    "tags": ["logic", "computability", "turing"]
  },
  {
    "id": "modal-logic",
    "name": { "ko": "양상 논리", "en": "Modal Logic" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 4,
    "content": {
      "ko": "필연성(□)과 가능성(◇) 개념을 다루는 논리 체계입니다. 크립키 의미론에서 가능 세계를 통해 해석됩니다.",
      "en": "A logical system dealing with necessity (□) and possibility (◇). Interpreted through possible worlds in Kripke semantics."
    },
    "latex": "\\Box\\varphi \\rightarrow \\varphi \\text{ (T)}, \\quad \\Box\\varphi \\rightarrow \\Box\\Box\\varphi \\text{ (4)}",
    "relations": {
      "prerequisites": ["propositional-logic", "first-order-logic"],
      "nextTopics": ["temporal-logic", "epistemic-logic"],
      "related": ["kripke-frames", "intuitionistic-logic"],
      "applications": ["program-verification", "philosophy", "linguistics"]
    },
    "tags": ["logic", "modal", "possible-worlds"]
  },
  {
    "id": "type-theory",
    "name": { "ko": "타입 이론", "en": "Type Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "수학적 대상을 타입으로 분류하는 형식 체계입니다. 커리-하워드 대응으로 증명과 프로그램이 동일시됩니다.",
      "en": "A formal system classifying mathematical objects by types. Through the Curry-Howard correspondence, proofs correspond to programs."
    },
    "latex": "\\frac{\\Gamma, x:A \\vdash t:B}{\\Gamma \\vdash (\\lambda x.t) : A \\rightarrow B}",
    "relations": {
      "prerequisites": ["lambda-calculus", "first-order-logic"],
      "nextTopics": ["homotopy-type-theory", "dependent-types"],
      "related": ["constructive-mathematics", "category-theory"],
      "applications": ["proof-assistants", "programming-languages"]
    },
    "tags": ["logic", "type-theory", "curry-howard"]
  },
  {
    "id": "forcing",
    "name": { "ko": "강제법", "en": "Forcing" },
    "field": "logic",
    "subfield": "set-theory",
    "difficulty": 5,
    "content": {
      "ko": "집합론의 독립성 증명에 사용되는 기법입니다. 코헨이 연속체 가설의 독립성을 증명하는 데 사용했습니다.",
      "en": "A technique used to prove independence results in set theory. Used by Cohen to prove the independence of the continuum hypothesis."
    },
    "latex": "p \\Vdash \\varphi \\quad \\text{(p forces } \\varphi\\text{)}",
    "relations": {
      "prerequisites": ["set-theory", "model-theory"],
      "nextTopics": ["iterated-forcing", "proper-forcing"],
      "related": ["continuum-hypothesis", "independence-proofs"],
      "applications": ["foundations-of-mathematics", "infinite-combinatorics"]
    },
    "tags": ["logic", "set-theory", "forcing"]
  },
  {
    "id": "descriptive-set-theory",
    "name": { "ko": "기술집합론", "en": "Descriptive Set Theory" },
    "field": "logic",
    "subfield": "set-theory",
    "difficulty": 5,
    "content": {
      "ko": "실수 집합의 복잡도를 위계적으로 분류합니다. 보렐 집합, 해석적 집합, 사영 집합의 위계가 핵심입니다.",
      "en": "Hierarchically classifies the complexity of sets of reals. The hierarchies of Borel, analytic, and projective sets are central."
    },
    "latex": "\\Sigma^0_1 \\subset \\Sigma^0_2 \\subset \\cdots \\subset \\Sigma^1_1 \\subset \\Sigma^1_2 \\subset \\cdots",
    "relations": {
      "prerequisites": ["set-theory", "topology", "measure-theory"],
      "nextTopics": ["determinacy", "large-cardinals"],
      "related": ["computability-theory", "polish-spaces"],
      "applications": ["analysis", "dynamical-systems"]
    },
    "tags": ["logic", "set-theory", "analysis"]
  },
  {
    "id": "bifurcation-theory",
    "name": { "ko": "분기 이론", "en": "Bifurcation Theory" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": "매개변수 변화에 따라 동역학계의 질적 성질이 급격히 변하는 현상을 연구합니다. 안장-마디, 호프 분기 등이 있습니다.",
      "en": "Studies phenomena where qualitative properties of dynamical systems change abruptly with parameter variation. Includes saddle-node, Hopf bifurcations."
    },
    "latex": "\\dot{x} = \\mu - x^2 \\quad \\text{(saddle-node)}, \\quad \\dot{z} = (\\mu + i)z - z|z|^2 \\quad \\text{(Hopf)}",
    "relations": {
      "prerequisites": ["differential-equations", "fixed-points"],
      "nextTopics": ["chaos-theory", "catastrophe-theory"],
      "related": ["stability-analysis", "normal-forms"],
      "applications": ["population-dynamics", "climate-models", "neuroscience"]
    },
    "tags": ["dynamical-systems", "bifurcation", "qualitative"]
  },
  {
    "id": "chaos-theory",
    "name": { "ko": "카오스 이론", "en": "Chaos Theory" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": "결정론적 시스템에서 초기 조건에 극도로 민감한 불규칙적 행동을 연구합니다. 로렌츠 방정식, 로지스틱 맵이 대표적 예입니다.",
      "en": "Studies irregular behavior in deterministic systems that is extremely sensitive to initial conditions. Lorenz equations and logistic map are classic examples."
    },
    "latex": "x_{n+1} = rx_n(1-x_n), \\quad \\lambda = \\lim_{n\\to\\infty} \\frac{1}{n}\\sum_{i=0}^{n-1} \\ln|f'(x_i)| > 0",
    "relations": {
      "prerequisites": ["bifurcation-theory", "iterated-maps"],
      "nextTopics": ["strange-attractors", "fractal-dimension"],
      "related": ["lyapunov-exponents", "ergodic-theory"],
      "applications": ["weather-prediction", "cryptography", "heart-dynamics"]
    },
    "tags": ["dynamical-systems", "chaos", "sensitivity"]
  },
  {
    "id": "lyapunov-exponents",
    "name": { "ko": "랴푸노프 지수", "en": "Lyapunov Exponents" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": "인접한 궤도가 분리되는 속도를 측정하는 지수입니다. 양의 리아푸노프 지수는 카오스의 특징입니다.",
      "en": "Exponents measuring the rate at which nearby trajectories separate. Positive Lyapunov exponents characterize chaos."
    },
    "latex": "\\lambda = \\lim_{t\\to\\infty} \\frac{1}{t} \\ln\\frac{|\\delta x(t)|}{|\\delta x(0)|}",
    "relations": {
      "prerequisites": ["differential-equations", "eigenvalue"],
      "nextTopics": ["chaos-theory", "attractor-dimension"],
      "related": ["stability-analysis", "oseledets-theorem"],
      "applications": ["chaos-detection", "predictability-analysis"]
    },
    "tags": ["dynamical-systems", "stability", "chaos"]
  },
  {
    "id": "strange-attractors",
    "name": { "ko": "이상한 끌개", "en": "Strange Attractors" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 5,
    "content": {
      "ko": "프랙탈 구조를 가진 카오스적 끌개입니다. 로렌츠 끌개, 헤논 맵 끌개가 대표적이며 자기닮음 구조를 보입니다.",
      "en": "Chaotic attractors with fractal structure. Lorenz and Hénon attractors are classic examples, exhibiting self-similar structure."
    },
    "latex": "\\dot{x} = \\sigma(y-x), \\quad \\dot{y} = x(\\rho-z)-y, \\quad \\dot{z} = xy-\\beta z",
    "relations": {
      "prerequisites": ["chaos-theory", "fractal"],
      "nextTopics": ["fractal-dimension", "hausdorff-dimension"],
      "related": ["lorenz-system", "henon-map"],
      "applications": ["turbulence", "electronic-circuits"]
    },
    "tags": ["dynamical-systems", "attractor", "fractal"]
  },
  {
    "id": "hamiltonian-dynamics",
    "name": { "ko": "해밀턴 역학", "en": "Hamiltonian Dynamics" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": "해밀토니안 함수로 기술되는 보존계의 역학입니다. 위상 공간에서 심플렉틱 구조를 보존하며 가적분계와 카오스를 모두 포함합니다.",
      "en": "Dynamics of conservative systems described by Hamiltonian functions. Preserves symplectic structure in phase space, encompassing both integrable and chaotic systems."
    },
    "latex": "\\dot{q} = \\frac{\\partial H}{\\partial p}, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q}",
    "relations": {
      "prerequisites": ["lagrangian-mechanics", "symplectic-geometry"],
      "nextTopics": ["kam-theory", "arnold-diffusion"],
      "related": ["canonical-transformations", "poisson-brackets"],
      "applications": ["celestial-mechanics", "plasma-physics", "molecular-dynamics"]
    },
    "tags": ["dynamical-systems", "hamiltonian", "symplectic"]
  },
  {
    "id": "ergodic-theory",
    "name": { "ko": "에르고드 이론", "en": "Ergodic Theory" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 5,
    "content": {
      "ko": "동역학계의 장기적 평균 행동을 측도론적으로 연구합니다. 시간 평균과 공간 평균의 일치가 핵심 개념입니다.",
      "en": "Studies long-term average behavior of dynamical systems using measure theory. The equality of time and space averages is the key concept."
    },
    "latex": "\\lim_{T\\to\\infty} \\frac{1}{T}\\int_0^T f(\\phi_t(x))\\,dt = \\int f\\,d\\mu",
    "relations": {
      "prerequisites": ["measure-theory", "dynamical-systems"],
      "nextTopics": ["mixing", "entropy-dynamical"],
      "related": ["birkhoff-theorem", "invariant-measure"],
      "applications": ["statistical-mechanics", "number-theory"]
    },
    "tags": ["dynamical-systems", "ergodic", "measure-theory"]
  },
  {
    "id": "center-manifold",
    "name": { "ko": "중심 다양체", "en": "Center Manifold" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 5,
    "content": {
      "ko": "고정점 근처에서 중립적 방향(영 고유값)에 접하는 불변 다양체입니다. 분기 분석과 차원 축소에 핵심적입니다.",
      "en": "An invariant manifold tangent to neutral directions (zero eigenvalues) near a fixed point. Essential for bifurcation analysis and dimension reduction."
    },
    "latex": "W^c = \\{x : \\phi_t(x) \\to 0 \\text{ polynomially as } t \\to \\pm\\infty\\}",
    "relations": {
      "prerequisites": ["stable-manifold", "eigenvalue"],
      "nextTopics": ["normal-forms", "bifurcation-theory"],
      "related": ["invariant-manifolds", "reduction-principle"],
      "applications": ["bifurcation-analysis", "control-theory"]
    },
    "tags": ["dynamical-systems", "manifold", "bifurcation"]
  },
  {
    "id": "poincare-map",
    "name": { "ko": "푸앵카레 사상", "en": "Poincaré Map" },
    "field": "analysis",
    "subfield": "dynamical-systems",
    "difficulty": 4,
    "content": {
      "ko": "연속 동역학계를 이산 사상으로 축소하는 기법입니다. 주기 궤도 분석과 카오스 연구에 필수적입니다.",
      "en": "A technique reducing continuous dynamical systems to discrete maps. Essential for analyzing periodic orbits and studying chaos."
    },
    "latex": "P: \\Sigma \\to \\Sigma, \\quad P(x) = \\phi_{\\tau(x)}(x)",
    "relations": {
      "prerequisites": ["differential-equations", "periodic-orbits"],
      "nextTopics": ["floquet-theory", "chaos-theory"],
      "related": ["section-surface", "return-map"],
      "applications": ["celestial-mechanics", "circuit-analysis"]
    },
    "tags": ["dynamical-systems", "discrete", "periodic"]
  },
  {
    "id": "tensor-definition",
    "name": { "ko": "텐서", "en": "Tensor" },
    "field": "algebra",
    "subfield": "tensor-analysis",
    "difficulty": 4,
    "content": {
      "ko": "다중선형 사상으로 정의되는 수학적 객체입니다. (p,q)-텐서는 p개의 공변 성분과 q개의 반변 성분을 가집니다.",
      "en": "A mathematical object defined as a multilinear map. A (p,q)-tensor has p covariant and q contravariant components."
    },
    "latex": "T: V^* \\times \\cdots \\times V^* \\times V \\times \\cdots \\times V \\to \\mathbb{R}",
    "relations": {
      "prerequisites": ["vector-space", "linear-transformation"],
      "nextTopics": ["tensor-product", "covariant-derivative"],
      "related": ["multilinear-algebra", "dual-space"],
      "applications": ["general-relativity", "continuum-mechanics", "machine-learning"]
    },
    "tags": ["tensor", "multilinear", "algebra"]
  },
  {
    "id": "tensor-product",
    "name": { "ko": "텐서곱", "en": "Tensor Product" },
    "field": "algebra",
    "subfield": "tensor-analysis",
    "difficulty": 4,
    "content": {
      "ko": "두 벡터 공간에서 새로운 벡터 공간을 구성하는 연산입니다. 쌍선형 사상의 보편적 성질로 특징지어집니다.",
      "en": "An operation constructing a new vector space from two vector spaces. Characterized by the universal property of bilinear maps."
    },
    "latex": "V \\otimes W = \\text{span}\\{v \\otimes w : v \\in V, w \\in W\\}",
    "relations": {
      "prerequisites": ["vector-space", "bilinear-map"],
      "nextTopics": ["tensor-definition", "exterior-algebra"],
      "related": ["kronecker-product", "universal-property"],
      "applications": ["quantum-mechanics", "multilinear-algebra"]
    },
    "tags": ["tensor", "algebra", "product"]
  },
  {
    "id": "covariant-contravariant",
    "name": { "ko": "공변/반변", "en": "Covariant/Contravariant" },
    "field": "algebra",
    "subfield": "tensor-analysis",
    "difficulty": 4,
    "content": {
      "ko": "좌표 변환에 따른 성분의 변환 법칙입니다. 공변 성분은 기저와 같이, 반변 성분은 반대로 변환됩니다.",
      "en": "Transformation rules for components under coordinate changes. Covariant components transform like basis, contravariant oppositely."
    },
    "latex": "T'^{i} = \\frac{\\partial x'^i}{\\partial x^j}T^j, \\quad T'_i = \\frac{\\partial x^j}{\\partial x'^i}T_j",
    "relations": {
      "prerequisites": ["coordinate-transformation", "basis"],
      "nextTopics": ["metric-tensor", "christoffel-symbols"],
      "related": ["index-notation", "einstein-summation"],
      "applications": ["differential-geometry", "physics"]
    },
    "tags": ["tensor", "transformation", "coordinates"]
  },
  {
    "id": "metric-tensor",
    "name": { "ko": "계량 텐서", "en": "Metric Tensor" },
    "field": "geometry",
    "subfield": "tensor-analysis",
    "difficulty": 4,
    "content": {
      "ko": "다양체 위의 거리와 각도를 정의하는 대칭 (0,2)-텐서입니다. 지표를 올리고 내리는 데 사용됩니다.",
      "en": "A symmetric (0,2)-tensor defining distances and angles on a manifold. Used to raise and lower indices."
    },
    "latex": "ds^2 = g_{ij}dx^i dx^j, \\quad T^i = g^{ij}T_j",
    "relations": {
      "prerequisites": ["tensor-definition", "inner-product"],
      "nextTopics": ["christoffel-symbols", "riemann-curvature"],
      "related": ["riemannian-manifold", "pseudo-riemannian"],
      "applications": ["general-relativity", "differential-geometry"]
    },
    "tags": ["tensor", "metric", "geometry"]
  },
  {
    "id": "christoffel-symbols",
    "name": { "ko": "크리스토펠 기호", "en": "Christoffel Symbols" },
    "field": "geometry",
    "subfield": "tensor-analysis",
    "difficulty": 4,
    "content": {
      "ko": "레비-치비타 연결의 좌표 표현입니다. 측지선 방정식과 공변 미분을 정의하는 데 사용됩니다.",
      "en": "Coordinate expression of the Levi-Civita connection. Used to define geodesic equations and covariant derivatives."
    },
    "latex": "\\Gamma^k_{ij} = \\frac{1}{2}g^{kl}\\left(\\partial_i g_{jl} + \\partial_j g_{il} - \\partial_l g_{ij}\\right)",
    "relations": {
      "prerequisites": ["metric-tensor", "partial-derivative"],
      "nextTopics": ["covariant-derivative", "geodesic"],
      "related": ["connection", "parallel-transport"],
      "applications": ["general-relativity", "geodesy"]
    },
    "tags": ["tensor", "connection", "differential-geometry"]
  },
  {
    "id": "covariant-derivative",
    "name": { "ko": "공변 미분", "en": "Covariant Derivative" },
    "field": "geometry",
    "subfield": "tensor-analysis",
    "difficulty": 5,
    "content": {
      "ko": "곡률이 있는 공간에서 텐서장을 미분하는 방법입니다. 평행 이동과 관련되며 좌표 독립적인 미분을 제공합니다.",
      "en": "A method of differentiating tensor fields in curved spaces. Related to parallel transport, providing coordinate-independent differentiation."
    },
    "latex": "\\nabla_i T^j_k = \\partial_i T^j_k + \\Gamma^j_{il}T^l_k - \\Gamma^l_{ik}T^j_l",
    "relations": {
      "prerequisites": ["christoffel-symbols", "tensor-definition"],
      "nextTopics": ["riemann-curvature", "geodesic-deviation"],
      "related": ["lie-derivative", "exterior-derivative"],
      "applications": ["general-relativity", "gauge-theory"]
    },
    "tags": ["tensor", "derivative", "connection"]
  },
  {
    "id": "riemann-curvature-tensor",
    "name": { "ko": "리만 곡률 텐서", "en": "Riemann Curvature Tensor" },
    "field": "geometry",
    "subfield": "tensor-analysis",
    "difficulty": 5,
    "content": {
      "ko": "다양체의 내재적 곡률을 측정하는 (1,3)-텐서입니다. 공변 미분의 비가환성으로 정의됩니다.",
      "en": "A (1,3)-tensor measuring intrinsic curvature of a manifold. Defined by the non-commutativity of covariant derivatives."
    },
    "latex": "R^\\rho_{\\sigma\\mu\\nu} = \\partial_\\mu\\Gamma^\\rho_{\\nu\\sigma} - \\partial_\\nu\\Gamma^\\rho_{\\mu\\sigma} + \\Gamma^\\rho_{\\mu\\lambda}\\Gamma^\\lambda_{\\nu\\sigma} - \\Gamma^\\rho_{\\nu\\lambda}\\Gamma^\\lambda_{\\mu\\sigma}",
    "relations": {
      "prerequisites": ["christoffel-symbols", "covariant-derivative"],
      "nextTopics": ["ricci-tensor", "einstein-field-equations"],
      "related": ["sectional-curvature", "bianchi-identities"],
      "applications": ["general-relativity", "differential-geometry"]
    },
    "tags": ["tensor", "curvature", "riemannian"]
  },
  {
    "id": "ricci-tensor",
    "name": { "ko": "리치 텐서", "en": "Ricci Tensor" },
    "field": "geometry",
    "subfield": "tensor-analysis",
    "difficulty": 5,
    "content": {
      "ko": "리만 곡률 텐서의 축약으로 얻어지는 대칭 (0,2)-텐서입니다. 아인슈타인 장 방정식의 핵심 구성 요소입니다.",
      "en": "A symmetric (0,2)-tensor obtained by contracting the Riemann tensor. Central component of Einstein field equations."
    },
    "latex": "R_{\\mu\\nu} = R^\\rho_{\\mu\\rho\\nu}, \\quad R = g^{\\mu\\nu}R_{\\mu\\nu}",
    "relations": {
      "prerequisites": ["riemann-curvature-tensor", "metric-tensor"],
      "nextTopics": ["einstein-tensor", "scalar-curvature"],
      "related": ["ricci-flow", "einstein-manifold"],
      "applications": ["general-relativity", "geometric-analysis"]
    },
    "tags": ["tensor", "curvature", "relativity"]
  },
  {
    "id": "lie-group",
    "name": { "ko": "리 군", "en": "Lie Group" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": "매끄러운 다양체 구조를 가진 군입니다. 군 연산이 미분 가능하며, 연속적인 대칭을 표현합니다.",
      "en": "A group with smooth manifold structure. Group operations are differentiable, representing continuous symmetries."
    },
    "latex": "G \\text{ is a Lie group if } \\mu: G \\times G \\to G, \\, \\iota: G \\to G \\text{ are smooth}",
    "relations": {
      "prerequisites": ["group-theory", "differentiable-manifold"],
      "nextTopics": ["lie-algebra", "exponential-map-lie"],
      "related": ["matrix-groups", "topological-groups"],
      "applications": ["physics", "differential-equations", "robotics"]
    },
    "tags": ["lie-theory", "group", "manifold"]
  },
  {
    "id": "lie-algebra",
    "name": { "ko": "리 대수", "en": "Lie Algebra" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": "리 군의 항등원에서의 접공간으로, 리 괄호 연산을 갖습니다. 군의 무한소 구조를 인코딩합니다.",
      "en": "The tangent space at the identity of a Lie group, equipped with Lie bracket. Encodes infinitesimal structure of the group."
    },
    "latex": "\\mathfrak{g} = T_eG, \\quad [X,Y] = XY - YX, \\quad [X,[Y,Z]] + [Y,[Z,X]] + [Z,[X,Y]] = 0",
    "relations": {
      "prerequisites": ["lie-group", "vector-space"],
      "nextTopics": ["structure-constants", "killing-form"],
      "related": ["bracket-operation", "jacobi-identity"],
      "applications": ["quantum-mechanics", "particle-physics"]
    },
    "tags": ["lie-theory", "algebra", "infinitesimal"]
  },
  {
    "id": "exponential-map-lie",
    "name": { "ko": "지수 사상", "en": "Exponential Map" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": "리 대수에서 리 군으로 가는 사상입니다. 무한소 생성자로부터 유한 변환을 생성합니다.",
      "en": "A map from Lie algebra to Lie group. Generates finite transformations from infinitesimal generators."
    },
    "latex": "\\exp: \\mathfrak{g} \\to G, \\quad \\exp(X) = \\sum_{n=0}^{\\infty} \\frac{X^n}{n!} = e^X",
    "relations": {
      "prerequisites": ["lie-group", "lie-algebra"],
      "nextTopics": ["baker-campbell-hausdorff", "one-parameter-subgroup"],
      "related": ["matrix-exponential", "adjoint-representation"],
      "applications": ["quantum-mechanics", "control-theory"]
    },
    "tags": ["lie-theory", "exponential", "mapping"]
  },
  {
    "id": "classical-lie-groups",
    "name": { "ko": "고전 리 군", "en": "Classical Lie Groups" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 4,
    "content": {
      "ko": "GL(n), SL(n), O(n), SO(n), U(n), SU(n), Sp(n) 등 행렬로 표현되는 기본적인 리 군들입니다.",
      "en": "Fundamental Lie groups represented as matrices: GL(n), SL(n), O(n), SO(n), U(n), SU(n), Sp(n)."
    },
    "latex": "SO(n) = \\{A \\in GL(n,\\mathbb{R}) : A^TA = I, \\det A = 1\\}",
    "relations": {
      "prerequisites": ["matrix", "group-theory"],
      "nextTopics": ["lie-group", "compact-lie-groups"],
      "related": ["rotation-group", "unitary-group"],
      "applications": ["physics", "computer-graphics", "robotics"]
    },
    "tags": ["lie-theory", "matrix-group", "classical"]
  },
  {
    "id": "adjoint-representation",
    "name": { "ko": "딸림 표현", "en": "Adjoint Representation" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": "리 군이 자신의 리 대수에 작용하는 표현입니다. 리 대수의 구조를 연구하는 데 핵심적입니다.",
      "en": "A representation of a Lie group acting on its own Lie algebra. Essential for studying Lie algebra structure."
    },
    "latex": "\\text{Ad}_g(X) = gXg^{-1}, \\quad \\text{ad}_X(Y) = [X,Y]",
    "relations": {
      "prerequisites": ["lie-group", "lie-algebra", "group-representation"],
      "nextTopics": ["killing-form", "root-system"],
      "related": ["conjugation", "inner-automorphism"],
      "applications": ["gauge-theory", "representation-theory"]
    },
    "tags": ["lie-theory", "representation", "adjoint"]
  },
  {
    "id": "killing-form",
    "name": { "ko": "킬링 형식", "en": "Killing Form" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": "리 대수 위의 대칭 쌍선형 형식입니다. 리 대수의 반단순성 판별과 분류에 핵심적입니다.",
      "en": "A symmetric bilinear form on a Lie algebra. Essential for determining semisimplicity and classification."
    },
    "latex": "B(X,Y) = \\text{tr}(\\text{ad}_X \\circ \\text{ad}_Y)",
    "relations": {
      "prerequisites": ["lie-algebra", "adjoint-representation"],
      "nextTopics": ["cartan-criterion", "root-system"],
      "related": ["semisimple-lie-algebra", "trace"],
      "applications": ["classification", "structure-theory"]
    },
    "tags": ["lie-theory", "bilinear-form", "semisimple"]
  },
  {
    "id": "root-system",
    "name": { "ko": "근계", "en": "Root System" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": "반단순 리 대수의 구조를 인코딩하는 유한 벡터 집합입니다. 딘킨 다이어그램으로 분류됩니다.",
      "en": "A finite set of vectors encoding the structure of semisimple Lie algebras. Classified by Dynkin diagrams."
    },
    "latex": "\\Phi \\subset \\mathfrak{h}^*, \\quad \\alpha \\in \\Phi \\Rightarrow -\\alpha \\in \\Phi, \\quad \\langle \\alpha, \\beta^\\vee \\rangle \\in \\mathbb{Z}",
    "relations": {
      "prerequisites": ["semisimple-lie-algebra", "cartan-subalgebra"],
      "nextTopics": ["weyl-group", "dynkin-diagram"],
      "related": ["simple-roots", "cartan-matrix"],
      "applications": ["representation-theory", "algebraic-groups"]
    },
    "tags": ["lie-theory", "root", "classification"]
  },
  {
    "id": "semisimple-lie-algebra",
    "name": { "ko": "반단순 리 대수", "en": "Semisimple Lie Algebra" },
    "field": "algebra",
    "subfield": "lie-theory",
    "difficulty": 5,
    "content": {
      "ko": "가해 이데알이 없는 리 대수입니다. 단순 리 대수들의 직합으로 분해되며, 킬링 형식이 비퇴화입니다.",
      "en": "A Lie algebra with no solvable ideals. Decomposes as direct sum of simple Lie algebras; Killing form is non-degenerate."
    },
    "latex": "\\mathfrak{g} = \\mathfrak{g}_1 \\oplus \\cdots \\oplus \\mathfrak{g}_k, \\quad \\mathfrak{g}_i \\text{ simple}",
    "relations": {
      "prerequisites": ["lie-algebra", "ideal"],
      "nextTopics": ["root-system", "cartan-decomposition"],
      "related": ["simple-lie-algebra", "radical"],
      "applications": ["representation-theory", "theoretical-physics"]
    },
    "tags": ["lie-theory", "semisimple", "structure"]
  },
  {
    "id": "fundamental-group",
    "name": { "ko": "기본군", "en": "Fundamental Group" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 4,
    "content": {
      "ko": "공간의 루프들을 호모토피 동치류로 분류한 군입니다. 공간의 1차원적 구멍 구조를 인코딩합니다.",
      "en": "A group classifying loops in a space up to homotopy equivalence. Encodes 1-dimensional hole structure of spaces."
    },
    "latex": "\\pi_1(X, x_0) = \\{[\\gamma] : \\gamma: [0,1] \\to X, \\gamma(0)=\\gamma(1)=x_0\\}",
    "relations": {
      "prerequisites": ["homotopy", "group-theory"],
      "nextTopics": ["covering-space", "higher-homotopy"],
      "related": ["path-connected", "simply-connected"],
      "applications": ["knot-theory", "surface-classification"]
    },
    "tags": ["topology", "algebraic-topology", "homotopy"]
  },
  {
    "id": "homology-group",
    "name": { "ko": "호몰로지 군", "en": "Homology Group" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 5,
    "content": {
      "ko": "공간의 n차원 구멍을 측정하는 아벨 군입니다. 경계가 없는 사이클과 경계인 사이클의 몫으로 정의됩니다.",
      "en": "Abelian groups measuring n-dimensional holes in a space. Defined as quotient of cycles without boundary by boundaries."
    },
    "latex": "H_n(X) = \\ker \\partial_n / \\text{im } \\partial_{n+1} = Z_n / B_n",
    "relations": {
      "prerequisites": ["chain-complex", "group-theory"],
      "nextTopics": ["cohomology", "exact-sequence"],
      "related": ["euler-characteristic", "betti-numbers"],
      "applications": ["data-analysis", "image-processing", "robotics"]
    },
    "tags": ["topology", "algebraic-topology", "homology"]
  },
  {
    "id": "cohomology-group",
    "name": { "ko": "코호몰로지 군", "en": "Cohomology Group" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 5,
    "content": {
      "ko": "호몰로지의 쌍대 개념으로, 곱 구조(컵곱)를 가집니다. 미분 형식과 드람 코호몰로지와 연결됩니다.",
      "en": "Dual notion of homology with product structure (cup product). Connected to differential forms and de Rham cohomology."
    },
    "latex": "H^n(X; R) = \\text{Hom}(H_n(X), R), \\quad \\smile: H^p \\times H^q \\to H^{p+q}",
    "relations": {
      "prerequisites": ["homology-group", "dual-space"],
      "nextTopics": ["cup-product", "de-rham-cohomology"],
      "related": ["poincare-duality", "characteristic-classes"],
      "applications": ["algebraic-geometry", "physics"]
    },
    "tags": ["topology", "algebraic-topology", "cohomology"]
  },
  {
    "id": "homotopy-groups",
    "name": { "ko": "호모토피 군", "en": "Homotopy Groups" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 5,
    "content": {
      "ko": "n차원 구의 공간으로의 사상을 호모토피 동치류로 분류한 군입니다. n≥2일 때 아벨 군이 됩니다.",
      "en": "Groups classifying maps from n-spheres to spaces up to homotopy. Abelian for n≥2."
    },
    "latex": "\\pi_n(X, x_0) = [(S^n, s_0), (X, x_0)], \\quad \\pi_n(S^n) \\cong \\mathbb{Z}",
    "relations": {
      "prerequisites": ["fundamental-group", "spheres"],
      "nextTopics": ["fibration", "exact-homotopy-sequence"],
      "related": ["whitehead-theorem", "hurewicz-theorem"],
      "applications": ["obstruction-theory", "stable-homotopy"]
    },
    "tags": ["topology", "algebraic-topology", "homotopy"]
  },
  {
    "id": "covering-space",
    "name": { "ko": "피복 공간", "en": "Covering Space" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 4,
    "content": {
      "ko": "각 점의 균등 피복 근방이 존재하는 연속 전사입니다. 기본군의 부분군과 일대일 대응합니다.",
      "en": "A continuous surjection with evenly covered neighborhoods at each point. In bijection with subgroups of the fundamental group."
    },
    "latex": "p: \\tilde{X} \\to X, \\quad p^{-1}(U) = \\bigsqcup_\\alpha V_\\alpha, \\quad p|_{V_\\alpha}: V_\\alpha \\xrightarrow{\\sim} U",
    "relations": {
      "prerequisites": ["fundamental-group", "continuous-function"],
      "nextTopics": ["deck-transformations", "universal-cover"],
      "related": ["lifting-property", "galois-correspondence"],
      "applications": ["riemann-surfaces", "knot-theory"]
    },
    "tags": ["topology", "algebraic-topology", "covering"]
  },
  {
    "id": "exact-sequence",
    "name": { "ko": "완전 열", "en": "Exact Sequence" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 4,
    "content": {
      "ko": "각 사상의 상이 다음 사상의 핵과 같은 군 준동형의 열입니다. 짧은 완전열과 긴 완전열이 중요합니다.",
      "en": "A sequence of group homomorphisms where image equals kernel at each step. Short and long exact sequences are important."
    },
    "latex": "0 \\to A \\xrightarrow{f} B \\xrightarrow{g} C \\to 0, \\quad \\text{im } f = \\ker g",
    "relations": {
      "prerequisites": ["group-homomorphism", "kernel-image"],
      "nextTopics": ["snake-lemma", "long-exact-sequence"],
      "related": ["split-exact", "five-lemma"],
      "applications": ["homological-algebra", "k-theory"]
    },
    "tags": ["algebra", "algebraic-topology", "exact"]
  },
  {
    "id": "cw-complex",
    "name": { "ko": "CW 복합체", "en": "CW Complex" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 4,
    "content": {
      "ko": "셀을 차원별로 부착하여 만든 위상 공간입니다. 대수적 위상수학에서 공간을 다루는 표준적 방법입니다.",
      "en": "A topological space built by attaching cells dimension by dimension. Standard approach for handling spaces in algebraic topology."
    },
    "latex": "X = X^0 \\subset X^1 \\subset X^2 \\subset \\cdots, \\quad X^n = X^{n-1} \\cup_\\phi e^n",
    "relations": {
      "prerequisites": ["topology", "cell"],
      "nextTopics": ["cellular-homology", "whitehead-theorem"],
      "related": ["simplicial-complex", "attaching-map"],
      "applications": ["homotopy-theory", "classification"]
    },
    "tags": ["topology", "algebraic-topology", "cell-complex"]
  },
  {
    "id": "euler-characteristic",
    "name": { "ko": "오일러 지표", "en": "Euler Characteristic" },
    "field": "topology",
    "subfield": "algebraic-topology",
    "difficulty": 3,
    "content": {
      "ko": "공간의 위상적 불변량으로, 베티 수의 교대합입니다. 다면체에서는 V-E+F로 계산됩니다.",
      "en": "A topological invariant of spaces, alternating sum of Betti numbers. For polyhedra, computed as V-E+F."
    },
    "latex": "\\chi(X) = \\sum_{n=0}^{\\infty} (-1)^n b_n = \\sum_{n=0}^{\\infty} (-1)^n \\dim H_n(X)",
    "relations": {
      "prerequisites": ["homology-group", "betti-numbers"],
      "nextTopics": ["gauss-bonnet", "lefschetz-fixed-point"],
      "related": ["genus", "polyhedra"],
      "applications": ["surface-classification", "graph-theory"]
    },
    "tags": ["topology", "invariant", "euler"]
  },
  {
    "id": "fourier-series-advanced",
    "name": { "ko": "푸리에 급수 심화", "en": "Fourier Series (Advanced)" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 4,
    "content": {
      "ko": "주기함수를 삼각함수의 급수로 전개합니다. 수렴 조건, 기브스 현상, 파세발 정리가 핵심 주제입니다.",
      "en": "Expansion of periodic functions as series of trigonometric functions. Convergence conditions, Gibbs phenomenon, and Parseval's theorem are key topics."
    },
    "latex": "f(x) = \\sum_{n=-\\infty}^{\\infty} c_n e^{inx}, \\quad \\sum|c_n|^2 = \\frac{1}{2\\pi}\\int|f|^2 dx",
    "relations": {
      "prerequisites": ["fourier-series", "convergence"],
      "nextTopics": ["fourier-transform-advanced", "distribution-theory"],
      "related": ["parseval-theorem", "fejer-kernel"],
      "applications": ["signal-processing", "heat-equation"]
    },
    "tags": ["harmonic-analysis", "fourier", "series"]
  },
  {
    "id": "fourier-transform-advanced",
    "name": { "ko": "푸리에 변환 심화", "en": "Fourier Transform (Advanced)" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 4,
    "content": {
      "ko": "함수를 주파수 영역으로 변환합니다. 슈워츠 공간, 플랑슈렐 정리, 역변환이 핵심입니다.",
      "en": "Transforms functions to frequency domain. Schwartz space, Plancherel theorem, and inverse transform are essential."
    },
    "latex": "\\hat{f}(\\xi) = \\int_{\\mathbb{R}^n} f(x)e^{-2\\pi i x \\cdot \\xi}dx, \\quad \\|\\hat{f}\\|_2 = \\|f\\|_2",
    "relations": {
      "prerequisites": ["fourier-transform", "lebesgue-integral"],
      "nextTopics": ["distribution-theory", "wavelets"],
      "related": ["convolution-theorem", "uncertainty-principle"],
      "applications": ["quantum-mechanics", "image-processing", "pde"]
    },
    "tags": ["harmonic-analysis", "fourier", "transform"]
  },
  {
    "id": "distribution-theory",
    "name": { "ko": "초함수론", "en": "Distribution Theory" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 5,
    "content": {
      "ko": "시험함수 공간 위의 연속 선형 범함수입니다. 디랙 델타 같은 특이 객체를 미분 가능하게 다룹니다.",
      "en": "Continuous linear functionals on test function spaces. Allows differentiation of singular objects like Dirac delta."
    },
    "latex": "\\langle T, \\phi \\rangle, \\quad \\langle T', \\phi \\rangle = -\\langle T, \\phi' \\rangle, \\quad \\delta(x) = \\lim_{\\epsilon \\to 0} \\frac{1}{\\epsilon}\\phi(x/\\epsilon)",
    "relations": {
      "prerequisites": ["functional-analysis", "test-functions"],
      "nextTopics": ["sobolev-spaces", "pseudodifferential-operators"],
      "related": ["schwartz-space", "tempered-distributions"],
      "applications": ["pde", "quantum-field-theory"]
    },
    "tags": ["harmonic-analysis", "distribution", "generalized-function"]
  },
  {
    "id": "wavelets",
    "name": { "ko": "웨이블릿", "en": "Wavelets" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 4,
    "content": {
      "ko": "국소화된 진동 함수의 족입니다. 시간-주파수 분석에서 푸리에 분석의 한계를 보완합니다.",
      "en": "A family of localized oscillating functions. Complements limitations of Fourier analysis in time-frequency analysis."
    },
    "latex": "\\psi_{a,b}(t) = \\frac{1}{\\sqrt{|a|}}\\psi\\left(\\frac{t-b}{a}\\right), \\quad \\int \\psi(t)dt = 0",
    "relations": {
      "prerequisites": ["fourier-transform-advanced", "inner-product"],
      "nextTopics": ["multiresolution-analysis", "discrete-wavelet"],
      "related": ["haar-wavelet", "daubechies-wavelet"],
      "applications": ["image-compression", "denoising", "data-analysis"]
    },
    "tags": ["harmonic-analysis", "wavelet", "time-frequency"]
  },
  {
    "id": "spherical-harmonics",
    "name": { "ko": "구면 조화 함수", "en": "Spherical Harmonics" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 4,
    "content": {
      "ko": "구면 위 라플라시안의 고유함수입니다. 구면 위 함수의 정규직교 기저를 형성합니다.",
      "en": "Eigenfunctions of the Laplacian on the sphere. Form an orthonormal basis for functions on the sphere."
    },
    "latex": "Y_l^m(\\theta, \\phi), \\quad \\Delta_{S^2} Y_l^m = -l(l+1)Y_l^m",
    "relations": {
      "prerequisites": ["laplacian", "orthonormal-basis"],
      "nextTopics": ["representation-theory", "quantum-angular-momentum"],
      "related": ["legendre-polynomials", "zonal-harmonics"],
      "applications": ["quantum-mechanics", "geophysics", "computer-graphics"]
    },
    "tags": ["harmonic-analysis", "spherical", "eigenfunction"]
  },
  {
    "id": "singular-integrals",
    "name": { "ko": "특이 적분", "en": "Singular Integrals" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 5,
    "content": {
      "ko": "커널이 특이점을 갖는 적분 연산자입니다. 힐베르트 변환과 칼데론-지그문트 이론이 핵심입니다.",
      "en": "Integral operators with singular kernels. Hilbert transform and Calderón-Zygmund theory are central."
    },
    "latex": "Tf(x) = \\text{p.v.} \\int K(x-y)f(y)dy, \\quad |K(x)| \\leq \\frac{C}{|x|^n}",
    "relations": {
      "prerequisites": ["lebesgue-integral", "operator-theory"],
      "nextTopics": ["calderon-zygmund", "bmo-space"],
      "related": ["hilbert-transform", "riesz-transform"],
      "applications": ["pde", "complex-analysis"]
    },
    "tags": ["harmonic-analysis", "singular", "operator"]
  },
  {
    "id": "fourier-analysis-groups",
    "name": { "ko": "군 위의 푸리에 해석", "en": "Fourier Analysis on Groups" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 5,
    "content": {
      "ko": "국소 콤팩트 아벨 군 위에서 푸리에 해석을 일반화합니다. 폰트랴긴 쌍대성이 핵심 정리입니다.",
      "en": "Generalizes Fourier analysis to locally compact abelian groups. Pontryagin duality is the key theorem."
    },
    "latex": "\\hat{G} = \\text{Hom}(G, S^1), \\quad \\hat{\\hat{G}} \\cong G",
    "relations": {
      "prerequisites": ["group-theory", "fourier-transform-advanced"],
      "nextTopics": ["noncommutative-harmonic-analysis", "representation-theory"],
      "related": ["character-group", "haar-measure"],
      "applications": ["number-theory", "signal-processing"]
    },
    "tags": ["harmonic-analysis", "group", "duality"]
  },
  {
    "id": "littlewood-paley-theory",
    "name": { "ko": "리틀우드-페일리 이론", "en": "Littlewood-Paley Theory" },
    "field": "analysis",
    "subfield": "harmonic-analysis",
    "difficulty": 5,
    "content": {
      "ko": "함수를 주파수 대역별로 분해하는 이론입니다. 여러 함수 공간의 특성화와 조화해석에 필수적입니다.",
      "en": "Theory decomposing functions by frequency bands. Essential for characterizing function spaces and harmonic analysis."
    },
    "latex": "\\|f\\|_{L^p} \\sim \\left\\|\\left(\\sum_j |P_j f|^2\\right)^{1/2}\\right\\|_{L^p}",
    "relations": {
      "prerequisites": ["fourier-transform-advanced", "functional-analysis"],
      "nextTopics": ["besov-spaces", "triebel-lizorkin"],
      "related": ["dyadic-decomposition", "square-function"],
      "applications": ["pde", "interpolation-theory"]
    },
    "tags": ["harmonic-analysis", "decomposition", "function-spaces"]
  }
]
