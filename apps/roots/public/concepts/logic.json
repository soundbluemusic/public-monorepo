[
  {
    "id": "propositional-logic",
    "name": { "ko": "명제 논리", "en": "Propositional Logic" },
    "field": "logic",
    "subfield": "propositional",
    "difficulty": 2,
    "content": {
      "ko": {
        "definition": "명제 논리는 참 또는 거짓 값을 가지는 명제들과 논리 연결사(AND, OR, NOT 등)를 다루는 형식 체계입니다.",
        "formulas": [
          { "latex": "\\neg p", "description": "부정 (NOT)" },
          { "latex": "p \\land q", "description": "논리곱 (AND)" },
          { "latex": "p \\lor q", "description": "논리합 (OR)" },
          { "latex": "p \\to q \\equiv \\neg p \\lor q", "description": "조건문 (IF-THEN)" },
          {
            "latex": "p \\leftrightarrow q \\equiv (p \\to q) \\land (q \\to p)",
            "description": "쌍조건문 (IFF)"
          }
        ],
        "examples": [
          {
            "problem": "p = '비가 온다', q = '땅이 젖는다'일 때 p → q의 의미는?",
            "solution": "'비가 오면 땅이 젖는다'. 비가 오지 않으면 결과와 관계없이 참입니다."
          }
        ],
        "applications": [
          { "field": "컴퓨터 과학", "description": "불리언 대수, 회로 설계" },
          { "field": "수학", "description": "증명 기초" },
          { "field": "AI", "description": "지식 표현" }
        ]
      },
      "en": {
        "definition": "Propositional logic is a formal system dealing with propositions (true/false) and logical connectives (AND, OR, NOT, etc.).",
        "formulas": [
          { "latex": "\\neg p", "description": "Negation (NOT)" },
          { "latex": "p \\land q", "description": "Conjunction (AND)" },
          { "latex": "p \\lor q", "description": "Disjunction (OR)" },
          { "latex": "p \\to q \\equiv \\neg p \\lor q", "description": "Implication (IF-THEN)" },
          {
            "latex": "p \\leftrightarrow q \\equiv (p \\to q) \\land (q \\to p)",
            "description": "Biconditional (IFF)"
          }
        ],
        "examples": [
          {
            "problem": "If p = 'It rains', q = 'Ground is wet', what does p → q mean?",
            "solution": "'If it rains, the ground is wet'. True when it doesn't rain regardless of q."
          }
        ],
        "applications": [
          { "field": "Computer Science", "description": "Boolean algebra, circuit design" },
          { "field": "Mathematics", "description": "Proof foundations" },
          { "field": "AI", "description": "Knowledge representation" }
        ]
      }
    },
    "relations": {
      "prerequisites": [],
      "nextTopics": ["predicate-logic", "boolean-algebra"],
      "related": ["sets"]
    },
    "tags": ["명제", "논리", "propositional", "logic"]
  },
  {
    "id": "predicate-logic",
    "name": { "ko": "술어 논리", "en": "Predicate Logic" },
    "field": "logic",
    "subfield": "predicate",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "술어 논리(1차 논리)는 명제 논리를 확장하여 변수, 양화사(∀, ∃), 술어를 포함합니다. 수학적 명제를 정확히 표현할 수 있습니다.",
        "formulas": [
          { "latex": "\\forall x \\, P(x)", "description": "전칭 양화사 (모든 x에 대해)" },
          { "latex": "\\exists x \\, P(x)", "description": "존재 양화사 (어떤 x가 존재하여)" },
          {
            "latex": "\\neg (\\forall x \\, P(x)) \\equiv \\exists x \\, \\neg P(x)",
            "description": "양화사 부정"
          }
        ],
        "examples": [
          {
            "problem": "'모든 인간은 죽는다'를 술어 논리로 표현하세요.",
            "solution": "∀x (Human(x) → Mortal(x))"
          },
          {
            "problem": "'모든 자연수에는 더 큰 소수가 있다'를 표현하세요.",
            "solution": "∀n ∃p (Prime(p) ∧ p > n)"
          }
        ],
        "applications": [
          { "field": "수학", "description": "공리계, 정리 증명" },
          { "field": "AI", "description": "자동 정리 증명, 지식 베이스" },
          { "field": "데이터베이스", "description": "SQL 쿼리의 이론적 기반" }
        ]
      },
      "en": {
        "definition": "Predicate logic (first-order logic) extends propositional logic with variables, quantifiers (∀, ∃), and predicates. It can express mathematical statements precisely.",
        "formulas": [
          { "latex": "\\forall x \\, P(x)", "description": "Universal quantifier (for all x)" },
          {
            "latex": "\\exists x \\, P(x)",
            "description": "Existential quantifier (there exists x)"
          },
          {
            "latex": "\\neg (\\forall x \\, P(x)) \\equiv \\exists x \\, \\neg P(x)",
            "description": "Quantifier negation"
          }
        ],
        "examples": [
          {
            "problem": "Express 'All humans are mortal' in predicate logic.",
            "solution": "∀x (Human(x) → Mortal(x))"
          },
          {
            "problem": "Express 'For every natural number, there's a larger prime'.",
            "solution": "∀n ∃p (Prime(p) ∧ p > n)"
          }
        ],
        "applications": [
          { "field": "Mathematics", "description": "Axiomatic systems, theorem proving" },
          { "field": "AI", "description": "Automated theorem proving, knowledge bases" },
          { "field": "Databases", "description": "Theoretical foundation of SQL" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["propositional-logic"],
      "nextTopics": ["proof-theory", "model-theory"],
      "related": ["sets"]
    },
    "tags": ["술어", "양화사", "predicate", "quantifier"]
  },
  {
    "id": "proof-methods",
    "name": { "ko": "증명 방법", "en": "Proof Methods" },
    "field": "logic",
    "subfield": "proof-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수학적 증명은 공리와 이미 증명된 정리로부터 논리적으로 결론을 도출하는 과정입니다. 직접 증명, 귀류법, 수학적 귀납법 등이 있습니다.",
        "formulas": [
          { "latex": "P \\to Q \\text{ (직접 증명)}", "description": "P가 참이면 Q가 참임을 보임" },
          {
            "latex": "\\neg Q \\to \\neg P \\text{ (대우 증명)}",
            "description": "Q의 부정에서 P의 부정을 도출"
          },
          {
            "latex": "\\neg P \\to \\text{모순} \\Rightarrow P \\text{ (귀류법)}",
            "description": "P의 부정이 모순을 유도하면 P는 참"
          }
        ],
        "examples": [
          {
            "problem": "√2가 무리수임을 귀류법으로 증명하세요.",
            "solution": "√2 = a/b (기약분수)라 가정. 2 = a²/b²이므로 a² = 2b². a는 짝수, a = 2k라 하면 4k² = 2b², b² = 2k². b도 짝수. 이는 기약분수 가정에 모순."
          }
        ],
        "applications": [
          { "field": "수학", "description": "정리 증명" },
          { "field": "컴퓨터 과학", "description": "알고리즘 정확성 증명" },
          { "field": "형식 검증", "description": "소프트웨어 검증" }
        ]
      },
      "en": {
        "definition": "Mathematical proof is the process of deriving conclusions logically from axioms and proven theorems. Methods include direct proof, contradiction, and induction.",
        "formulas": [
          {
            "latex": "P \\to Q \\text{ (direct proof)}",
            "description": "Assume P true, show Q true"
          },
          {
            "latex": "\\neg Q \\to \\neg P \\text{ (contrapositive)}",
            "description": "Derive ¬P from ¬Q"
          },
          {
            "latex": "\\neg P \\to \\text{contradiction} \\Rightarrow P \\text{ (proof by contradiction)}",
            "description": "If ¬P leads to contradiction, P is true"
          }
        ],
        "examples": [
          {
            "problem": "Prove √2 is irrational by contradiction.",
            "solution": "Assume √2 = a/b in lowest terms. 2 = a²/b², so a² = 2b². a is even, let a = 2k. Then 4k² = 2b², b² = 2k². b is also even. Contradicts lowest terms."
          }
        ],
        "applications": [
          { "field": "Mathematics", "description": "Theorem proving" },
          { "field": "Computer Science", "description": "Algorithm correctness" },
          { "field": "Formal Verification", "description": "Software verification" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["propositional-logic"],
      "nextTopics": ["mathematical-induction"],
      "related": ["sets"]
    },
    "tags": ["증명", "귀류법", "proof", "contradiction"]
  },
  {
    "id": "mathematical-induction",
    "name": { "ko": "수학적 귀납법", "en": "Mathematical Induction" },
    "field": "logic",
    "subfield": "proof-theory",
    "difficulty": 3,
    "content": {
      "ko": {
        "definition": "수학적 귀납법은 자연수에 대한 명제를 증명하는 방법입니다. 기초 단계(n=1)와 귀납 단계(n=k → n=k+1)로 구성됩니다.",
        "formulas": [
          {
            "latex": "P(1) \\land (\\forall k \\, (P(k) \\to P(k+1))) \\Rightarrow \\forall n \\, P(n)",
            "description": "수학적 귀납법의 원리"
          }
        ],
        "examples": [
          {
            "problem": "1 + 2 + ... + n = n(n+1)/2임을 귀납법으로 증명하세요.",
            "solution": "기초: n=1일 때 1 = 1×2/2 ✓. 귀납: 1+...+k = k(k+1)/2 가정. 1+...+k+(k+1) = k(k+1)/2 + (k+1) = (k+1)(k+2)/2 ✓"
          }
        ],
        "history": {
          "discoveredBy": "파스칼, 페르마",
          "year": "17세기",
          "background": "귀납법의 원리는 자연수의 정의에 내재되어 있으며, 명시적으로 사용된 것은 17세기부터입니다."
        },
        "applications": [
          { "field": "수학", "description": "급수 공식, 부등식 증명" },
          { "field": "컴퓨터 과학", "description": "재귀 알고리즘 분석" },
          { "field": "형식 언어", "description": "문법 성질 증명" }
        ]
      },
      "en": {
        "definition": "Mathematical induction proves statements about natural numbers. It consists of base case (n=1) and inductive step (n=k → n=k+1).",
        "formulas": [
          {
            "latex": "P(1) \\land (\\forall k \\, (P(k) \\to P(k+1))) \\Rightarrow \\forall n \\, P(n)",
            "description": "Principle of mathematical induction"
          }
        ],
        "examples": [
          {
            "problem": "Prove 1 + 2 + ... + n = n(n+1)/2 by induction.",
            "solution": "Base: n=1, 1 = 1×2/2 ✓. Inductive: Assume for k. Then 1+...+k+(k+1) = k(k+1)/2 + (k+1) = (k+1)(k+2)/2 ✓"
          }
        ],
        "history": {
          "discoveredBy": "Pascal, Fermat",
          "year": "17th century",
          "background": "The principle is inherent in natural number definition, explicitly used from 17th century."
        },
        "applications": [
          { "field": "Mathematics", "description": "Series formulas, inequality proofs" },
          { "field": "Computer Science", "description": "Recursive algorithm analysis" },
          { "field": "Formal Languages", "description": "Grammar property proofs" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["natural-numbers", "proof-methods"],
      "nextTopics": ["strong-induction", "structural-induction"],
      "related": ["recursion"]
    },
    "tags": ["귀납법", "증명", "induction", "proof"]
  },
  {
    "id": "godels-incompleteness",
    "name": { "ko": "괴델의 불완전성 정리", "en": "Gödel's Incompleteness Theorems" },
    "field": "logic",
    "subfield": "foundations",
    "difficulty": 5,
    "content": {
      "ko": {
        "definition": "괴델의 불완전성 정리는 충분히 강력한 수학 체계에서는 증명도 반증도 할 수 없는 참인 명제가 존재함을 보여줍니다.",
        "formulas": [
          {
            "latex": "\\text{Con}(F) \\to \\exists G \\, (F \\nvdash G \\land F \\nvdash \\neg G)",
            "description": "제1 불완전성 정리 (비형식적)"
          },
          {
            "latex": "\\text{Con}(F) \\to F \\nvdash \\text{Con}(F)",
            "description": "제2 불완전성 정리"
          }
        ],
        "examples": [
          {
            "problem": "괴델 문장의 아이디어를 설명하세요.",
            "solution": "'이 문장은 증명될 수 없다'를 형식화. 만약 증명 가능하면 거짓인 것이 증명됨(모순). 증명 불가능하면 참이지만 증명 불가."
          }
        ],
        "history": {
          "discoveredBy": "쿠르트 괴델",
          "year": "1931년",
          "background": "힐베르트 프로그램에 대한 응답으로, 수학의 완전한 형식화가 불가능함을 보였습니다."
        },
        "applications": [
          { "field": "수학기초론", "description": "형식 체계의 한계" },
          { "field": "컴퓨터 과학", "description": "정지 문제, 계산가능성" },
          { "field": "철학", "description": "진리와 증명의 관계" }
        ]
      },
      "en": {
        "definition": "Gödel's incompleteness theorems show that in any sufficiently powerful mathematical system, there exist true statements that cannot be proved or disproved.",
        "formulas": [
          {
            "latex": "\\text{Con}(F) \\to \\exists G \\, (F \\nvdash G \\land F \\nvdash \\neg G)",
            "description": "First incompleteness theorem (informal)"
          },
          {
            "latex": "\\text{Con}(F) \\to F \\nvdash \\text{Con}(F)",
            "description": "Second incompleteness theorem"
          }
        ],
        "examples": [
          {
            "problem": "Explain the idea of Gödel sentence.",
            "solution": "Formalize 'This statement is unprovable'. If provable, proves a false statement (contradiction). If unprovable, it's true but unprovable."
          }
        ],
        "history": {
          "discoveredBy": "Kurt Gödel",
          "year": "1931",
          "background": "Response to Hilbert's program, showing complete formalization of mathematics is impossible."
        },
        "applications": [
          { "field": "Foundations", "description": "Limits of formal systems" },
          { "field": "Computer Science", "description": "Halting problem, computability" },
          { "field": "Philosophy", "description": "Truth vs. provability" }
        ]
      }
    },
    "relations": {
      "prerequisites": ["predicate-logic", "proof-theory"],
      "nextTopics": ["computability"],
      "related": ["halting-problem"]
    },
    "tags": ["괴델", "불완전성", "Gödel", "incompleteness"]
  },
  {
    "id": "godel-incompleteness",
    "name": { "ko": "괴델의 불완전성 정리", "en": "Gödel's Incompleteness Theorems" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "충분히 강력한 형식 체계는 참이지만 증명할 수 없는 명제를 포함하며(제1정리), 자신의 무모순성을 증명할 수 없습니다(제2정리).",
      "en": "Sufficiently powerful formal systems contain true but unprovable statements (first theorem) and cannot prove their own consistency (second theorem)."
    },
    "latex": "\\text{Con}(T) \\Rightarrow \\exists \\varphi: T \\nvdash \\varphi \\land T \\nvdash \\neg\\varphi",
    "relations": {
      "prerequisites": ["first-order-logic", "peano-arithmetic"],
      "nextTopics": ["proof-theory", "recursion-theory"],
      "related": ["halting-problem", "undecidability"],
      "applications": ["foundations-of-mathematics", "philosophy-of-math"]
    },
    "tags": ["logic", "foundations", "incompleteness"]
  },
  {
    "id": "model-theory",
    "name": { "ko": "모델 이론", "en": "Model Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "형식 언어와 그것이 해석되는 수학적 구조(모델) 사이의 관계를 연구합니다. 완전성, 콤팩트성, 뢰벤하임-스콜렘 정리가 핵심입니다.",
      "en": "Studies the relationship between formal languages and mathematical structures (models) interpreting them. Completeness, compactness, and Löwenheim-Skolem are key results."
    },
    "latex": "T \\models \\varphi \\Leftrightarrow T \\vdash \\varphi \\quad \\text{(Completeness)}",
    "relations": {
      "prerequisites": ["first-order-logic", "set-theory"],
      "nextTopics": ["stability-theory", "categoricity"],
      "related": ["universal-algebra", "ultraproducts"],
      "applications": ["algebraic-geometry", "number-theory"]
    },
    "tags": ["logic", "model-theory", "semantics"]
  },
  {
    "id": "proof-theory",
    "name": { "ko": "증명 이론", "en": "Proof Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "형식적 증명 자체를 수학적 대상으로 연구합니다. 자연 연역, 시퀀트 계산, 컷 제거, 증명의 정규화가 핵심 주제입니다.",
      "en": "Studies formal proofs as mathematical objects. Natural deduction, sequent calculus, cut elimination, and proof normalization are key topics."
    },
    "latex": "\\frac{\\Gamma \\vdash A \\quad \\Delta, A \\vdash B}{\\Gamma, \\Delta \\vdash B} \\text{ (Cut)}",
    "relations": {
      "prerequisites": ["first-order-logic", "formal-systems"],
      "nextTopics": ["ordinal-analysis", "reverse-mathematics"],
      "related": ["type-theory", "constructive-mathematics"],
      "applications": ["automated-theorem-proving", "program-verification"]
    },
    "tags": ["logic", "proof-theory", "formal-methods"]
  },
  {
    "id": "computability-theory",
    "name": { "ko": "계산 가능성 이론", "en": "Computability Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 4,
    "content": {
      "ko": "알고리즘으로 계산 가능한 것의 한계를 연구합니다. 튜링 기계, 정지 문제, 결정 불가능성, 튜링 차수가 핵심 개념입니다.",
      "en": "Studies the limits of what can be computed algorithmically. Turing machines, halting problem, undecidability, and Turing degrees are key concepts."
    },
    "latex": "\\text{HALT} = \\{\\langle M, w \\rangle : M \\text{ halts on } w\\} \\text{ is undecidable}",
    "relations": {
      "prerequisites": ["turing-machine", "formal-languages"],
      "nextTopics": ["complexity-theory", "oracle-computation"],
      "related": ["godel-incompleteness", "church-turing-thesis"],
      "applications": ["theoretical-computer-science", "ai-limits"]
    },
    "tags": ["logic", "computability", "turing"]
  },
  {
    "id": "modal-logic",
    "name": { "ko": "양상 논리", "en": "Modal Logic" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 4,
    "content": {
      "ko": "필연성(□)과 가능성(◇) 개념을 다루는 논리 체계입니다. 크립키 의미론에서 가능 세계를 통해 해석됩니다.",
      "en": "A logical system dealing with necessity (□) and possibility (◇). Interpreted through possible worlds in Kripke semantics."
    },
    "latex": "\\Box\\varphi \\rightarrow \\varphi \\text{ (T)}, \\quad \\Box\\varphi \\rightarrow \\Box\\Box\\varphi \\text{ (4)}",
    "relations": {
      "prerequisites": ["propositional-logic", "first-order-logic"],
      "nextTopics": ["temporal-logic", "epistemic-logic"],
      "related": ["kripke-frames", "intuitionistic-logic"],
      "applications": ["program-verification", "philosophy", "linguistics"]
    },
    "tags": ["logic", "modal", "possible-worlds"]
  },
  {
    "id": "type-theory",
    "name": { "ko": "타입 이론", "en": "Type Theory" },
    "field": "logic",
    "subfield": "mathematical-logic",
    "difficulty": 5,
    "content": {
      "ko": "수학적 대상을 타입으로 분류하는 형식 체계입니다. 커리-하워드 대응으로 증명과 프로그램이 동일시됩니다.",
      "en": "A formal system classifying mathematical objects by types. Through the Curry-Howard correspondence, proofs correspond to programs."
    },
    "latex": "\\frac{\\Gamma, x:A \\vdash t:B}{\\Gamma \\vdash (\\lambda x.t) : A \\rightarrow B}",
    "relations": {
      "prerequisites": ["lambda-calculus", "first-order-logic"],
      "nextTopics": ["homotopy-type-theory", "dependent-types"],
      "related": ["constructive-mathematics", "category-theory"],
      "applications": ["proof-assistants", "programming-languages"]
    },
    "tags": ["logic", "type-theory", "curry-howard"]
  },
  {
    "id": "forcing",
    "name": { "ko": "강제법", "en": "Forcing" },
    "field": "logic",
    "subfield": "set-theory",
    "difficulty": 5,
    "content": {
      "ko": "집합론의 독립성 증명에 사용되는 기법입니다. 코헨이 연속체 가설의 독립성을 증명하는 데 사용했습니다.",
      "en": "A technique used to prove independence results in set theory. Used by Cohen to prove the independence of the continuum hypothesis."
    },
    "latex": "p \\Vdash \\varphi \\quad \\text{(p forces } \\varphi\\text{)}",
    "relations": {
      "prerequisites": ["set-theory", "model-theory"],
      "nextTopics": ["iterated-forcing", "proper-forcing"],
      "related": ["continuum-hypothesis", "independence-proofs"],
      "applications": ["foundations-of-mathematics", "infinite-combinatorics"]
    },
    "tags": ["logic", "set-theory", "forcing"]
  },
  {
    "id": "descriptive-set-theory",
    "name": { "ko": "기술집합론", "en": "Descriptive Set Theory" },
    "field": "logic",
    "subfield": "set-theory",
    "difficulty": 5,
    "content": {
      "ko": "실수 집합의 복잡도를 위계적으로 분류합니다. 보렐 집합, 해석적 집합, 사영 집합의 위계가 핵심입니다.",
      "en": "Hierarchically classifies the complexity of sets of reals. The hierarchies of Borel, analytic, and projective sets are central."
    },
    "latex": "\\Sigma^0_1 \\subset \\Sigma^0_2 \\subset \\cdots \\subset \\Sigma^1_1 \\subset \\Sigma^1_2 \\subset \\cdots",
    "relations": {
      "prerequisites": ["set-theory", "topology", "measure-theory"],
      "nextTopics": ["determinacy", "large-cardinals"],
      "related": ["computability-theory", "polish-spaces"],
      "applications": ["analysis", "dynamical-systems"]
    },
    "tags": ["logic", "set-theory", "analysis"]
  }
]
